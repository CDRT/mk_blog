{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the ThinkDeploy Blog","text":""},{"location":"about/","title":"About","text":""},{"location":"about/#our-mission","title":"Our Mission","text":"<p>At Lenovo we know that deploying large quantities of Windows PCs into an enterprise environment can be challenging.  The goal of the Commercial Deployment Readiness Team is to make deployments of our Think products as easy as possible for our commercial customers.  This page will describe some of the things we are doing to accomplish this.</p>"},{"location":"about/#enterprise-deployment-solutions-portal","title":"Enterprise Deployment Solutions portal","text":"<p>With a broad portfolio of products to support and the related content that goes with them, it can be a difficult task to identify where to find resources when help is needed.  The Lenovo Support website is designed to improve the ease of use and customer experience to expedite the search for the content a customer needs.  Specifically related to deploying and configuring our Think products, we have put together the Enterprise Deployment Solutions as a landing page aimed specifically at the IT administrators that are tasked with deploying large numbers of our Windows PC products into their environment.</p>"},{"location":"about/#enterprise-client-management-forum","title":"Enterprise Client Management Forum","text":"<p>The Commercial Deployment Readiness Team maintains working Configuration Manager and MDT lab environments so we can recreate customer issues that we receive through our Enterprise Client Management Forum. This forum is targeted again to those IT admins that are deploying and managing many Lenovo PCs. This is often the quickest way to get an answer to deployment questions. Our team monitors this forum daily and we also have some great members that offer answers and insights as well.</p>"},{"location":"about/#lenovo-cdrt-docs-site","title":"Lenovo CDRT Docs Site","text":"<p>We now have a consolidated site for documentation of items within the CDRT scope:  docs.lenovocdrt.com This site will contain the latest content from the team and cover items such as product guides for our Lenovo tools for administrators (Lenovo System Update Suite, Commercial Vantage, Think BIOS Config Tool, etc.), deployment guides for docking stations and BIOS updates, and any future topics we develop.</p>"},{"location":"autopilot--system-update--latest-drivers/","title":"Autopilot + System Update = Latest drivers","text":"<p>This post walks you through updating your Think product's drivers during Windows Autopilot using Lenovo System Update.</p> <p>Ideally, you'll want the most current drivers installed on the device prior to the user's first sign-in.  </p>"},{"location":"autopilot--system-update--latest-drivers/#prerequisites","title":"Prerequisites","text":"<ul> <li>~~Latest version of System Update~~ Script will install System Update via Microsoft's Winget PowerShell Module</li> <li>Microsoft's Win32 Content Prep tool</li> <li>Sample PowerShell script that performs the following:</li> <li>Installs PowerShell 7</li> <li>Installs Microsoft.Winget.Client PowerShell module, which allows us to install System Update via Winget</li> <li>Sets the AdminCommandLine registry value that will:<ul> <li>Download/install type 3 packages (drivers only). More info on package types can be found in the updated Deployment Guide.</li> <li>Writes the installation status of each update to WMI.</li> <li>Configures the System Update GUI</li> <li>Disables the default scheduled tasks created by System Update.</li> <li>Sets a custom scheduled task for System Update to run.</li> </ul> </li> </ul> <p>Save the below as Invoke-SystemUpdate.ps1: https://github.com/philjorgensen/Intune/blob/main/Autopilot/System%20Update/Invoke-SystemUpdate.ps1</p> Invoke-SystemUpdate.ps1<pre><code>&lt;# \nDISCLAIMER: \n\nThese sample scripts are not supported under any Lenovo standard support   \n\nprogram or service. The sample scripts are provided AS IS without warranty   \n\nof any kind. Lenovo further disclaims all implied warranties including,   \n\nwithout limitation, any implied warranties of merchantability or of fitness for   \n\na particular purpose. The entire risk arising out of the use or performance of   \n\nthe sample scripts and documentation remains with you. In no event shall   \n\nLenovo, its authors, or anyone else involved in the creation, production, or   \n\ndelivery of the scripts be liable for any damages whatsoever (including,   \n\nwithout limitation, damages for loss of business profits, business interruption,   \n\nloss of business information, or other pecuniary loss) arising out of the use   \n\nof or inability to use the sample scripts or documentation, even if Lenovo   \n\nhas been advised of the possibility of such damages.  \n#&gt; \n\n&lt;#\n.SYNOPSIS\n    Script to install and configure Lenovo System Update. \n\n.DESCRIPTION\n    Script will install Lenovo System Update and set the necessary registry subkeys and values that downloads/installs \n    reboot type 3 packages on the system. Certain UI settings are configured for an optimal end user experience.\n    The default scheduled task created by System Update will be disabled. A custom scheduled task for System Update will be created.\n\n.NOTES\n    FileName: Invoke-SystemUpdate.ps1\n    Author: Philip Jorgensen\n\n    Created:    2023-10-10\n    Change:     2024-04-15\n                    Switch to winget installation method using PowerShell 7 and the Microsoft.Winget.Client module\n                    Add logging\n                    Add soft reboot code to finish driver installation for drivers that may require it\n#&gt;\n\n$LogPath = Join-Path -Path (Join-Path -Path $env:ProgramData -ChildPath \"Lenovo\") -ChildPath \"SystemUpdate\"\nStart-Transcript -Path $LogPath\\Autopilot-SystemUpdate.log\n\n&lt;# \n    Credit to Andrew Taylor\n    https://github.com/andrew-s-taylor/public/blob/main/Powershell%20Scripts/Intune/deploy-winget-during-esp.ps1\n#&gt;\n#GitHub API endpoint for PowerShell releases\n$githubApiUrl = 'https://api.github.com/repos/PowerShell/PowerShell/releases/latest'\n\n#Fetch the latest release details\n$release = Invoke-RestMethod -Uri $githubApiUrl\n\n#Find asset with .msi in the name\n$asset = $release.assets | Where-Object { $_.name -like \"*msi*\" -and $_.name -like \"*x64*\" }\n\n#Get the download URL and filename of the asset (assuming it's a MSI file)\n$downloadUrl = $asset.browser_download_url\n$filename = $asset.name\n\n#Download the latest release\nInvoke-WebRequest -Uri $downloadUrl -OutFile $filename\n\n#Install PowerShell 7\nStart-Process msiexec.exe -Wait -ArgumentList \"/I $filename /qn\"\n\n#Start a new PowerShell 7 session\n$pwshExecutable = \"C:\\Program Files\\PowerShell\\7\\pwsh.exe\"\n\n#Run a script block in PowerShell 7\n&amp; $pwshExecutable -Command {\n    $provider = Get-PackageProvider -Name NuGet -ErrorAction Ignore\n    if (-not($provider))\n    {\n        Write-Host \"Installing provider NuGet\"\n        Find-PackageProvider -Name NuGet -ForceBootstrap -IncludeDependencies\n    }\n}\n&amp; $pwshExecutable -Command {\n    Install-Module -Name Microsoft.Winget.Client -Force -AllowClobber\n}\n&amp; $pwshExecutable -Command {\n    Import-Module -Name Microsoft.Winget.Client\n}\n&amp; $pwshExecutable -Command {\n    Repair-WinGetPackageManager\n}\n&amp; $pwshExecutable -Command {\n    Install-WinGetPackage -Id Lenovo.SystemUpdate\n}\n\n#Set SU AdminCommandLine\n$Key = \"HKLM:\\SOFTWARE\\Policies\\Lenovo\\System Update\\UserSettings\\General\"\n$Name = \"AdminCommandLine\"\n$Value = \"/CM -search A -action INSTALL -includerebootpackages 3 -noicon -noreboot -exporttowmi\"\n\n#Create subkeys if they don't exist\nif (-not(Test-Path -Path $Key))\n{\n    New-Item -Path $Key -Force | Out-Null\n    New-ItemProperty -Path $Key -Name $Name -Value $Value | Out-Null\n}\nelse\n{\n    New-ItemProperty -Path $Key -Name $Name -Value $Value -Force | Out-Null\n}\nWrite-Host \"AdminCommandLine value set\"\n\n#Configure System Update interface\n$Key2 = \"HKLM:\\SOFTWARE\\WOW6432Node\\Lenovo\\System Update\\Preferences\\UserSettings\\General\"\n$Values = @{\n\n    \"AskBeforeClosing\"     = \"NO\"\n\n    \"DisplayLicenseNotice\" = \"NO\"\n\n    \"MetricsEnabled\"       = \"NO\"\n\n    \"DebugEnable\"          = \"YES\"\n}\n\nif (Test-Path -Path $Key2)\n{\n    foreach ($Value in $Values.GetEnumerator() )\n    {\n        New-ItemProperty -Path $Key2 -Name $Value.Key -Value $Value.Value -Force\n    }\n}\nWrite-Host \"System Update GUI configured\"\n\n&lt;# \nRun SU and wait until the Tvsukernel process finishes.\nOnce the Tvsukernel process ends, Autopilot flow will continue.\n#&gt;\n$systemUpdate = \"$(${env:ProgramFiles(x86)})\\Lenovo\\System Update\\tvsu.exe\"\n&amp; $systemUpdate /CM\n\nWrite-Host \"Execute System Update and search for drivers\"\n\n#Wait for tvsukernel to initialize\nStart-Sleep -Seconds 15\nWait-Process -Name Tvsukernel\nWrite-Host \"Drivers installed\"\n\n#Disable the default System Update scheduled tasks\nGet-ScheduledTask -TaskPath \"\\TVT\\\" | Disable-ScheduledTask\nWrite-Host \"Default scheduled tasks disabled\"\n\n&lt;# \nDisable Scheduler Ability.  \nThis will prevent System Update from creating the default scheduled tasks when updating to future releases.\n#&gt; \n$schdAbility = \"HKLM:\\SOFTWARE\\WOW6432Node\\Lenovo\\System Update\\Preferences\\UserSettings\\Scheduler\"\nSet-ItemProperty -Path $schdAbility -Name \"SchedulerAbility\" -Value \"NO\"\n\n#Create a custom scheduled task for System Update\n$taskActionParams = @{\n    Execute  = $systemUpdate\n    Argument = '/CM'\n}\n$taskAction = New-ScheduledTaskAction @taskActionParams\n\n#Adjust to your requirements\n$taskTriggerParams = @{\n    Weekly     = $true\n    DaysOfWeek = 'Monday'\n    At         = \"9am\"\n}\n$taskTrigger = New-ScheduledTaskTrigger @taskTriggerParams\n$taskUserPrincipal = New-ScheduledTaskPrincipal -UserId 'SYSTEM'\n$taskSettings = New-ScheduledTaskSettingsSet -Compatibility Win8\n\n$newTaskParams = @{\n    TaskPath    = \"\\TVT\\\"\n    TaskName    = \"Custom-RunTVSU\"\n    Description = \"System Update searches and installs new drivers only\"\n    Action      = $taskAction\n    Principal   = $taskUserPrincipal\n    Trigger     = $taskTrigger\n    Settings    = $taskSettings\n}\nRegister-ScheduledTask @newTaskParams -Force | Out-Null\nWrite-Host \"Custom scheduled task created\"\nWrite-Host \"Exiting with a 3010 return code for a soft reboot to complete driver installation.\"\nStop-Transcript\nExit 3010\n</code></pre>"},{"location":"autopilot--system-update--latest-drivers/#preparing-the-win32-app-old-method","title":"Preparing the Win32 App (Old method)","text":"<p>Once all pre-requisites are downloaded to a source location, run the Content Prep tool to package the content as an .intunewin package. A sample command would be:</p> <pre><code>IntuneWinAppUtil.exe -c \"C:\\SU\\\" -s \"Configure-TVSUandScheduledTask.ps1\" -o \"C:\\SU\\output\"\n</code></pre> <p></p>"},{"location":"autopilot--system-update--latest-drivers/#preparing-the-win32-app-new-method","title":"Preparing the Win32 App (New method)","text":"<p>Download the Invoke-SystemUpdate.intunewin app from GitHub or</p> <p>Using the Win32 Content Prep tool, create your own .intunewin file. Example:</p> <pre><code>intunewinapputil.exe -c .\\SU -s Invoke-SystemUpdate.ps1 -o .\\ -q\n</code></pre>"},{"location":"autopilot--system-update--latest-drivers/#add-win32-app","title":"Add Win32 App","text":"<p>Add a new Win32 app in Intune. Select the .intunewin app created earlier and click ok to upload.</p> <p>Fill out the necessary information for each section.</p> <p></p> <p>For the Install command enter the following:</p> <pre><code>powershell.exe -ExecutionPolicy Bypass -File .\\Invoke-SystemUpdate.ps1\n</code></pre> <p>Uninstall command to uninstall System Update:</p> <pre><code>\"%ProgramFiles(x86)%\\Lenovo\\System Update\\unins000.exe\" /SILENT\n</code></pre> <p></p> <p>Additional Requirement type: Registry</p> <ul> <li>Key path: HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS</li> <li>Value name: SystemManufacturer</li> <li>Registry key requirement: String comparison</li> <li>Operator: Equals</li> <li>Value: LENOVO This ensures the app will only run on Lenovo systems</li> </ul> <p></p> <p>Detection rule type: File</p> <p></p> <ul> <li>Path: %ProgramData%\\Lenovo\\SystemUpdate\\sessionSE</li> <li>File or folder: update_history.txt</li> <li>Detection method: File or folder exists</li> </ul> <p></p> <p>The update_history.txt is generated since we're specifying the -exporttowmi switch in the AdminCommandLine.  Since the system will be going through Autopilot for the first time, this obviously won't be present.</p> <p>Assign the app to a group containing Autopilot registered devices.</p> <p>If you already have an Enrollment Status Page profile configured, add this app to the list of selected apps that are required to install before the device can be used.  This ensures System Update completes before proceeding to the next phase.</p> <p></p>"},{"location":"autopilot--system-update--latest-drivers/#viewing-the-results","title":"Viewing the Results","text":"<p>A look through the IntuneManagementExtension.log, you'll see the update_history.txt file was not detected</p> <p></p> <p>Several minutes later, it's now detected</p> <p></p> <p>You can then run the following PowerShell command to see which updates were installed</p> <pre><code>Get-ChildItem -Path C:\\ProgramData\\lenovo\\SystemUpdate\\sessionSE\\update_history.txt | Select-String -SimpleMatch \"Success\" | fl Line\n</code></pre> <p>The screenshot below shows the results from a ThinkPad T480s preloaded with Windows 10 1903. 13 drivers updated successfully!</p> <p></p>"},{"location":"autopilot--thin-installer--current-driversbiosfirmware/","title":"Autopilot + Thin Installer = Current Drivers/BIOS/Firmware","text":"<p>Revisiting a solution from 2020 that leverages Lenovo System Update to update drivers during Autopilot which provided a way to ensure devices were up-to-date before handing off to end users.</p> <p>Fast forward to this 2023 Configuration Manager OSD solution that will update drivers, BIOS, and firmware got me thinking: How awesome would it be to migrate this to Autopilot world and really provide users with completely up-to-date devices right out of the gate?</p>"},{"location":"autopilot--thin-installer--current-driversbiosfirmware/#scenario","title":"Scenario","text":"<p>This solution works best when performing an Autopilot for pre-provisioned deployment. Depending on the number of applicable updates, especially BIOS or firmware, I have seen some systems take ~30 minutes to complete during my testing. As we all know, the goal of Autopilot is for the end user to have a quick and painless experience.</p>"},{"location":"autopilot--thin-installer--current-driversbiosfirmware/#requirements","title":"Requirements","text":"<p>You'll need the following pieces to get started:</p> <ul> <li>Current version of Lenovo Thin Installer - Download here</li> <li>Win32 Content Prep tool - Download here</li> <li>Autopilot session detection script:</li> </ul> <p>https://github.com/philjorgensen/Intune/blob/main/Autopilot/Thin%20Installer/Detect-AutopilotSession.ps1</p> <ul> <li>PowerShell script  Get-LnvUpdates.ps1 for the magic:</li> </ul> <p>https://github.com/philjorgensen/Intune/blob/main/Autopilot/Thin%20Installer/Get-LnvUpdates.ps1</p>"},{"location":"autopilot--thin-installer--current-driversbiosfirmware/#solution","title":"Solution","text":"<p>Typically, Update Retriever is used to download updates from the Lenovo Support site to a repository folder on a local drive or network share in which Thin Installer can be configured to search for and install updates from. This solution eliminates the need for Update Retriever and instead will build out the repository locally on the device followed by invoking Thin Installer to handle the installation of applicable updates.</p>"},{"location":"autopilot--thin-installer--current-driversbiosfirmware/#building-the-win32-applications","title":"Building the Win32 Applications","text":"<p>Create a folder structure for the source files.</p> <ul> <li> <p>C:\\IntuneWin32\\Source\\ThinInstaller\\lenovo_thininstaller_1.04.01.0004.exe</p> </li> <li> <p>C:\\IntuneWin32\\Source\\Get-LnvUpdates\\Get-LnvUpdates.ps1</p> </li> </ul> <p>Use the Win32 Content Prep tool to create an .intunewin package for Thin Installer and Get-LnvUpdates</p> <pre><code>IntuneWinAppUtil.exe -c \"C:\\IntuneWin32\\Source\\ThinInstaller\\\" -s lenovo_thininstaller_1.04.01.0004.exe -o C:\\IntuneWin32\\Output -q\n</code></pre> <pre><code>IntuneWinAppUtil.exe -c \"C:\\IntuneWin32\\Source\\Get-LnvUpdates\\\" -s Get-LnvUpdates.ps1 -o C:\\IntuneWin32\\Output -q\n</code></pre>"},{"location":"autopilot--thin-installer--current-driversbiosfirmware/#adding-the-apps","title":"Adding the Apps","text":"<p>Login to the Intune admin center and add a new Windows app (Win32). Select the lenovo_thininstaller_1.04.01.0004.intunewin app package file.</p> <ul> <li>Fill out the required App information fields and any optional fields.</li> <li>For Program information, specify the Install command</li> </ul> <pre><code>lenovo_thininstaller_1.04.01.0004.exe /verysilent /norestart\n</code></pre> <p>Since Thin Installer requires no installation and does not write anything to the Registry, simply removing the directory can be used for the Uninstall command</p> <pre><code>cmd.exe /c rmdir /s /q \"C:\\Program Files (x86)\\Lenovo\\ThinInstaller\"\n</code></pre> <ul> <li> <p>Set the Install behavior to System</p> </li> <li> <p>Set the Operating system architecture to 64-bit (you could tick both 32-bit as well but who's still deploying 32-bit Windows?)</p> </li> <li>Set the Minimum operating system to Windows 10 1607 (or whatever OS build you choose)</li> <li>Skip Requirements</li> <li>For Detection rules, choose File for the rule type and specify the following:<ul> <li>Path: %ProgramFiles%\\Lenovo\\ThinInstaller</li> <li>File or folder: ThinInstaller.exe</li> <li>Detection method: File or folder exists</li> <li>Associated with a 32-bit app on 64-bit clients: Yes</li> </ul> </li> </ul> <p>Review + save to create the Thin Installer app</p> <p>Let's create the second app. Repeat the above steps to add a new Win32 app, selecting the Get-LnvUpdates.intunewin app package file.</p> <ul> <li>The Install command will be calling the PowerShell script along with a handful of parameters to pass</li> </ul> <p>Depending on your requirements, you can change the values for each parameter. For this solution, I'm essentially \"throwing the kitchen sink\" at the device so all applicable updates are installed.</p> <pre><code>powershell.exe -NoProfile -ExecutionPolicy Bypass -File \".\\Get-LnvUpdates.ps1\" -PackageTypes \"1,2,3,4\" -RebootTypes \"0,3,5\" -RT5toRT3 -Install\n</code></pre> <ul> <li>There's really no need for an Uninstall command but since it's required. Just enter</li> </ul> <pre><code>cmd.exe /c\n</code></pre> <ul> <li>Set the Install behavior to System</li> <li>Set the Device restart behavior to Determine behavior based on return codes. The script will flag Intune for a Soft reboot after the updates have been installed.</li> <li>On the Requirements section, add an additional Script requirement rule, specifying the Detect-AutopilotSession.ps1 file. Since this is intended for Autopilot, we don't want this running post deployment when a user is logged in.<ul> <li>Run script as 32-bit process on 64-bit clients: No</li> <li>Run this script using the logged on credentials: No</li> <li>Enfor script signature check: No</li> <li>Select output data type: Boolean</li> <li>Operator: Equals</li> <li>Value: Yes</li> </ul> </li> <li>For detection rules, we'll add another File rule type.<ul> <li>Path: %ProgramFiles%\\Lenovo\\ThinInstaller\\logs</li> <li>File or folder: update_history.txt</li> <li>Detection method: File or folder exists</li> <li>Associated with a 32-bit app on 64-bit clients: Yes</li> </ul> </li> </ul> <p>The update_history.txt is generated after Thin Installer has completed the update process.</p> <p>Review + save to create the app. Once it's created, head back to the properties, add the Thin Installer app we created earlier as a dependency and configure it to Automatically Install.</p>"},{"location":"autopilot--thin-installer--current-driversbiosfirmware/#deploy","title":"Deploy","text":"<p>Deploy the Get Lenovo Updates Win32 app to a device group. Since this is intended for Autopilot devices, I'm going to deploy to a dynamic device group containing all of my Autopilot devices.</p> <p>You'll also need to adjust the Enrollment Status Page (ESP) settings.</p> <p>Under the Block device use until required apps are installed if they are assigned to the user/device, add the Get Lenovo Updates app to the list here.</p> <p></p>"},{"location":"autopilot--thin-installer--current-driversbiosfirmware/#checking-the-results","title":"Checking the Results","text":"<p>Note</p> <p>If you've installed Windows from media and are only using inbox drivers, you may need to increase the ESP timeout.</p> <p>Prior to resealing the device and handing off to the user, you can review the results of the installation log found under C:\\Program Files(x86)\\Lenovo\\ThinInstaller\\logs</p> <p>On my test device, you can see almost a dozen drivers have been updated, including the BIOS</p> <p></p> <p>Warning</p> <p>In a Self-Deploy scenario, you may need to use a Registry requirement rule for detection instead of Detect-AutopilotSession.ps1. The rule type parameters should be as follows:</p> <ul> <li>Key path: HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon</li> <li>Value name: DefaultUserName</li> <li>Registry key requirement: Select String comparison</li> <li>Operator: Select Equals</li> <li>Value: defaultuser0</li> </ul>"},{"location":"arm-based-operating-system-deployment/","title":"Arm-based Operating System Deployment","text":"<p>Operating System Deployment support for Windows 11 ARM 64 devices is now supported in the 2403 release of Configuration Manager. This guide will demonstrate how to deploy Windows 11 to the Qualcomm equipped ThinkPad X13s and T14s Gen 6.</p>"},{"location":"arm-based-operating-system-deployment/#thinkpad-x13s","title":"ThinkPad X13s","text":""},{"location":"arm-based-operating-system-deployment/#adk","title":"ADK","text":"<p>At the time of initially publishing this article, I had installed the September 2023 ADK (10.1.25398.1) and the Windows PE add-on. This version is required for Windows ARM deployments. If you need to update the ADK from a previous version, do so before updating Configuration Manager. This will allow the default boot images to be automatically updated to the latest Win PE version.</p>"},{"location":"arm-based-operating-system-deployment/#site-update","title":"Site Update","text":"<p>Update 2403 is an in-console update. If you're upgrading, make sure to go through the install checklist before applying the update. If everything goes smoothly, you'll now see a new boot image in the console.</p> <p></p> <p></p>"},{"location":"arm-based-operating-system-deployment/#pxe-configuration","title":"PXE Configuration","text":"<p>During testing, the Distribution Point in my lab was configured for SCCM's PXE responder service (WDS-less). However, if you're going to deploy an ARM-based device, WDS PXE is the only way to do it (for now). Rather than messing with my existing one, I went ahead and stood up another DP in my lab and configured it for WDS PXE.</p> <p></p>"},{"location":"arm-based-operating-system-deployment/#drivers","title":"Drivers","text":"<p>Next will be adding the right drivers to the boot image. When I initially PXE booted the X13s using a USB-C to Ethernet adapter, I successfully got into WinPE, but there was no touchpad/trackpoint or keyboard support so that left me dead in the water. At the time of this writing, the latest SCCM pack for X13s was released on April 5. You'll want to download the Windows 11 22H2 pack and extract the contents to your driver share.</p> <p>In the console, go to Software Library &gt; Drivers and click Import Driver in the ribbon bar to start the driver import wizard.</p>"},{"location":"arm-based-operating-system-deployment/#boot-image","title":"Boot Image","text":"<p>We're only going to import the Boot Critical drivers. Referencing the SCCM pack ReadMe, the Build ID for these drivers is N3HQC12W and can be found under the Chipset directory. The path to this directory is what you'll specify in the wizard to import.</p> <p></p> <p>Wait several minutes for the drivers (52 total) to be imported to the driver catalog. Once that clears, keep the defaults checked and assign the drivers a category, optional of course. I created a X13s and WinPE category for organization purposes.</p> <p></p> <p>Skip to select packages to add the drivers to.</p> <p>On the Select drivers to include in the boot image, tick the box beside the Boot image (arm64) and click next, which will then present you with this prompt</p> <p></p> <p>Click Yes and you'll be greeted with one more</p> <p></p> <p>Click next all the way through to complete adding the drivers to your boot image.</p> <p>If you pull up the boot image properties and click on the Drivers tab, you should see all of the injected drivers</p> <p></p> <p>With the properties still open, enable command line support under the Customization tab and add any other Optional Components, such as PowerShell support. Update Distribution Points and your boot image is ARM ready.</p>"},{"location":"arm-based-operating-system-deployment/#driver-package","title":"Driver Package","text":"<p>I tested both ways for driver installation. A Driver Package and a legacy Package containing the extracted drivers. I prefer the latter, so in the console, go to Software Library &gt; Packages and create a new Package. Give it a name, tick the box beside This package contains source files, and point it to the path on your share where you extracted the drivers. Click the radio button beside Do not create a program and finish out the wizard. Distribute the Package to your Distribution Points.</p>"},{"location":"arm-based-operating-system-deployment/#windows-11-arm-media","title":"Windows 11 ARM Media","text":"<p>Download the Windows 11 ARM ISO and add the install.wim under Software Library &gt; Operating System Images. This is 24H2 Enterprise</p> <p></p>"},{"location":"arm-based-operating-system-deployment/#task-sequence","title":"Task Sequence","text":"<p>Create a new Task Sequence, selecting the option to Install an existing image package. Name it and choose the Arm boot image</p> <p></p> <p>Choose the Windows 11 Arm image package and proceed through the Task Sequence creation wizard.</p> <p>Once complete, edit the Task Sequence and disable the default step to apply drivers.</p> <ul> <li>Create a new group titled Drivers. Under that group, add a Download Package Content step and add the driver package created earlier. I'll tick the radio button to save the content to a custom path of %_SMSTSMDataPath%\\Drivers</li> </ul> <p>More info on TS variables can be found here https://learn.microsoft.com/mem/configmgr/osd/understand/task-sequence-variables#SMSTSMDataPath</p> <p></p> <ul> <li>Add a Run Command Line step that calls Dism to recursively install the drivers.</li> </ul> <pre><code>DISM.exe /Image:%OSDTargetSystemDrive%\\ /Add-Driver /Driver:%_SMSTSMDataPath%\\Drivers /Recurse /LogPath:%_SMSTSLogPath%\\DISM.log\n</code></pre> <p></p> <p>Now deploy the Task Sequence to the Unknown Computers device collection.</p>"},{"location":"arm-based-operating-system-deployment/#experience","title":"Experience","text":"<p>Firing up the X13s and F12'ing to the boot menu to PXE</p> <p></p> <p>Boot image incoming!</p> <p></p> <p>Unfortunately, we have a resolution problem which I can't seem to get sorted. I've even tried dumping the entire driver pack in the boot image but that didn't fix it. On the bright side, you can kick off your Task Sequence.</p> <p></p> <p>Successful deployment with a clean Device Manager!</p> <p></p> <p></p>"},{"location":"arm-based-operating-system-deployment/#thinkpad-t14s-gen-6","title":"ThinkPad T14s Gen 6","text":""},{"location":"arm-based-operating-system-deployment/#adk_1","title":"ADK","text":"<p>At the time of updating this article, my ConfigMgr environment is at version 2403 with ADK 10.1.26100 (May 2024) installed.</p>"},{"location":"arm-based-operating-system-deployment/#boot-image_1","title":"Boot Image","text":"<p>Looking at the ARM64 boot image properties, the version is 10.0.26100.</p> <p></p> <p>Switching to the Drivers tab, you can see no additional drivers have been injected.</p> <p></p>"},{"location":"arm-based-operating-system-deployment/#pxe-boot","title":"PXE Boot","text":"<p>On my T14s Gen 6, I'll activate System Deployment Boot Mode at the boot menu and proceed to PXE booting</p> <p></p> <p>Here, I can see the ARM64 boot image downloading (package ID matches)</p> <p></p>"},{"location":"arm-based-operating-system-deployment/#task-sequence_1","title":"Task Sequence","text":"<p>We've now entered PE and can continue to choose a task sequence. Remember, no drivers were added to the boot image so the fact that we can see the wizard confirms inbox driver support for this model.</p> <p>The SCCM pack for T14s Gen 6 can be downloaded here</p> <p>The HSA pack can be downloaded here</p> <p></p> <p></p>"},{"location":"arm-based-operating-system-deployment/#end-results","title":"End Results","text":"<p>Once OSD completes, I can see a clean device manager.</p> <p></p>"},{"location":"collecting-and-storing-lenovo-warranty--information-to-azure-monitor/","title":"Collecting and Storing Lenovo Warranty <br> Information to Azure Monitor","text":"<p>A feature add (by popular demand) in Commercial Vantage is the ability to write the device's warranty information to WMI.  </p> <p>The Lenovo_WarrantyInformation WMI class located under the root\\Lenovo Namespace is created when the Write Warranty Information to WMI policy has been enabled on the device.</p> <p>In this post, we're going to walk through how this data can be collected from Intune managed devices and ingested into a Log Analytics Workspace in Azure Monitor.</p> <p>The solution is derived from an excellent Microsoft blog post, which provides an example of collecting BIOS information.  Admittedly, I haven't explored the depths of Graph and was surprised to read that script outputs are stored in a resultMessage property on the service side, as noted in the post.  </p> <p>Once I got the grasp of the workflow, I thought why not try and go after warranty information?  Stepping outside of my comfort zone, I decided to take this a bit further by delving into Log Analytics and Azure Automation to automate the collection of this data using a scheduled Runbook.  Fortunately, the MS docs have been incredibly helpful during my testing.</p> <p>Before you begin, make sure your test devices have the latest version of Commercial Vantage installed and the GPO to write warranty information to WMI has been configured.  Refer to this blog post on how to deploy the setting with Intune or you can configure it manually using the provided .Admx template loaded into the local Group Policy Editor.  You can verify data has been written to WMI by browsing to the namespace using WMIExplorer.</p> <p>Deploy this PowerShell script to a user/device group to get started</p> <pre><code>Get-CimInstance -Namespace root/Lenovo -ClassName Lenovo_WarrantyInformation | Select-Object `\n    SerialNumber, `\n    Product, `\n    StartDate, `\n    EndDate, `\n    LastUpdateTime | ConvertTo-Json\n</code></pre> <p>Once you're starting to see script execution has succeeded on your devices in the MEM admin center, access the data via Graph as demonstrated in the blog post referenced earlier.</p> <p>Here's an example of what you should expect to see in Graph Explorer.</p> <p></p> <p>Now that we have data, we're going to send this to the Azure Monitor HTTP Data Collector API using PowerShell.  You'll need to note the Workspace ID and Primary Key of the Log Analytics workspace you intend on using.</p> <p>You can find this information under Log Analytics workspace &gt; Agents management</p> <p></p> <p>Next, we're going to setup a PowerShell Runbook that will create a POST request to the HTTP Data Collector API that includes our list of devices to send.</p>"},{"location":"collecting-and-storing-lenovo-warranty--information-to-azure-monitor/#prerequisites","title":"Prerequisites","text":"<p>Azure Automation account.  If you haven't created one, refer to the MS doc on how to do this.</p> <p>Intune PowerShell SDK, which provides support for the Intune API through Graph.  This module will need to be imported from the PowerShell Gallery into Azure Automation before proceeding.  Here's a short script to do so:</p> <pre><code>$ResourceGroup = '&lt;your resource group&gt;'\n$AutomationAccount = '&lt;your automation account&gt;'\n\n# URL to Graph package: https://www.powershellgallery.com/packages/Microsoft.Graph.Intune\nif (!(Get-AzAutomationModule -ResourceGroupName $ResourceGroup -AutomationAccountName $AutomationAccount | Where-Object { $_.Name -eq $ModuleName -and $_.ProvisioningState -eq 'Succeeded' })) {\n    New-AzAutomationModule -Name $ModuleName -ResourceGroupName $ResourceGroup -AutomationAccountName $AutomationAccount -ContentLinkUri 'https://www.powershellgallery.com/api/v2/package/Microsoft.Graph.Intune/6.1907.1.0'\n}\n</code></pre> <p>Verify the module's status shows Available</p> <p></p> <p>Two Azure Automation string type variables that will hold an Azure user account/encrypted password to authenticate to Graph (make sure this account has the appropriate permissions).  These will be called using the Get-AutomationVariable internal cmdlets.</p> <p></p> <p>Once everything is ready to go, choose the Azure Automation account you want to use and click Runbooks and Create a runbook.  Enter a name and choose PowerShell for the runbook type.</p> <p>I've adjusted the PowerShell sample to include the JSON data that will be ingested to the Log Analytics Workspace.  You'll need to replace the $CustomerId and $SharedKey variables with your Workspace ID and Primary Key.  I've also set the $LogType variable to WarrantyInformation as this will be the name of the Custom Log that's created to store exactly what we're collecting, warranty information.</p> <p>Copy/paste the below script to your runbook</p> <pre><code>&lt;#\nSet internal automation cmdlets for Graph authentication\nReference: https://docs.microsoft.com/en-us/azure/automation/shared-resources/variables?tabs=azure-powershell#internal-cmdlets-to-access-variables\n#&gt;\n$AdminUser = Get-AutomationVariable -Name 'AdminUser'\n$AdminPassword = Get-AutomationVariable -Name 'AdminPassword'\n$SecureAdminPassword = ConvertTo-SecureString -String $AdminPassword -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential ($AdminUser, $SecureAdminPassword)\n\n# Connect to Graph Beta API\nUpdate-MSGraphEnvironment -SchemaVersion 'beta'\nConnect-MSGraph -PSCredential $Cred | Out-Null\n\n&lt;# \nGather warranty info from successful script executions\nReference: https://techcommunity.microsoft.com/t5/device-management-in-microsoft/how-to-collect-custom-inventory-from-azure-ad-joined-devices/ba-p/2280850#.YIGt2nOrV50.linkedin\n#&gt;\n$result = Invoke-MSGraphRequest -HttpMethod GET -Url 'deviceManagement/deviceManagementScripts/&lt;script id&gt;/deviceRunStates?$expand=managedDevice' | Get-MSGraphAllPages\n$success = $result | Where-Object -Property errorCode -EQ 0\n$resultMessage = $success.resultMessage \n$Devices = $resultMessage | ConvertFrom-Json\n$newjson = $Devices | ConvertTo-Json\n\n&lt;#\nBelow sample request reference:\nhttps://docs.microsoft.com/en-au/azure/azure-monitor/logs/data-collector-api?WT.mc_id=EM-MVP-5002871&amp;ranMID=24542&amp;ranEAID=je6NUbpObpQ&amp;ranSiteID=je6NUbpObpQ-Kk7A3ox8I8XgrRn0d4uDfA&amp;epi=je6NUbpObpQ-Kk7A3ox8I8XgrRn0d4uDfA&amp;irgwc=1&amp;OCID=AID2000142_aff_7593_1243925&amp;tduid=(ir__nxnprvrvwwkfq3kekk0sohzncu2xuln0dh1bwc9k00)(7593)(1243925)(je6NUbpObpQ-Kk7A3ox8I8XgrRn0d4uDfA)()&amp;irclickid=_nxnprvrvwwkfq3kekk0sohzncu2xuln0dh1bwc9k00#sample-requests\n#&gt;\n\n# Replace with your Workspace ID\n$CustomerId = \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"  \n\n# Replace with your Primary Key\n$SharedKey = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n\n# Specify the name of the record type that you'll be creating\n$LogType = \"WarrantyInformation\"\n\n# You can use an optional field to specify the timestamp from the data. If the time field is not specified, Azure Monitor assumes the time is the message ingestion time\n$TimeStampField = \"\"\n\n# Create the function to create the authorization signature\nFunction Build-Signature ($customerId, $sharedKey, $date, $contentLength, $method, $contentType, $resource)\n{\n    $xHeaders = \"x-ms-date:\" + $date\n    $stringToHash = $method + \"`n\" + $contentLength + \"`n\" + $contentType + \"`n\" + $xHeaders + \"`n\" + $resource\n\n    $bytesToHash = [Text.Encoding]::UTF8.GetBytes($stringToHash)\n    $keyBytes = [Convert]::FromBase64String($sharedKey)\n\n    $sha256 = New-Object System.Security.Cryptography.HMACSHA256\n    $sha256.Key = $keyBytes\n    $calculatedHash = $sha256.ComputeHash($bytesToHash)\n    $encodedHash = [Convert]::ToBase64String($calculatedHash)\n    $authorization = 'SharedKey {0}:{1}' -f $customerId,$encodedHash\n    return $authorization\n}\n\n\n# Create the function to create and post the request\nFunction Post-LogAnalyticsData($customerId, $sharedKey, $body, $logType)\n{\n    $method = \"POST\"\n    $contentType = \"application/json\"\n    $resource = \"/api/logs\"\n    $rfc1123date = [DateTime]::UtcNow.ToString(\"r\")\n    $contentLength = $body.Length\n    $signature = Build-Signature `\n        -customerId $customerId `\n        -sharedKey $sharedKey `\n        -date $rfc1123date `\n        -contentLength $contentLength `\n        -method $method `\n        -contentType $contentType `\n        -resource $resource\n    $uri = \"https://\" + $customerId + \".ods.opinsights.azure.com\" + $resource + \"?api-version=2016-04-01\"\n\n    $headers = @{\n        \"Authorization\" = $signature;\n        \"Log-Type\" = $logType;\n        \"x-ms-date\" = $rfc1123date;\n        \"time-generated-field\" = $TimeStampField;\n    }\n\n    $response = Invoke-WebRequest -Uri $uri -Method $method -ContentType $contentType -Headers $headers -Body $body -UseBasicParsing\n    return $response.StatusCode\n\n}\n\n# Submit the data to the API endpoint\nPost-LogAnalyticsData -customerId $customerId -sharedKey $sharedKey -body ([System.Text.Encoding]::UTF8.GetBytes($newjson)) -logType $logType\n</code></pre> <p>Click on Test pane and click on Start.  After a few seconds, you should see Complete</p> <p></p> <p>Let's check out the new Custom Log in our workspace.  Click the Custom logs blade.  There should now be a WarrantyInformation_CL visible.  Notice the type is Ingestion API.  </p> <p></p> <p>Head over to the Azure Monitor Logs and run the following query to see our devices.</p> <pre><code>WarrantyInformation_CL\n| order by Product_s\n| distinct Product_s, StartDate_s, EndDate_s\n</code></pre> <p></p> <p>Yay!  Warranty data!</p> <p>If you don't need to make any further changes with the Runbook, click on Publish.  </p> <p>Another example would be if you wanted to only show devices whose Warranty ended in the year 2020, you could run this query</p> <pre><code>WarrantyInformation_CL\n| distinct SerialNumber_s, Product_s, StartDate_s, EndDate_s\n| where EndDate_s contains \"2020\"\n</code></pre> <p></p> <p>You can also pin a specific query to your dashboard if you desire</p> <p> </p> <p>Now we can set up a recurring schedule for the Runbook to monitor our fleet's warranty.</p>"},{"location":"reporting-bios-password-states-on--think-products-with-configmgr/","title":"Reporting BIOS Password States on <br> Think Products with ConfigMgr","text":"<p>There may be a need to run a report on your Think products to check which BIOS settings are enabled or disabled, or if there is even a BIOS supervisor password set.</p> <p>This post will walk through creating a simple custom report in ConfigMgr that will display the following:</p> <ul> <li>All Lenovo Think products</li> <li>Model (Friendly Names)</li> <li>Computer Name</li> <li>BIOS Version</li> <li>Is TPM Enabled?</li> <li>Is TPM Activated?</li> <li>Secure Boot Status</li> <li>UEFI Enabled?</li> <li>Device Guard in BIOS Enabled?</li> <li>BIOS Password(s) Set</li> </ul>"},{"location":"reporting-bios-password-states-on--think-products-with-configmgr/#extending-hardware-inventory","title":"Extending Hardware Inventory","text":"<p>More info</p> <p>First, you'll need to extend hardware inventory.  To make this a bit easier, there's a zip at the bottom of the page you can download that contains a MOF file you can import into your Default Client Settings that will add these classes</p> <ul> <li>Lenovo_BiosSetting</li> <li>Lenovo_Bios PasswordSettings</li> </ul> <p>Open the Default Client Settings, select Hardware Inventory, and click Set Classes</p> <p></p> <p>On the Hardware Inventory Class window, click Import.  Select the MOF file containing the Lenovo WMI Classes.  Leave the default radio button selected to import both the inventory classes and settings and Click Import.  Click Ok to complete.</p> <p></p> <p></p> <p>Once the clients receive the updated Client Settings, the two Lenovo classes will be inventoried and can be reviewed in Resource Explorer.  If you have a mixed environment of different vendors, it may be a good idea to create Custom Client Settings and deploy only to a Collection containing Lenovo hardware.</p> <p>Creating a Custom Report</p> <p>Also at the bottom of the page is a sample report you can import into your SSRS.  Assuming you have the Reporting Services Point role installed and configured, find the URL of your Report Manager.  This can be found in the Console under the Monitoring Workspace / Reporting Node</p> <p></p> <p>Open Internet Explorer, navigate to the Report Manager URL and choose a path to upload the report to.  Once uploaded, edit the report in Report Builder.  You'll need to replace the Data Source and make any other customizations to fit your environment.  Here's an example of what will be presented</p> <p></p> <p>You'll notice in the example, different values under the BIOS Password(s) column.  These correspond to the integer that's displayed in the Password State property when querying the Lenovo_BiosPasswordSettings class.  There were 8 new values introduced in the Whisky Lake generation of ThinkPad.  Complete list below:</p> <p>0   |   No BIOS Password Set</p> <p>1   |   Only Power On Password</p> <p>2   |   Only Supervisor Password</p> <p>3   |   User HDD and/or User HDD and Master Password</p> <p>5   |   Power On + User HDD and/or User HDD and Master Password</p> <p>6   |   Supervisor + User HDD and/or User HDD and Master Password</p> <p>7   |   Supervisor + Power On + User HDD and/or User HDD and Master Password</p> <p>64  |   Only System Management Password</p> <p>65  |   System Management + Power On Password</p> <p>66  |   Supervisor + System Management Password</p> <p>67  |   Supervisor + System Management + Power On Password</p> <p>68  |   System Management + User HDD and/or User HDD Master Password</p> <p>69  |   System Management + Power On + User HDD and/or User HDD Master Password</p> <p>70  |   Supervisor + System Management + User HDD and/or User HDD Master Password</p> <p>71  |   Supervisor + System Management + Power On + User HDD and/or User HDD Master Password</p> <p>I'm by no means an SQL expert but below is the query used to pull this data:</p> <pre><code>SELECT DISTINCT\n  SMS_G_System_COMPUTER_SYSTEM.Manufacturer00 AS 'Manufacturer',\n  __em_COMPUTER_SYSTEM_PRODUCT0.Version00 AS 'Model',\n  SMS_G_System_COMPUTER_SYSTEM.Name00 AS 'Computer Name',\n  SMS_G_System_PC_BIOS.SMBIOSBIOSVersion00 AS 'BIOS Version',\n  CASE\n    WHEN SMS_G_System_TPM.IsEnabled_InitialValue00 = 1 THEN 'Yes'\n    ELSE 'No'\n  END AS 'TPM Enabled',\n  CASE\n    WHEN SMS_G_System_TPM.IsActivated_InitialValue00 = 1 THEN 'Yes'\n    ELSE 'No'\n  END AS 'TPM Activated',\n  CASE\n    WHEN SMS_G_System_FIRMWARE.SecureBoot00 = 1 THEN 'Enabled'\n    ELSE 'Disabled'\n  END AS 'Secure Boot',\n  CASE\n    WHEN SMS_G_System_FIRMWARE.UEFI00 = 1 THEN 'Enabled'\n    ELSE 'Disabled'\n  END AS 'UEFI',\n  CASE\n    WHEN ___System_LENOVO_BIOSSETTING2.CurrentSetting00 LIKE 'Device Guard,Enabled%' THEN 'Enabled'\n    WHEN ___System_LENOVO_BIOSSETTING2.CurrentSetting00 LIKE 'DeviceGuard,Enable%' THEN 'Enabled'\n    ELSE 'Disabled'\n  END AS 'Device Guard',\n  CASE\n    WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 1 THEN 'Only Power On Password'\n    WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 2 THEN 'Only Supervisor Password'\n    WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 3 THEN 'Supervisor + Power On Password'\n    WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 4 THEN 'User HDD and/or User HDD and Master Password'\n    WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 5 THEN 'Power On + User HDD and/or User HDD and Master Password'\n    WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 6 THEN 'Supervisor + User HDD and/or User HDD and Master Password'\n    WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 7 THEN 'Supervisor + Power On + User HDD and/or User HDD and Master Password'\n    WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 64 THEN 'Only System Management Password'\n WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 65 THEN 'System Management + Power On Password'\n    WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 66 THEN 'Supervisor + System Management Password'\n WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 67 THEN 'Supervisor + System Management + Power On Password'\n WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 68 THEN 'System Management + User HDD and/or User HDD Master Password'\n WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 69 THEN 'System Management + Power On + User HDD and/or User HDD Master Password'\n WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 70 THEN 'Supervisor + System Management + User HDD and/or User HDD Master Password'\n WHEN __ENOVO_BIOSPASSWORDSETTINGS1.PasswordState00 = 71 THEN 'Supervisor + System Management + Power On + User HDD and/or User HDD Master Password'\n    ELSE 'No BIOS Passwords Set'\n  END AS 'BIOS Password(s)'\nFROM vSMS_R_System AS SMS_R_System\nINNER JOIN COMPUTER_SYSTEM_PRODUCT_DATA AS __em_COMPUTER_SYSTEM_PRODUCT0\n  ON __em_COMPUTER_SYSTEM_PRODUCT0.MachineID = SMS_R_System.ItemKey\nINNER JOIN Computer_System_DATA AS SMS_G_System_COMPUTER_SYSTEM\n  ON SMS_G_System_COMPUTER_SYSTEM.MachineID = SMS_R_System.ItemKey\nINNER JOIN TPM_DATA AS SMS_G_System_TPM\n  ON SMS_G_System_TPM.MachineID = SMS_R_System.ItemKey\nINNER JOIN Firmware_DATA AS SMS_G_System_FIRMWARE\n  ON SMS_G_System_FIRMWARE.MachineID = SMS_R_System.ItemKey\nINNER JOIN LENOVO_BIOSPASSWORDSETTINGS_DATA AS __ENOVO_BIOSPASSWORDSETTINGS1\n  ON __ENOVO_BIOSPASSWORDSETTINGS1.MachineID = SMS_R_System.ItemKey\nINNER JOIN PC_BIOS_DATA AS SMS_G_System_PC_BIOS\n  ON SMS_G_System_PC_BIOS.MachineID = SMS_R_System.ItemKey\nINNER JOIN LENOVO_BIOSSETTING_DATA AS ___System_LENOVO_BIOSSETTING2\n  ON ___System_LENOVO_BIOSSETTING2.MachineID = SMS_R_System.ItemKey\nWHERE SMS_G_System_COMPUTER_SYSTEM.Manufacturer00 = N'LENOVO'\nAND __em_COMPUTER_SYSTEM_PRODUCT0.Version00 LIKE N'Think%'\n/*AND ___System_LENOVO_BIOSSETTING2.CurrentSetting00 LIKE N'Device Guard%'\nOR ___System_LENOVO_BIOSSETTING2.CurrentSetting00 LIKE N'DeviceGuard%'*/\n</code></pre> <p>The Device Guard BIOS setting is what's being reported only.  You will still need to perform OS side Device Guard configurations.  If a system does not have the Device Guard BIOS setting present, it will be filtered from the report.  You can comment out the last 2 lines of the query if you're certain the systems you're reporting on do have the Device Guard BIOS setting.</p>"},{"location":"reporting-bios-password-states-on--think-products-with-configmgr/#downloads","title":"Downloads","text":"<p>MOF File: https://download.lenovo.com/cdrt/blog/Lenovo-WMIClasses.zip</p> <p>Sample Report (CDRT logo has been removed): https://download.lenovo.com/cdrt/blog/Lenovo-TPM_BiosPassword_SecureBoot_Status-Report.zip</p>"},{"location":"converting-bios-to-uefi-on-think-products-with-configmgr/","title":"Converting BIOS to UEFI on Think Products with ConfigMgr","text":"<p>A new Task Sequence Variable, TSUEFIDrive, was introduced in Configuration Manager Current Branch version 1610. This variable will prepare the hard drive for transition to UEFI from legacy BIOS, in one task sequence. This is extremely helpful if you're migrating systems from Windows 7 to Windows 10 in a refresh scenario.</p> <p>A detailed walk-through by the Microsoft team on how to configure your Task Sequence for use with this variable can be found here. We want to focus on step 5 from this guide:</p> <p>Add a step to start the OEM tool that will convert the firmware from BIOS to UEFI. This will typically be a Run Command Line task sequence step with a command line to start the OEM tool.</p> <p>This blog post will demonstrate how to accomplish this scenario using the Think BIOS Config Tool.</p> <p>On your test ThinkPad or ThinkCentre, use the Think BIOS Config tool to configure the BIOS settings you want applied to the rest of your ThinkPads/ThinkCentres and export to an .ini.</p> <p>Here is a sample .ini exported from a ThinkPad T460</p> <pre><code>WakeOnLAN,ACOnly\nEthernetLANOptionROM,Enable\nIPv4NetworkStack,Enable\nIPv6NetworkStack,Enable\nUefiPxeBootPriority,IPv4First\nWiGigWake,Disable\nUSBBIOSSupport,Enable\nAlwaysOnUSB,Enable\nTrackPoint,Automatic\nTouchPad,Automatic\nFnCtrlKeySwap,Disable\nFnSticky,Disable\nFnKeyAsPrimary,Disable\nBootDisplayDevice,LCD\nSharedDisplayPriority,DockDisplay\nTotalGraphicsMemory,256MB\nBootTimeExtension,Disable\nSpeedStep,Enable\nAdaptiveThermalManagementAC,MaximizePerformance\nAdaptiveThermalManagementBattery,Balanced\nCPUPowerManagement,Automatic\nOnByAcAttach,Disable\nPasswordBeep,Disable\nKeyboardBeep,Enable\nAMTControl,Disable\nLockBIOSSetting,Disable\nMinimumPasswordLength,Disable\nBIOSPasswordAtUnattendedBoot,Enable\nBIOSPasswordAtReboot,Disable\nBIOSPasswordAtBootDeviceList,Disable\nPasswordCountExceededError,Enable\nFingerprintPredesktopAuthentication,Enable\nFingerprintReaderPriority,External\nFingerprintSecurityMode,Normal\nFingerprintPasswordAuthentication,Enable\nSecurityChip,Active\nTXTFeature,Disable\nPhysicalPresenceForTpmProvision,Disable\nPhysicalPresenceForTpmClear,Enable\nBIOSUpdateByEndUsers,Enable\nSecureRollBackPrevention,Disable\nDataExecutionPrevention,Enable\nVirtualizationTechnology,Enable\nVTdFeature,Enable\nEthernetLANAccess,Enable\nWirelessLANAccess,Enable\nWirelessWANAccess,Enable\nBluetoothAccess,Enable\nUSBPortAccess,Enable\nMemoryCardSlotAccess,Enable\nIntegratedCameraAccess,Enable\nMicrophoneAccess,Enable\nFingerprintReaderAccess,Enable\nNfcAccess,Enable\nWiGig,Enable\nBottomCoverTamperDetected,Disable\nInternalStorageTamper,Disable\nComputraceModuleActivation,Enable\nSecureBoot,Enable\nSGXControl,SoftwareControl\nBootMode,Quick\nStartupOptionKeys,Enable\nBootDeviceListF12Option,Enable\nBootOrder,USBCD:USBFDD:NVMe0:HDD0:USBHDD:PCILAN\nNetworkBoot,PCILAN\nBootOrderLock,Disable\n</code></pre> <p>If you have a mix of Think products, you can combine all settings in a single .ini. If the setting does not apply to the client, it will simply be skipped. I chose the Virtualization settings for this example because all ThinkPads ship with these disabled. If you want to leverage Device Guard at some point, which requires virtualization to be enabled as a prerequisite, you can achieve this in the same step.</p> <p>You can also reduce the .ini file down to just the lines containing the settings you care about. Here's an example of an .ini that contains settings that will be applied to both platforms:</p> <pre><code>VirtualizationTechnology,Enable\nIntel(R) Virtualization Technology,Enabled\nVTdFeature,Enable\nVT-d,Enabled\nSecureBoot,Enable\nSecure Boot,Enabled \n</code></pre> <p>Notice there are two of each setting being applied. This is because these values are worded differently between ThinkPad and ThinkCentre.</p> <p>Create a new Package in your ConfigMgr console that contains the HTA and the .ini and distribute to your distribution points. Now, back to step 5 above, add a Run Command Line step to call the HTA and apply the .ini as shown below. The command line will work if no Supervisor password is set on the client.</p> <p>HTA support will need to be added to the boot image</p> <p></p> <pre><code>cmd.exe /c ThinkBiosConfig.hta \"file=ThinkPadConfig.ini\"\n</code></pre> <p>If you have a Supervisor password set on your clients, you can generate an encryption key in the BIOS Config Tool that will be used to pass the Supervisor password to set the BIOS changes. For more info, refer to the documentation. In the below screenshot, the command line now includes the \"pass\" switch with the encryption key I generated from the tool</p> <p></p> <p>That's it! You'll notice the system restart twice for the changes to take effect but the task sequence will resume and boot into PE to finish out the deployment since the boot image was staged to the hard drive prior to restart.</p>"},{"location":"certificate-based-bios-authentication/","title":"Certificate-based BIOS Authentication","text":"<p>Beginning with 2022 ThinkPad models, it is now possible to configure systems to use a digital signing certificate instead of a supervisor password. Although this feature does not eliminate the challenge of initially securing the device, it does eliminate the need to exchange passwords in plain text when scripting BIOS settings changes.</p> <p>To leverage this capability, a new set of WMI methods were introduced as part of the Lenovo WMI BIOS Interface. The usage concept follows these steps:</p> <ol> <li>Create a code signing certificate with public key/private key files</li> <li>Provision devices with the certificate</li> <li>Generate a \"signed settings string\"</li> <li>Call the new method to set the setting on the target device</li> <li>Repeat steps 3 &amp; 4 as needed</li> </ol> <p>To make the process easier, we have created a LnvBiosCerts PowerShell module and the Lenovo BIOS Cert Tool (LnvBiosCertsInterface.ps1) which provides a GUI interface for working with these functions. The current version of this package can be downloaded from here (LnvBiosCertTool_1.0.2.zip).</p> <p>A reference guide to the PowerShell module is available at https://docs.lenovocdrt.com/guides/lbct/index</p>"},{"location":"certificate-based-bios-authentication/#getting-started","title":"Getting Started","text":"<p>The first step in trying this out will be to generate a compatible code signing certificate. In this article we will use OpenSSL to create the certificate. In this guide we will be using OpenSSL Light for this. This can be installed on an administrator\u2019s system using Winget:</p> <p></p> <p>Once it is installed, add the path to the CLI tool to the Path environment variable.</p> <pre><code>$env:Path += \";C:\\Program Files\\OpenSSL-Win64\\bin\"\n</code></pre> <p>Then run the following command to generate a private key as a .PEM file:</p> <pre><code>openssl genrsa -out privateKey.pem 2048\n</code></pre> <p></p> <p>This file should be kept secure with access only given to an administrator. Having access to this file would be analogous to knowing a Supervisor Password.</p> <p>Depending on your company's requirements you may need to use .DER file format instead.  These are also supported and can be generated from the .PEM file. This solution does not currently support encrypted keys.</p> <p>The optional command to convert the .PEM file to a .DER file:</p> <pre><code>openssl rsa -in privateKey.pem -inform PEM -out privateKey.der -outform DER\n</code></pre> <p>A public key can be generated from the private key with the following command:</p> <pre><code>openssl rsa -in privateKey.pem -pubout -out publicKey.pem\n</code></pre> <p>Convert to .DER (optional):</p> <pre><code>openssl rsa -pubin -in publicKey.pem -inform PEM -out publicKey.der -outform DER\n</code></pre> <p>Next we need to generate the X509 Certificate that will be provisioned to the managed devices.</p> <pre><code>openssl req -new -x509 -days 7300 -key privateKey.pem -out biosCert.pem -sha256 [-config openssl.cnf]\n</code></pre> <p>If you installed the Lite version of OpenSSL for Windows, the config file will not be there so you can ignore the -config openssl.cnf parameter.</p> <p></p>"},{"location":"certificate-based-bios-authentication/#deploy-the-lnvbioscerts-module","title":"Deploy the LnvBiosCerts Module","text":"<p>The zip file linked at the beginning of this article contains a subfolder named LnvBiosCerts which contains the PowerShell module. To install the module, you can simply copy that folder to one of the following locations:</p> <p><code>C:\\Program Files\\WindowsPowerShell\\Modules</code></p> <p>or</p> <p><code>C:\\Users\\&lt;username&gt;\\Documents\\WindowsPowerShell\\Modules</code></p> <p>The first location is preferable as it allows any user or admin process on the machine to access the module.  The second location only makes the module available for that particular user.</p> <p></p> <p>Open a new Administrator PowerShell terminal. This ensures the module just copied to this system will be loaded. If, however, the commands below are not recognized you may need to explicitly import the module with this command:</p> <pre><code>Import-Module 'LnvBiosCerts' -force\n</code></pre> <p>Run the following command in the folder where the biosCert.pem file is located to provision the certificate to the system:</p> <pre><code>Set-LnvBiosCertificate -Certfile .\\biosCert.pem -Password pass1word\n</code></pre> <p></p> <p>The -Password parameter passes the current Supervisor Password that exists on the device and this password will be removed and replaced with the certificate. The target device must either have a Supervisor Password already set or must be in the System Deployment Boot Mode with the command being run from a script under WinPE of a PXE boot image.</p> <p>Reboot the system so that the changes can be finalized.  You may notice a message during reboot that confirms the configuration has changed.</p>"},{"location":"certificate-based-bios-authentication/#generate-a-signed-command","title":"Generate a Signed Command","text":"<p>On the administrator device which has the private key, generate a signed command.  This can be done using the Lenovo BIOS Certificate Tool user interface by doing the following:</p> <ol> <li>Click Generate Signed Command in the left navigation menu</li> <li>Select the method \u2018SetBiosSetting\u2019</li> <li>Specify the path to the private key</li> <li>Either enter or select the setting name and value (use the Load WMI Settings button if the current system has the setting needed, otherwise you can type the setting name and value in manually)</li> <li>Click Generate Command</li> <li>Copy the text generated to a text file you can copy to or access from the test device</li> </ol> <p>The signed command can also be generated from the PowerShell terminal by running the following command in the folder where the private key exists:</p> <pre><code>Get-LnvSignedWmiCommand -Method SetBiosSetting -SettingName WakeOnLANDock -SettingValue Disable -KeyFile .\\privateKey.pem | Out-File .\\setting.txt\n</code></pre> <p>This will generate a text file for you containing the signed command.</p> <p>You can generate multiple signed commands to change multiple BIOS Settings. You must also create a signed command that uses the SaveBiosSettings method.  This must be the final command submitted after changing one or more settings to ensure the settings are saved prior to restarting the machine.</p>"},{"location":"certificate-based-bios-authentication/#apply-the-signed-command","title":"Apply the Signed Command","text":"<p>On the test machine where the certificate has been applied and the LnvBiosCerts module has been installed, run the following command to apply the signed command which can be copied from the text file created in the previous step:</p> <pre><code>Submit-LnvBiosChange -Command \u201c(text from text file)\u201d\n</code></pre> <p></p> <p>Repeat this step for all the signed commands and make sure the last one applied is the one that references the SaveBiosSettings method. Restart the system for the settings changes to take effect.</p>"},{"location":"certificate-based-bios-authentication/#going-further","title":"Going Further","text":"<p>The Lenovo BIOS Cert Tool provides an easy to use graphical interface to work with the certificate-based BIOS configuration methods. There are several additional functions provided by the Lenovo BIOS Cert Tool that are described below.</p>"},{"location":"certificate-based-bios-authentication/#working-with-think-bios-config-tool","title":"Working with Think BIOS Config Tool","text":"<p>The Think BIOS Config Tool is a separate tool that provides the ability to list all the available settings and values on a system. The settings can be configured as desired and an INI file can be generated with changed settings. The Lenovo BIOS Certificate Tool can convert one of these INI files into a text file containing the signed WMI commands to apply the settings.</p> <p></p> <p>The generated file can be used on the Apply Signed Commands page of the Lenovo BIOS Certificate Tool or can easily be incorporated into your own PowerShell script.</p> <p></p>"},{"location":"certificate-based-bios-authentication/#unlocking-system-secured-with-certificate","title":"Unlocking System Secured with Certificate","text":"<p>When a system is secured with a certificate, you cannot access BIOS Setup directly on the machine using a Supervisor Password. Therefore, there is a different process to unlock a machine to access BIOS Setup.</p> <ol> <li>Technician boots the system pressing F1 to enter BIOS Setup.</li> <li>Insert a USB key to save a BIOS Unlock File to</li> <li>Click \"Generate Unlock Code\"</li> <li>Send BIOS Unlock File to administrator</li> <li>Administrator uses Lenovo BIOS Cert Tool to generate Unlock Code by specifiying Private Key File and Unlock File.</li> <li>Administrator sends Unlock Code to Technician</li> <li>Technician enters Unlock Code and continues to BIOS Setup</li> </ol> <p></p>"},{"location":"certificate-based-bios-authentication/#final-notes","title":"Final Notes","text":""},{"location":"certificate-based-bios-authentication/#clearing-certificate","title":"Clearing certificate","text":"<p>If you are clearing the certificate from multiple machines, it makes more sense to change the certificate to a temporary password instead of just removing the certificate. Generating a ClearBiosCertificate command requires the machine serial number which means there is a unique command for each machine.</p> <p>ChangeBiosCertificateToPassword would be a general command for all machines with that certificate which will replace the certificate with a password you specify. This will leave the devices in a secure, managable state also.</p>"},{"location":"certificate-based-bios-authentication/#installing-module-to-auto-load","title":"Installing Module to auto load","text":"<p>By placing the LnvBiosCerts folder in the %Program Files%\\WindowsPowershell\\Modules folder, the module will auto load when a PowerShell window is started.</p>"},{"location":"certificate-based-bios-authentication/#limitations","title":"Limitations","text":"<p>The SetFunctionRequest method has a limitation regarding the ResetSystemToFactoryDefaults BIOS function. The method will not be able to call this function with a certificate installed on the machine.</p>"},{"location":"configuration-manager---driver-import-error-some-packages-cannot-be-updated/","title":"Configuration Manager - Driver Import Error: Some packages cannot be updated","text":"<p>Recently we have experienced an increase of reported issues when importing drivers into Configuration Manager.  After a successful import, the import wizard goes to copy the drivers to the package and distribute the package to the distribution point(s), yet an error is received.</p> <p></p> <p>While there is no issue with the import process, the process to update driver packages where the content is stored fails.</p>"},{"location":"configuration-manager---driver-import-error-some-packages-cannot-be-updated/#cause","title":"Cause","text":"<p>The cause of the issue is the source location containing the driver files is missing, yet the driver is still present in Configuration Manager database, expecting to be referenced by the new package.</p>"},{"location":"configuration-manager---driver-import-error-some-packages-cannot-be-updated/#remediation","title":"Remediation","text":"<p>Unfortunately, the error listed does not define the missing driver(s) responsible for the failure.  To locate these drivers, I have written a PowerShell script to test the presence of the folder location listed for each driver.  If the location is not present, I output the missing driver's CI_ID, Name, and Content Source Location.  Once the drivers with missing content source locations are identified, you can either replace the missing content or delete the drivers from the database.  </p> <p>Each of these options present their own unique issues:</p> <ul> <li>Replacing the content, will result in obtaining the original content, which may not be available any longer resulting in deleting the drivers.</li> <li>Deleting the drivers from the Configuration Manager console will ultimately remove these drivers from existing packages, causing Operating System Deployment Task Sequences to miss drivers in the Operating System.  When deleting, you may have to revalidate the drivers and deployment.</li> </ul>"},{"location":"configuration-manager---driver-import-error-some-packages-cannot-be-updated/#script","title":"Script","text":"<pre><code>#Get All Drivers in CM\n$CMDrvs = Get-CMDriver -Fast | ? {$_.ContentSourcePath -ne \"\"}\nForEach($CMDrv in $CMDrvs){\n    # Iterate through all the drivers testing the existence of the source path\n    If((Test-Path \"FileSystem::$($CMDrv.ContentSourcePath)\") -eq $False){\n\n     # Outputting relevant information to console\n        Write-Host \"CI_ID: $($CMDrv.CI_ID) - Driver: $($CMDrv.DriverProvider) $($CMDrv.LocalizedDisplayName) missing folder $($CMDrv.ContentSourcePath)\"\n    }\n}\n</code></pre>"},{"location":"using-winget-to-install-applications-as-part-of-a-configuration-manager-configuration-baseline/","title":"Using Winget to Install Applications as Part of a Configuration Manager Configuration Baseline","text":""},{"location":"using-winget-to-install-applications-as-part-of-a-configuration-manager-configuration-baseline/#brief-background","title":"Brief Background","text":"<p>The future of package management for Windows is Windows Package Manager. This simplifies the installation and management of applications using the winget tool.</p> <p>There is a community repository that contains all of the package manifest files for Windows. Browsing through the repository, I noticed Lenovo System Update (and its many previous versions) had already been submitted by other contributors. I thought to myself, \"We should add our other enterprise tools to the list.\" We now have available in the repository:</p> <ul> <li>Dock Manager</li> <li>Update Retriever</li> <li>Thin Installer</li> <li>System Update</li> </ul> <p>Early on during my testing with winget, the ultimate goal was to be able to install applications in System context. The struggle was that winget isn't recognized if you try to call it in System context. There was, however, an alternate solution by using AppInstallerCli.exe. I wrote a short script on how to leverage this to upgrade packages with a Scheduled Task.</p> <p>After revisiting winget, I noticed AppInstallerCli.exe wasn't present anymore. On my test machine, the Desktop App Installer package had updated to version 1.17.10271 from version 1.16.12653. Instead, I did see winget.exe in the root of the Microsoft.DesktopAppInstaller directory. In previous versions, this was located under %LocalAppData%\\Microsoft\\WindowsApps, where it still is but it appears Microsoft has listened to the community on wanting support for this in System context.</p> <p>Winget releases can be found at https://github.com/microsoft/winget-cli/releases</p> <p>Which now leads us to the purpose of this article. How can I remediate a device missing a critical application using a Configuration Baseline? What makes this even more attractive, is that I don't have to create an Application and retain the source files.</p> <p>I'll use Thin Installer for this demonstration.</p>"},{"location":"using-winget-to-install-applications-as-part-of-a-configuration-manager-configuration-baseline/#create-the-configuration-item","title":"Create the Configuration Item","text":"<p>Start off by navigating to the Assets and Compliance workspace in the console, expand Compliance Settings, and select Configuration Items. Click Create Configuration Item from the ribbon bar and enter a name for the CI.</p> <p></p> <p>I specified Windows 10 and Windows 11 for Supported Platforms</p> <p></p> <p>Add a new setting, choose Script for the setting type and Boolean for data type.</p> <p></p> <p>Click Edit Script... in the Discovery script section. Choose Windows PowerShell as the script language and copy/paste the code below</p> <pre><code>$ThinInstaller = Join-Path -Path (Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath Lenovo) -ChildPath \"ThinInstaller\"\nif (Test-Path -Path $ThinInstaller)\n{ return $true }\nelse { return $false }\n</code></pre> <p>Copy/paste the below code to be used for the Remediation script.</p> <pre><code>$Winget = Get-ChildItem -Path (Join-Path -Path (Join-Path -Path $env:ProgramFiles -ChildPath \"WindowsApps\") -ChildPath \"Microsoft.DesktopAppInstaller*_x64*\\winget.exe\")\n$Id = \"Lenovo.ThinInstaller\"\n\ntry {\n    Invoke-Expression -Command \"cmd.exe /c '$Winget' install --id $Id --scope machine --silent --accept-source-agreements --accept-package-agreements --log C:\\Winget-ThinInstaller.log\"\n}\ncatch {\n    Throw \"Failed to install Thin Installer\"\n}\n</code></pre> <p>Configure the compliance condition rule as:</p> <ul> <li>Rule type - Value</li> <li>The value returned by the specified script - Equals True</li> <li>Tick the box to Run the specified remediation script when this setting is noncompliant</li> </ul> <p></p> <p>Complete the wizard to create the new Configuration Item.</p> <p>Navigate to the Configuration Baselines node. Click Create Configuration Baseline in the ribbon bar. Specify a name, add the CI that was just created, and lick Ok.</p> <p></p> <p>Deploy the baseline to a Collection. Tick the box to Remediate noncompliant rules when supported.</p> <p></p> <p>Hop over to a test machine and open the Configuration Manager Client Applet to force a machine policy retrieval. Once the new baseline appears under the Configurations tab, click Evaluate and wait for the magic to happen. When the baseline completes, scroll over to the Compliance column to confirm the status shows Compliant.</p> <p>The remediation script also outputs the winget log to C:\\Winget-ThinInstaller.log. Open it up and near the bottom you should see Installation process succeeded</p> <p></p> <p>This is a simple example of what can be possible with winget moving forward. At the time of testing, I also attempted to deploy this same remediation script through Intune as a Win32 app but it fails. I have no idea why since the process is essentially the same. This article will be updated once that's solved.</p>"},{"location":"deploying-certificate-based-bios-authentication-with-microsoft-configuration-manager/","title":"Deploying Certificate-based BIOS Authentication with Microsoft Configuration Manager","text":"<p>This guide will demonstrate how to convert the BIOS security of a Lenovo Think product, protected by a Supervisor Password, to a digital certificate-based authentication mechanism using a Configuration Manager task sequence.</p>"},{"location":"deploying-certificate-based-bios-authentication-with-microsoft-configuration-manager/#overview","title":"Overview","text":"<p>For those wanting to harden BIOS access even further by switching to certificate-based authentication, let's explore how to accomplish this with the power of a task sequence.</p>"},{"location":"deploying-certificate-based-bios-authentication-with-microsoft-configuration-manager/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, this solution assumes the following:</p> <ul> <li>Your devices are currently secured with a Supervisor Password</li> <li>Code signing certificate file (.pem) with public/private keys has been generated</li> </ul> <p>Info</p> <p>Follow this blog article for a more in-depth guide on how to generate a code signing certificate.</p>"},{"location":"deploying-certificate-based-bios-authentication-with-microsoft-configuration-manager/#create-the-packages","title":"Create the Packages","text":"<p>In my lab, I've created 2 legacy Packages. One for my .pem certificate file that will be installed on my test device and another containing the LnvBiosCerts PowerShell module that will be copied to the PowerShell modules folder.</p> <p>In the console, navigate to Software Library &gt; Application Management &gt; Packages and create 2 new Packages:</p> <ul> <li> <p>Lenovo BIOS Certificate - Package source path contains your .pem certificate file</p> </li> <li> <p>PSModule - LnvBiosCerts - Package source path contains the extracted contents of the LnvBiosCerts module</p> </li> <li>Example source path directory structure should look like:<ul> <li>\\\\share\\ConfigMgr\\Content\\Software\\Lenovo\\Modules\\LnvBiosCertTool_1.0.2<ul> <li>LnvBiosCerts<ul> <li>1.0.2<ul> <li>LnvBiosCerts.psd1</li> <li>LnvBiosCerts.psm1</li> </ul> </li> </ul> </li> <li>LnvBiosCertInterface.ps1 (optional)</li> </ul> </li> </ul> </li> </ul> <p>Distribute packages to your distribution points</p>"},{"location":"deploying-certificate-based-bios-authentication-with-microsoft-configuration-manager/#create-the-task-sequence","title":"Create the Task Sequence","text":"<p>This example is short and not overly complex, however, a few of the steps consist of critical WQL queries that checks for the appropriate BIOS Password State value required to convert to certificate-based auth.</p> <p>The layout is below. Let's walk through the steps</p> <p></p> <ul> <li>Set Task Sequence Variable<ul> <li>Name: isThink</li> <li>Value: true</li> <li>Condition: WMI Query<ul> <li>WMI Namespace: root\\cimv2</li> </ul> </li> </ul> </li> </ul> <pre><code> SELECT * FROM Win32_ComputerSystemProduct\n WHERE Version LIKE 'ThinkPad%'\n   OR Version LIKE 'ThinkCentre%'\n   OR Version LIKE 'ThinkStation%'\n</code></pre> <p>This step will only set the variable if the device is a ThinkPad, ThinkCentre, or ThinkStation</p> <p></p> <p></p> <ul> <li>Set Task Sequence Variable<ul> <li>Name: isSvpSet</li> <li>Value: true</li> <li>Condition: WMI Query<ul> <li>WMI Namespace: root\\WMI</li> </ul> </li> </ul> </li> </ul> <pre><code>SELECT PasswordState FROM Lenovo_BiosPasswordSettings WHERE\n(PasswordState = 2) OR\n(PasswordState = 3) OR\n(PasswordState = 6) OR\n(PasswordState = 7) OR\n(PasswordState = 66)\n</code></pre> <p>This step will only set the variable if the value of the BIOS Password State matches. Reference this table for what each value translates to.</p> <p></p> <ul> <li>Copy LnvBiosCerts Module Group<ul> <li>Condition: Task Sequence Variable isThink equals \"true\"</li> </ul> </li> </ul> <p></p> <ul> <li>Run Command Line - This command uses xcopy to copy the LnvBiosCerts module to the WindowsPowerShell\\Modules directory<ul> <li>Name: Copy to PS5 Modules</li> <li>Disable 64-bit file system redirection</li> <li>Tick Package and choose the LnvBiosCerts Package created earlier</li> </ul> </li> </ul> <pre><code>xcopy \".\\*.*\" \"%ProgramFiles%\\WindowsPowerShell\\Modules\" /e /i /y\n</code></pre> <p></p> <ul> <li>Convert to Cert Auth Group<ul> <li>Condition: Task Sequence Variable isSvpSet equals \"true\"</li> </ul> </li> </ul> <p></p> <ul> <li>Run Command Line<ul> <li>Name: Import LnvBiosCerts Module</li> </ul> </li> </ul> <pre><code>powershell.exe -ExecutionPolicy Bypass -Command \"Import-Module LnvBiosCerts -Force\"\n</code></pre> <ul> <li> <p>Set Task Sequence Variable</p> <ul> <li>Name: OSDDoNotLogCommand</li> <li>Value: true</li> </ul> </li> <li> <p>Set Task Sequence Variable</p> <ul> <li>Name: Set Supervisor Password Variable</li> <li>Name: SVP</li> <li>Tick Do not display this value</li> <li>Value: Enter the BIOS supervisor password</li> </ul> </li> </ul> <p></p> <ul> <li>Run Command Line - This command invokes Set-LnvBiosCertificate to provision the certificate to the device. The -Password parameter value uses the %SVP% task sequence variable set in the Set Supervisor Password Variable step.<ul> <li>Tick Package and choose the Lenovo BIOS Certificate Package created earlier</li> </ul> </li> </ul> <pre><code>powershell.exe -ExecutionPolicy Bypass -Command \"Set-LnvBiosCertificate -Certfile .\\biosCert.pem -Password %SVP%\"\n</code></pre> <p></p> <p>The last step is to restart the computer</p>"},{"location":"deploying-certificate-based-bios-authentication-with-microsoft-configuration-manager/#monitoring-the-results","title":"Monitoring the Results","text":"<p>Tracing the smsts.log, we see the Supervisor Password has been masked due to setting the OSDDoNotLogCommand variable to true.</p> <p></p> <p>The output of provisioning the certificate to the device shows success.</p> <p></p>"},{"location":"deploying-certificate-based-bios-authentication-with-microsoft-configuration-manager/#user-experience","title":"User Experience","text":"<p>User is presented with a reboot message stating the system has converted to certificate-based authentication for BIOS access.</p> <p></p> <p>Once the device restarts, you will see the configuration has changed and a 2nd reboot takes place.</p> <p></p> <p>Accessing BIOS now requires an unlock code.</p> <p></p>"},{"location":"automatically-create-configmgr-device-collections-for-lenovo-products/","title":"Automatically Create ConfigMgr Device Collections for Lenovo Products","text":"<p>This is a PowerShell based solution that will query the ConfigMgr database for Lenovo branded products and create a Device Collection based off the friendly name, i.e. ThinkPad T14 Gen 2.  Each device will then be moved to its respective collection.</p>"},{"location":"automatically-create-configmgr-device-collections-for-lenovo-products/#prerequisites","title":"PREREQUISITES","text":"<p>In order for the friendly name to be queried, the Win32_ComputerSystemProduct WMI class will need to be added/enabled to the ConfigMgr hardware inventory.  This needs to be performed in the Default Client Settings in the Client Settings node under the Administration workspace.  For a step by step, refer to the this MS doc.</p>"},{"location":"automatically-create-configmgr-device-collections-for-lenovo-products/#solution","title":"SOLUTION","text":"<p>Script can be downloaded from my GitHub.</p> <p>Run in an elevated PowerShell on a system that has the ConfigMgr console installed.  This also assumes you have the necessary permissions to create Device Collections in your environment.</p> Create-LenovoDeviceCollections.ps1<pre><code>&lt;#\n.SYNOPSIS\n    Creates ConfigMgr Device Collections for Lenovo systems\n.DESCRIPTION\n    Script that checks the ConfigMgr database for Lenovo branded systems and creates a Device Collection based off the friendly name.\n\n    Example: ThinkPad T14 Gen 2\n.PARAMETER SiteServer\n    Fully qualified domain name of Site Server\n.EXAMPLE\n    .\\Create-LenovoDeviceCollections.ps1 -SiteServer cm01.domain.com\n.NOTES\n    Author: Philip Jorgensen\n    Created: 12/16/2021\n\n    Run script from Site Server or system with the ConfigMgr console installed.\n#&gt;\n\n[CmdletBinding()]\nparam (\n    [Parameter(Mandatory = $true,\n        HelpMessage = \"FQDN of Site Server\",\n        ValueFromPipeline = $false)\n    ]\n    [ValidateNotNullOrEmpty()]\n    [OutputType([String])]$SiteServer\n)\n\n$ErrorActionPreference = \"SilentlyContinue\"\n\n#Import ConfigMgr PS Module\nif (!(Get-Module -Name ConfigurationManager)) {\n    Import-Module $env:SMS_ADMIN_UI_PATH.Replace(\"bin\\i386\", \"bin\\ConfigurationManager.psd1\")\n}\n\n#Connect to ConfigMgr Site \nWrite-Host \"Connecting to $SiteServer...\" -ForegroundColor Yellow\n$SiteCode = $(Get-CimInstance -ComputerName $SiteServer -Namespace \"root\\SMS\" -Class \"SMS_ProviderLocation\").Sitecode\n\nif (!(Get-PSDrive -Name $Sitecode)) {\n    New-PSDrive -Name $Sitecode -PSProvider CMSite -Root $SiteServer -Description \"Primary Site Server\"\n}\n\nSet-Location -Path $Sitecode\":\\DeviceCollection\"\n\n&lt;# \n    Queries system by Lenovo version.\n    NOTE: The Computer System Product (Win32_ComputerSystemProduct) hardware inventory class with Vendor property must be enabled.\n#&gt;\n\n$Subfolder = \"Lenovo\"  \n$Models = Get-CimInstance -ComputerName $SiteServer -Namespace \"root\\SMS\\site_$($Sitecode)\" -Query \"Select * From SMS_G_System_COMPUTER_SYSTEM_PRODUCT Where Vendor = 'LENOVO'\" | Select-Object -Property Vendor, Version | Sort-Object -Unique -Property Vendor, Version\n\nif ($Models.Count -ne '0') {\n    if (!(Test-Path -Path $Subfolder)) {\n        New-Item -Name $Subfolder\n    }\n\n    $i = 1\n    foreach ($Model in $Models) {\n        $sModel = $Model.Version\n        $iModel = $Models.Count\n        Write-Progress \"Adding Lenovo devices to named device collections.\" -Status \"Updating the $sModel collection. $i of $iModel\" `\n            -PercentComplete ($i++ / $Models.count * 100)\n\n        &lt;# \n            Creates collection based on version of Lenovo system and sets schedule to update collection weekly.\n            Adjust schedule as desired.\n        #&gt;\n        #Adjust limiting collection as desired.\n        $Schedule = New-CMSchedule -DayOfWeek Monday -Start \"2/17/2016 03:00:00 AM\"\n        $ModelVersion = $Model.Version\n\n        if (!(Get-CMDeviceCollection -Name $ModelVersion)) {\n            $NewCollection = New-CMDeviceCollection -Name \"$ModelVersion\" -LimitingCollectionName 'All Systems' -RefreshType Periodic -RefreshSchedule $Schedule\n            $LenovoCollection = Get-CMDeviceCollection -Name \"$ModelVersion\"\n            Move-CMObject -InputObject $LenovoCollection -FolderPath \"$Subfolder\"\n        }\n        $CollectionQuery = \"Select *  From  SMS_R_System inner join SMS_G_System_COMPUTER_SYSTEM_PRODUCT on SMS_G_System_COMPUTER_SYSTEM_PRODUCT.ResourceId = SMS_R_System.ResourceId where SMS_G_System_COMPUTER_SYSTEM_PRODUCT.Version = \"\"$ModelVersion\"\"\"\n        if (!(Get-CMDeviceCollectionQueryMembershipRule -CollectionName $ModelVersion -RuleName $ModelVersion)) {\n            Add-CMDeviceCollectionQueryMembershipRule -CollectionName \"$ModelVersion\" -QueryExpression $CollectionQuery -RuleName $ModelVersion\n        }\n    }\n\n    # Disconnect from Site\n    Write-Host \"Device Collections updated.\" -ForegroundColor Yellow\n    Write-Host \"Disconnecting from Site...\" -ForegroundColor Yellow\n    Set-Location -Path $env:SMS_ADMIN_UI_PATH\n    Remove-PSDrive -Name $Sitecode\n    Set-Location -Path $env:HOMEPATH    \n}\n\nElse {\n    Write-Host \"No Lenovo Models detected in the CM database...\"\n}\n</code></pre>"},{"location":"automatically-create-configmgr-device-collections-for-lenovo-products/#result","title":"RESULT","text":"<p>This was tested in a lab with very few devices so this may or may not take some time to finish depending on the amount of endpoints in your environment.  In the end, you should see a Lenovo subfolder containing all of your Lenovo Device Collections.  Hopefully this helps with organization!</p> <p></p>"},{"location":"installing-updates-from-the-lenovo-3rd-party-catalog-in-a-configmgr-operating-system-deployment/","title":"Installing Updates from the Lenovo 3rd Party Catalog in a ConfigMgr Operating System Deployment","text":"<p>In some scenarios, there may be the desire to leverage the Lenovo Updates Catalog to apply applicable updates during an OS deployment task sequence. This article will cover how this might be achieved.</p>"},{"location":"installing-updates-from-the-lenovo-3rd-party-catalog-in-a-configmgr-operating-system-deployment/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Enable third-party updates on your Software Update Point - https://docs.microsoft.com/mem/configmgr/sum/deploy-use/third-party-software-updates</p> </li> <li> <p>Subscribe to the Lenovo Third-Party Update Catalog in ConfigMgr - https://docs.microsoft.com/en-us/mem/configmgr/sum/deploy-use/third-party-software-updates#subscribe-to-a-third-party-catalog-and-sync-updates</p> </li> </ul> <p>After subscribing and synchronizing the Lenovo Updates Catalog, open the Software Update Point Component Properties and check the box next to the Lenovo product tree to sync Lenovo Updates and the LUCAgent.</p> <p></p> <p>Initiate a site-wide synchronization of software updates to sync the metadata for all updates in the Lenovo catalog. Once the sync has completed, go to the Software Library workspace, expand Software Updates, and select the All Software Updates node. All Lenovo updates should be populated here.</p> <p>In this example, I'm going to publish the Lenovo Updates Catalog Agent. This is a light weight tool that performs data conversions in WMI to assist with the evaluation of the installation and applicability rules for each update in the Lenovo Updates Catalog. The installation and applicability rules determine if an update is currently installed or if an update is applicable to the device. This is required on all Lenovo products if you plan on publishing and deploying other updates.</p> <p>In the All Software Updates node, filter the updates by adding the following criteria:</p> <ul> <li>Title contains Lenovo Updates Catalog Agent</li> <li>Expired set to No</li> <li>Superseded set to No</li> <li>Vender equals Lenovo</li> </ul> <p>Optionally, save this search by clicking Save Current Search in the ribbon bar</p> <p></p> <p>Select the Lenovo Updates Catalog Agent update and select Publish Third-Party Software Update Content to download the update binaries, which is stored in the WSUSContent directory. Initiate a site-wide synchronization of software updates. Once complete, the icon beside the update should flip from blue (metadata-only) to green (deployable).</p> <p>I will create an Automatic Deployment Rule to add the LUCAgent (and any future versions) to a Software Update Group, which can then be deployed to a Device Collection.</p> <p>In the Software Library workspace, expand Sofware Updates and select Automatic Deployment Rules.</p> <ul> <li>Select Create Automatic Deployment Rule from the ribbon bar.</li> <li>Enter Lenovo Updates Catalog Agent for the name of the rule.</li> <li>Specify the All Unknown Computers collection.</li> <li>Select the radio button **Add to an existing Software Update Group.</li> <li>Tick the box to Enable the deployment after this rule is run.</li> </ul> <p>On the Deployment Settings page, set the type of deployment to Required. Set the following property filters and search criteria as follows:</p> <ul> <li>Superseded No</li> <li>Title Lenovo Updates Catalog Agent</li> <li>Vendor Lenovo</li> </ul> <p>Click Preview and 1 updates should return</p> <p></p> <p>Specify the recurring schedule for the rule. I chose to run the rule after any software update point synchronization.</p> <p>Further in the wizard, select the option to Create a new deployment package. This will contain the update(s) associated with the ADR.</p> <ul> <li>Enter the name Lenovo Updates Catalog Agent</li> <li>Specify the source path to where the deployment package will reside.</li> <li>Add the Distribution Points or distribution point groups to host the content.</li> <li>Specify the download location for the ADR. My site server has an Internet connection so I'll choose to Download software updates from the Internet.</li> </ul> <p>Proceed through the wizard to complete the creation of the ADR, which will then run.</p> <p>Select the Software Update Groups node to verify the Lenovo Updates Catalog Agent SUG has been created and populated with the update.</p> <p></p>"},{"location":"installing-updates-from-the-lenovo-3rd-party-catalog-in-a-configmgr-operating-system-deployment/#wsus-certificate-and-installation-script","title":"WSUS Certificate and Installation Script","text":"<p>To successfully install the LUCAgent (or any Third-Party update) in an operating system deployment, the third-party Wsus signing certificate needs to be installed in the Trusted Root and Trusted Publishers certificate stores. The Windows Update agent policy to Allow signed updates for an intranet Microsoft update service location will also need to be set. This is handled through Client Settings under the Software Updates tab.</p> <p>However, in an operating system deployment, the device can't receive this client policy so these tasks have to be handled beforehand.</p> <p>The below PowerShell commands will be used to accomplish this</p> <p>Update the script to match the name of the Wsus signing certificate when you exported it.</p> <pre><code># Set registry entry\nNew-ItemProperty -Path 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate' -Name AcceptTrustedPublisherCerts -PropertyType DWord -Value 1\nWrite-Output \"Registry Entry set\"\n\n# Import certificates into Root and Trusted Publisher store\ncertutil.exe -addstore -f \"TrustedPublisher\" .\\Import-WsusSigningCertificate.ps1\ncertutil.exe -addstore -f \"Root\" .\\Import-WsusSigningCertificate.ps1\nWrite-Output \"Wsus Signing Certificate imported\"\n</code></pre> <p>Save this script as Import-WsusSigningCertificate.ps1 to a source location. Export the Wsus signing certificate from a workstation or your site server and save it to the same location.</p> <p>In my lab, I saved both items to \\share\\ConfigMgr\\Content\\OSD\\Certificates</p> <p></p>"},{"location":"installing-updates-from-the-lenovo-3rd-party-catalog-in-a-configmgr-operating-system-deployment/#operating-system-deployment-task-sequence","title":"Operating System Deployment Task Sequence","text":"<p>In the Configuration Manager console, select the Software Library workspace, expand Application Management, and select the Packages node.</p> <ul> <li>Select Create Package</li> <li>Enter a name for the package.</li> <li>Tick the box beside This package contains source files</li> <li>Set the source folder to the location where Import-WsusSigningCertificate.ps1 and the Wsus signing certificate reside.</li> <li>Do not create a program for the package.</li> <li>Distribute the package to your Distribution Points and/or Distribution Point Groups.</li> </ul> <p>Create a new or Task Sequence or edit an existing one. After the Setup Windows and Configuration Step, add a Run PowerShell Script step.</p> <ul> <li>Name the step Import Certificate</li> <li>Select the package that you just created and enter the script name Import-WsusSigningCertificate.ps1</li> <li>Set the PowerShell execution policy to Bypass</li> </ul> <p></p> <p>Add an Install Software Updates step</p> <ul> <li>Select Required for installation - Mandatory software updates only</li> </ul> <p>Deploy this Task Sequence to an Unknown Lenovo device. Monitoring the smsts.log, I see the Windows Update agent policy to accept trusted publishers has been set and the certificate has been added to the certificate stores.</p> <p></p> <p>A bit further down, The installation of the LUC Agent has completed successfully.</p> <p></p> <p>If these steps weren't added, you would see a 0x800b0109 error in the log, which translates to \"A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider.\"</p>"},{"location":"deploying-commercial-vantage-with-configmgr/","title":"Deploying Commercial Vantage with ConfigMgr","text":"<p>Previously, Lenovo provided two separate apps (Lenovo Settings and Lenovo Companion) that allowed the user to change hardware settings, run diagnostic scans, and check for software and driver updates.  As of December 2017, all of the features in those two apps (discontinued) were merged into a single app Commercial Vantage</p> <p>This post will walk through deploying Commercial Vantage as a ConfigMgr application.</p> <p>All required components, as well as the Group Policy Admin Template, and sample registry files are included in the zip available for download on the Vantage landing page.</p> <p>Info</p> <p>In previous versions of Commercial Vantage, the installation was orchestrated using a batch file. Starting in version 20.2506.39.0, installation of the Commercial Vantage suite and add-ins are controlled by VantageInstaller.exe</p>"},{"location":"deploying-commercial-vantage-with-configmgr/#create-the-app","title":"Create the App","text":"<p>Download/extract the contents from the zip to a source location.</p> <p>In the console, navigate to Software Library &gt; Application Management &gt; Applications. Click Create Application and set the following:</p> <ul> <li> <p>General: Manually specify the application information</p> <ul> <li>General Information: Enter Commercial Vantage for the name and any other information you want to fill out.</li> </ul> </li> <li> <p>Software Center: Fill out what should be displayed to the end user when they view this app in Software Center.</p> <ul> <li> <p>Deployment Types: Add a Script Installer deployment type</p> </li> <li> <p>General Information: Enter a name for the deployment type.</p> </li> <li> <p>Content: Point the content location to the directory where the Vantage source files reside.</p> <ul> <li> <p>Installation Program: VantageInstaller.exe Install -Vantage -SuHelper</p> </li> <li> <p>Uninstall Program: VantageInstaller.exe Uninstall -Vantage</p> </li> </ul> </li> </ul> </li> </ul> <p>Note</p> <p>Depending on your requirements, there can be two detection methods that can be used. If the Store is blocked in your environment and/or Store apps are not automatically updated, detection method 1 should be used. Otherwise, detection method 2 can be used as future versions will be auto updated.</p> <ul> <li> <p>Detection Method 1: Select Configure rules to detect the presence of this deployment type. Click Add Clause...</p> <ul> <li> <p>Setting Type: File System</p> </li> <li> <p>Type: Folder</p> </li> <li> <p>Path: ProgramFiles\\Lenovo</p> </li> <li> <p>File or folder name: VantageService</p> </li> <li> <p>Tick the box This file or folder is associated with a 32-bit application on 64-bit systems.</p> </li> <li> <p>Ensure the radio button The file system setting must exist on the target system to indicate presence of this application is selected.</p> </li> <li> <p>Add a second File System clause to check the presence of the .appx package</p> </li> <li> <p>Type: Folder</p> </li> <li> <p>Path: ProgramFiles\\WindowsApps</p> </li> <li> <p>File or folder name: E046963F.LenovoSettingsforEnterprise_20.2506.39.0_x64__k1h2ywk1493x8</p> </li> <li> <p>Tick the box This file or folder is associated with a 32-bit application on 64-bit systems.</p> </li> </ul> </li> </ul> <ul> <li>Detection Method 2: Select Use a custom script to detect the presence of this deployment type.<ul> <li>Select PowerShell as the script type. Enter the following code into the script contents field:</li> </ul> </li> </ul> <p>The script can also be downloaded from my GitHub</p> Detect-CommercialVantage.ps1<pre><code># Version of Lenovo Vantage that is being deployed\n$DeployedVantageVersion = [version]\"20.2506.39.0\"\n\ntry\n{\n    # Get the path to the most recent VantageService folder under ProgramFiles(x86)\n    $vantageServicePath = Get-ChildItem -Path \"${env:ProgramFiles(x86)}\\Lenovo\\VantageService\" -Directory | Select-Object -Last 1\n\n    # Check if the path exists before proceeding\n    if ($vantageServicePath)\n    {\n        # Find LenovoVantageService.exe in the directory\n        $vantageServiceFile = Get-ChildItem -Path $vantageServicePath.FullName -Filter \"LenovoVantageService.exe\" -File -Recurse -ErrorAction Stop | Select-Object -Last 1\n\n        if ($vantageServiceFile)\n        {\n            # Extract the version information\n            $serviceVersion = [version]$vantageServiceFile.VersionInfo.FileVersion\n        }\n        else\n        {\n            $serviceVersion = $null\n            Write-Warning \"LenovoVantageService.exe was not found.\"\n        }\n    }\n    else\n    {\n        $serviceVersion = $null\n        Write-Warning \"VantageService directory was not found.\"\n    }\n\n\n    $minServiceVersion = [version]\"3.8.23.0\"\n    if ($serviceVersion -le $minServiceVersion)\n    {\n        Write-Output \"Lenovo Vantage Service is outdated (found version $serviceVersion, required minimum $minServiceVersion).\"\n        exit 1\n    }\n}\ncatch\n{\n    Write-Output \"Failed to retrieve Lenovo Vantage Service version. Error: $($_.Exception.Message)\"\n    exit 1\n}\n\n# Check for the Lenovo Commercial Vantage APPX package\ntry\n{\n    $vantagePackage = Get-AppxPackage -Name E046963F.LenovoSettingsforEnterprise -AllUsers -ErrorAction Stop\n    $installedVersion = [version]$vantagePackage.Version\n\n    if ($installedVersion -ge $DeployedVantageVersion)\n    {\n        Write-Output \"Lenovo Commercial Vantage APPX package is up-to-date (installed version: $installedVersion, required version: $DeployedVantageVersion).\"\n        exit 0\n    }\n    else\n    {\n        Write-Output \"Lenovo Commercial Vantage APPX package is outdated (installed version: $installedVersion, required version: $DeployedVantageVersion).\"\n        exit 1\n    }\n}\ncatch\n{\n    Write-Output \"Failed to detect Lenovo Commercial Vantage APPX package. Error: $($_.Exception.Message)\"\n    exit 1\n}\n</code></pre> <ul> <li> <p>User Experience:</p> <ul> <li> <p>Installation Behavior: Install for system</p> </li> <li> <p>Logon requirement: Whether or not a user is logged on</p> </li> <li> <p>Installation program visibility: Hidden</p> </li> </ul> </li> </ul>"},{"location":"deploying-commercial-vantage-with-configmgr/#distribute-content","title":"Distribute Content","text":"<p>Select the Commercial Vantage application and click Distribute Content from the ribbon bar. Both apps should be shown in the Content to distribute list. Click next and add the Distribution Points or Distribution Point Group to send the content to.</p>"},{"location":"deploying-commercial-vantage-with-configmgr/#deploy-the-app","title":"Deploy the App","text":"<p>Create a Device Collection to deploy the Commercial Vantage app. If you have a mixed environment of computer vendors, it's suggested to create a collection targeting only Lenovo Think branded products.</p>"},{"location":"deploying-commercial-vantage-with-intune/","title":"Deploying Commercial Vantage with Intune","text":"<p>For those who are migrating from Configuration Manager to Intune, you may find the need to deploy Commercial Vantage to your devices from Intune. Commercial Vantage consists of a UWP app plus other services and components. An enterprise package with deployment guide and ADMX templates is available to assist deploying this solution. Download the latest version of Commercial Vantage with Deployment Guide here.</p>"},{"location":"deploying-commercial-vantage-with-intune/#preparing-the-win32-app","title":"Preparing the Win32 App","text":"<p>Once the zip has been downloaded and extracted, use the Content Prep Tool to convert to an .intunewin format. In previous versions, there was a batch file that handled the installation of all dependencies, certs, and .msix bundle. Starting in version 20.2506.39.0, installation of the Commercial Vantage suite is now controlled by the VantageInstaller.exe.</p> <p>A sample command would be:</p> <pre><code>IntuneWinAppUtil.exe -c \"C:\\Sources\\IntuneWin\\LenovoCommercialVantage_20.2506.39.0_v17\" -s \"VantageInstaller.exe\" -o \"C:\\Sources\\IntuneWin\\output\" -q\n</code></pre> <p></p>"},{"location":"deploying-commercial-vantage-with-intune/#creating-the-win32-app","title":"Creating the Win32 App","text":"<p>Login to the MEM admin center and add a new Windows app (Win32). Select the new App package file created above, which should be named VantageInstaller.intunewin and click OK.</p> <p>Fill out the necessary fields in the App information section and click Review + save</p> <p></p> <p>In the Edit application section, this is where the install/uninstall commands will be specified.</p> <ul> <li>Install command</li> </ul> <p>Note</p> <p>The -SuHelper parameter will also install SUHelper</p> <pre><code>VantageInstaller.exe Install -Vantage -SuHelper\n</code></pre> <ul> <li>Uninstall command</li> </ul> <p>Note</p> <ul> <li>Specifying -Vantage will uninstall the Commercial Vantage suite (CV, Vantage Service, Add-ins)</li> <li>Specifying -App will only uninstall CV</li> </ul> <pre><code>VantageInstaller.exe Uninstall -Vantage\n</code></pre> <p>Set Device restart behavior to Determine behavior based on return codes.</p> <p></p> <p>In the Requirements section, tick the Operating system architecture to x64 and set the Minimum operating system to 1809</p> <p>Add an additional Registry type requirement rule that will only apply to Lenovo branded systems.</p> <p></p> <ul> <li>Key path</li> </ul> <pre><code>HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS\n</code></pre> <ul> <li>Value name</li> </ul> <pre><code>SystemManufacturer\n</code></pre> <ul> <li> <p>Registry key requirement: String comparison</p> </li> <li> <p>Operator: Equals</p> </li> <li> <p>Value</p> </li> </ul> <pre><code>LENOVO\n</code></pre> <p></p> <p>For the detection rule, a custom script detection will be used. Commercial Vantage depends on these 2 services to run</p> <ul> <li>ImControllerService (Not required for ARM-based devices)</li> <li>LenovoVantageService</li> </ul> <p>This sample PowerShell script can be used for detection</p> <p>Info</p> <p>If the Store is not blocked in your environment, Vantage will automatically update itself as new versions are released.</p> <pre><code># Version of Lenovo Vantage that is being deployed\n$DeployedVantageVersion = [version]\"20.2506.39.0\"\n\ntry\n{\n    # Get the path to the most recent VantageService folder under ProgramFiles(x86)\n    $vantageServicePath = Get-ChildItem -Path \"${env:ProgramFiles(x86)}\\Lenovo\\VantageService\" -Directory | Select-Object -Last 1\n\n    # Check if the path exists before proceeding\n    if ($vantageServicePath)\n    {\n        # Find LenovoVantageService.exe in the directory\n        $vantageServiceFile = Get-ChildItem -Path $vantageServicePath.FullName -Filter \"LenovoVantageService.exe\" -File -Recurse -ErrorAction Stop | Select-Object -Last 1\n\n        if ($vantageServiceFile)\n        {\n            # Extract the version information\n            $serviceVersion = [version]$vantageServiceFile.VersionInfo.FileVersion\n        }\n        else\n        {\n            $serviceVersion = $null\n            Write-Warning \"LenovoVantageService.exe was not found.\"\n        }\n    }\n    else\n    {\n        $serviceVersion = $null\n        Write-Warning \"VantageService directory was not found.\"\n    }\n\n\n    $minServiceVersion = [version]\"3.8.23.0\"\n    if ($serviceVersion -le $minServiceVersion)\n    {\n        Write-Output \"Lenovo Vantage Service is outdated (found version $serviceVersion, required minimum $minServiceVersion).\"\n        exit 1\n    }\n}\ncatch\n{\n    Write-Output \"Failed to retrieve Lenovo Vantage Service version. Error: $($_.Exception.Message)\"\n    exit 1\n}\n\n# Check for the Lenovo Vantage Addins directory\ntry\n{\n    $addinsPath = \"$env:ProgramData\\Lenovo\\Vantage\\Addins\"\n    if (Test-Path -Path $addinsPath -PathType Container)\n    {\n        Write-Output \"Lenovo Vantage Addins directory found at $addinsPath.\"\n    }\n    else\n    {\n        Write-Output \"Lenovo Vantage Addins directory not found at $addinsPath.\"\n        exit 1\n    }\n}\ncatch\n{\n    Write-Output \"Failed to check Lenovo Vantage Addins directory. Error: $($_.Exception.Message)\"\n    exit 1\n}\n\n# Check for the Lenovo Commercial Vantage APPX package\ntry\n{\n    $vantagePackage = Get-AppxPackage -Name E046963F.LenovoSettingsforEnterprise -AllUsers -ErrorAction Stop\n    $installedVersion = [version]$vantagePackage.Version\n\n    if ($installedVersion -ge $DeployedVantageVersion)\n    {\n        Write-Output \"Lenovo Commercial Vantage APPX package is up-to-date (installed version: $installedVersion, required version: $DeployedVantageVersion).\"\n        exit 0\n    }\n    else\n    {\n        Write-Output \"Lenovo Commercial Vantage APPX package is outdated (installed version: $installedVersion, required version: $DeployedVantageVersion).\"\n        exit 1\n    }\n}\ncatch\n{\n    Write-Output \"Failed to detect Lenovo Commercial Vantage APPX package. Error: $($_.Exception.Message)\"\n    exit 1\n}\n</code></pre> <p></p> <p>Click Review and then Save to complete the app creation and content upload to Intune. Once the upload has finished, assign to a group.</p>"},{"location":"deploying-commercial-vantage-with-intune/#automatically-create-the-win32-app","title":"Automatically Create the Win32 App","text":"<p>A PowerShell helper script can be used to automatically create the Win32 app using the IntuneWin32App module.</p> <p>Download the New-CommercialVantageWin32.ps1 and Detect-CommercialVantage.ps1 from my GitHub here.</p>"},{"location":"deploying-commercial-vantage-with-intune/#results","title":"Results","text":"<p>Track the installation through the IntuneManagementExtension.log</p> <p>Here we can see the minimum OS version requirement has been met</p> <p></p> <p>The additional requirement to check if the system is in fact a Lenovo system is true</p> <p></p> <p>Monitoring the AgentExecutor.log, the detection script returns Commercial Vantage is up-to-date</p> <p></p>"},{"location":"enabling-logging-for-commercial-vantage/","title":"Enabling Logging for Commercial Vantage","text":"<p>As noted in our docs, logging is not enabled by default any longer for Commercial Vantage. This is in regards to the System Update add-in. Historically, a log file is generated when a device checks for or installs updates.</p> <p>Lenovo\u2019s Product Security team wanted to ensure that enabling logs was a customer choice, and not something that was enabled by default without customer knowledge. This blog will provide example solutions for enabling logging for devices managed by Intune and ConfigMgr.</p>"},{"location":"enabling-logging-for-commercial-vantage/#intune","title":"Intune","text":"<p>There are several options for Intune managed devices. We'll leverage Remediations for this example. A simple detection script will check for the necessary registry name and its value. If the value is False, the remediation script will flip it to True.</p> <p>Below is a sample detection that can be used:</p> <pre><code>$Path = \"HKLM:\\SOFTWARE\\WOW6432Node\\Lenovo\\SystemUpdateAddin\\Logs\"\n$Name = \"EnableLogs\"\n$Value = $true\n\ntry {\n    $Registry = Get-ItemProperty -Path $Path -Name $Name -ErrorAction Stop | Select-Object -ExpandProperty $Name\n    If ($Registry -eq $Value){\n        Write-Output -InputObject \"System Update logging enabled.\"\n        Exit 0\n    } \n    Write-Warning -Message \"System Update logging not enabled.\"\n    Exit 1\n} \ncatch {\n    Write-Warning -Message \"Could not enable System Update logging...\"\n    Exit 1\n}\n</code></pre> <p>Followed by a sample remediation:</p> <pre><code>Write-Output -InputObject \"Enabling System Update Logging...\"\n$Path = \"HKLM:\\SOFTWARE\\WOW6432Node\\Lenovo\\SystemUpdateAddin\\Logs\"\nIf (-not(Test-Path -Path $Path)) {\n    New-Item -Path $Path -Force\n}\nSet-ItemProperty $Path EnableLogs -Value $true\n</code></pre> <p>Login to the Microsoft Intune admin center and click create script package. Enter a name and select the detection and remediation script files to add. Choose to run the script in 64-bit PowerShell, configure the assignment and schedule. For our lab, I've set this to run hourly. Since this only applies to Lenovo devices, it may be worthwhile to create a device filter that only targets Lenovo branded systems. For example:</p> <pre><code>(device.manufacturer -eq \"LENOVO\")\n</code></pre> <p></p> <p>Once the device retrieves the policy for Remediation scripts, track the HealthScripts.log for details. In this screenshot, I can see logging was enabled and verified in the Registry</p> <p></p> <p>The next time the System Update feature of Commercial Vantage runs, you can find the log in the following location:</p> <pre><code>%ProgramData%\\Lenovo\\Vantage\\AddinData\\LenovoSystemUpdateAddin\\logs\n</code></pre>"},{"location":"enabling-logging-for-commercial-vantage/#configmgr","title":"ConfigMgr","text":"<p>For ConfigMgr managed devices, you can import a sample Configuration Baseline that will accomplish the same result.</p> <p>Download the Baseline here.</p> <p>If you look at the properties of the Configuration Item, you'll see this is a simple Registry value setting type and a single compliance rule.</p> <p></p> <p></p> <p>When you deploy the Baseline, be sure to check the options to Remediate noncompliant rules when supported and Allow remediation outside the maintenance window.</p> <p></p> <p>Happy logging!</p>"},{"location":"dynamically-updating-think-product-bios-with-configmgr/","title":"Dynamically Updating Think Product BIOS with ConfigMgr","text":"<p>What follows is a brief look at what is possible and not necessarily recommended for everyone.  Hopefully someone finds it useful.</p> <p>Earlier at MMS this year (2017), a fantastic session on modern driver management in OS deployments was presented by Kim Oppalfens and Tom Degreef.  This method and what it entails can be found here.</p> <p>I was inspired by their session and wanted to see if this could work with Lenovo's BIOS updates in a similar manner.  The workflow is basically the same, with the key piece being the overridable task sequence variable in the Download Package Content step called OSDDownloadDownloadPackages.</p> <p>Here's the layout of the Task Sequence:</p> <p></p>"},{"location":"dynamically-updating-think-product-bios-with-configmgr/#creating-the-packages","title":"Creating the Package(s)","text":"<p>You'll need to download the latest BIOS for your model from Lenovo's support site and extract the contents to a source directory.  Here's the folder structure I use in my lab:</p> <p><code>&lt;Share&gt;\\OSD\\BIOS\\&lt;first 4 characters of BIOS&gt;\\&lt;version&gt;</code></p> <p>Example:</p> <p><code>&lt;Share&gt;\\OSD\\BIOS\\R06E\\1.27</code></p> <p>The BIOS used here is for a ThinkPad Yoga 370.  You can find the SMBiosBiosVersion of your systems by running the following PowerShell command:</p> <p><code>(get-wmiobject win32_bios).smbiosbiosversion</code></p> <p>You can also find this on the BIOS Update Utility page for your system, near the bottom under Previous Version.</p> <p></p> <p>Back in the ConfigMgr console, create a standard package (no program).  Here's my Yoga 370 example:</p> <p></p> <p>You can name these however you want as long as you have the 1st 4 characters of the BIOS in the Name field.  Also recommended to include the version of the BIOS and for easy access to future BIOS updates, I added the URL to the Update Utility page for the system in the Comment field.  Distribute the newly created Package to your distribution points.</p>"},{"location":"dynamically-updating-think-product-bios-with-configmgr/#dynamic-bios-powershell-script-get-biospackagesps1","title":"Dynamic BIOS PowerShell Script (Get-BIOSPackages.ps1)","text":"<p>Generate the XML by running the following commands (on the Site Server):</p> <pre><code>$SiteCode = $(Get-WmiObject -ComputerName \"$ENV:COMPUTERNAME\" -Namespace \"root\\SMS\" -Class \"SMS_ProviderLocation\").SiteCode\n\nGet-WmiObject -Class sms_package -Namespace root\\sms\\site_$SiteCode | Select-Object Name,PackageID,Version | Sort-Object -Property Name | Export-Clixml -Path \"BIOSPackages.xml\"\n</code></pre> <p>Create another Package named Get-BIOSPackages.  This will contain the source path of the PowerShell script that will dynamically match the system's BIOS to the appropriate PackageID as well as the BIOSPackages.xml that was generated above.  Credit goes to Kim Oppalfens for the original script, which I tweaked for the BIOS part.</p> <p>If you are still using PowerShell v2, replace Get-CimInstance with Get-WmiObject</p> <pre><code>[xml]$Packages = Get-Content BIOSPackages.xml\n\n# Environment variable call for task sequence only\n\n$tsenv = New-Object -ComObject Microsoft.SMS.TSEnvironment\n\n$BIOS = (Get-CimInstance -Namespace root\\cimv2 -ClassName Win32_BIOS).SMBIOSBIOSVersion.Substring(0,4)\n\n$ns = New-Object Xml.XmlNamespaceManager $Packages.NameTable\n\n$ns.AddNamespace( \"def\", \"http://schemas.microsoft.com/powershell/2004/04\" )\n\n$Xpathqry=\"/def:Objs/def:Obj//def:MS[contains(.,`\"$BIOS`\")]\"\n\n$Package = ($Packages.SelectNodes($xpathqry,$ns))\n\n$PackageID = $Package.SelectNodes('def:S[contains(@N,\"PackageID\")]',$ns)\n\n$tsenv.Value('OSDDownloadDownloadPackages') = $PackageID.InnerXML\n</code></pre>"},{"location":"dynamically-updating-think-product-bios-with-configmgr/#task-sequence","title":"Task Sequence","text":"<ol> <li> <p>Run PowerShell Script step, calling the Get-BIOSPackages.ps1</p> </li> <li> <p>Download Package Content step:  Choose any Package here as it will be overridden anyway. </p> <p>Tick the box to save the path as a variable named BIOS.  What happens here is when there's a package match to download, it will be saved to the C:_SMSTaskSequence\\Packages directory while also setting the custom variable of BIOS01, which is the first package being downloaded.  Here's what it looks like in the smsts.log.</p> <p></p> <p>Notice the PackageID of PS100077.  This matches the Yoga 370 Package that was created earlier.</p> </li> <li> <p>Run Command Line: Flash ThinkPad BIOS</p> <p>If you have a combination of Think products, add a second and/or third step with the appropriate WMI query. See screenshots</p> <p></p> <p>The command line here is simply executing winuptp64.exe with the silent switch, which is the BIOS flash utility.  The 64-bit version of winuptp should be found in just about all BIOS Update Utility packages for systems dating back to the Haswell line.</p> <p>In the Start in: field, enter %BIOS01% as this will tell winuptp64.exe to execute from the directory as explained above.</p> <p></p> </li> <li> <p>Task Sequence Variable to reboot system.  This will complete the flash operation.</p> <p></p> <p>To finish the Task Sequence cleanly, I'm using the SMSTSPostAction variable with the value being wpeutil reboot (if in WinPE).  If in FullOS, use the native restart computer step.</p> </li> </ol> <p>ThinkCentre Flash Command Line</p> <p>flash64.cmd /ign /sccm /quiet</p> <p>SMSTSPostAction (If in WinPE) = wpeutil shutdown </p> <p>(If in FullOS) = cmd.exe /c shutdown -s -t 0 -f</p> <p>This will not shut down the system to the point of having to physically push the power button to turn back on.  This just instructs the BIOS update to proceed to phase 2 of the flash process. The system will reboot and finish out the update.</p> <p>ThinkStation Flash Command Line</p> <p>flashx64.cmd</p> <p>SMSTSPostAction (If in WinPE) = wpeutil shutdown </p> <p>(If in FullOS) = cmd.exe /c shutdown -s -t 0 -f</p>"},{"location":"dynamically-updating-think-product-bios-with-configmgr/#other-things-to-consider","title":"Other things to consider","text":"<p>Depending on your scenario, if updating BIOS from full OS, don't forget to disable BitLocker (if applicable) prior to continuing and re-enable post flash.</p> <p>Consider the following \"gotcha\" scenario:</p> <p>Windows 7 is installed on a ThinkCentre, which is encrypted with BitLocker.  The protectors will not automatically enable after the flash completes and the system has rebooted as opposed to Windows 10, leaving the system unprotected.  This is because of the required shutdown in order to finish the flash.  A possible workaround is to add a Run Command Line step to add a RunOnce reg key to enable protectors before the shutdown.</p> <pre><code>reg add HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce /v EnableBitLocker /t REG_SZ /d \"cmd.exe /c manage-bde -protectors -enable c:\"\n</code></pre>"},{"location":"dynamically-install-hardware-support-apps-with-configmgr/","title":"Dynamically Install Hardware Support Apps with ConfigMgr","text":"<p>This article is intended to provide another solution to install HSA packs for your Think product in a ConfigMgr Task Sequence.</p> <p>For an in-depth overview of these HSA packs and installation script, refer to this article.  </p> <p>To make this process a bit easier and to reduce the number of steps in your Task Sequence, this solution goes hand in hand with an older post: Dynamically Updating BIOS.</p>"},{"location":"dynamically-install-hardware-support-apps-with-configmgr/#workflow","title":"Workflow","text":"<p>We can achieve this in essentially 3 steps in a Task Sequence.</p> <ul> <li>Set the correct Package to download for the applicable model (PowerShell script)</li> <li>Download Package to a custom path on the client</li> <li>Installation using the Install-HSA.ps1 script found here</li> </ul>"},{"location":"dynamically-install-hardware-support-apps-with-configmgr/#download-hsa-pack-manual-way","title":"Download HSA Pack (Manual Way)","text":"<p>First, you'll need to download/extract the contents of the HSA pack to a desired location and place the Install-HSA.ps1 file in the top level directory.</p> <p></p>"},{"location":"dynamically-install-hardware-support-apps-with-configmgr/#create-legacy-packages","title":"Create Legacy Package(s)","text":"<p>In the ConfigMgr console, create a Package (No Program) and enter the following details</p> <ul> <li>Name - Friendly name of the system.  For example, ThinkPad X13 Yoga Gen 1</li> <li>This can be found in the deployment recipe card for the model</li> <li>Version - This is optional, but I entered the HSA pack version, which can be found in the ReadMe or typically in the pack's file name.</li> <li>Description/Comment - This is the first 4 characters of the Machine Type Model. For Example, 21D6,21D7</li> <li>Also found in the deployment recipe card</li> </ul> <p></p> <ul> <li>MIF File Name - HSA</li> <li>MIF Name - OS version. win10 or win11</li> <li>MIF Version - Windows Build. For example 22H2 or 22H2_23H2 (if deploying to Windows 10/11 23H2). Note: This is not to be used as a parameter value in the task sequence.</li> </ul> <p>If there are no 23H2 HSA packs available, use the 22H2 packs.</p> <p></p>"},{"location":"dynamically-install-hardware-support-apps-with-configmgr/#download-hsa-pack-automated-way","title":"Download HSA Pack (Automated Way)","text":"<p>We have added a new node in the Think Deploy catalog for HSAs. With this, we can automate the download, extraction, and creation of ConfigMgr packages with the PowerShell script New-LnvHsaConfigMgrPackage.ps1.</p> <p></p> <p>You can select a single pack to download or ctrl + click for multiple. The packs will download and extract to the temp directory, moved to the share you specify, and finally ConfigMgr Packages are created.</p> <p></p> <p>You'll need to distribute the content to your Distribution Points</p> <p>The script can be found on my GitHub here</p> <p>https://github.com/philjorgensen/ConfigMgr/tree/main/Packages</p>"},{"location":"dynamically-install-hardware-support-apps-with-configmgr/#generating-the-packages-xml","title":"Generating the Packages XML","text":"<p>If you don't already have a Package containing your Scripts, create another one for this purpose.</p> <p>Referencing the Dynamic BIOS Update post, you'll need to generate an XML containing your Packages. This XML will contain the necessary data in order to match the HSA Package to your Think product. To generate the XML, run the below code</p> <pre><code># Connect to ConfigMgr Site \n\n$SiteCode = $(Get-WmiObject -ComputerName \"$ENV:COMPUTERNAME\" -Namespace \"root\\SMS\" -Class \"SMS_ProviderLocation\").SiteCode\n\n# Get Package data and export XML\nGet-WmiObject -Class SMS_Package -Namespace root\\SMS\\Site_$SiteCode | Select-Object Pkgsourcepath, Description, Manufacturer, MifFileName, MifName, MIFVersion, Name, PackageID, ShareName, Version | Sort-Object -Property Name | Export-Clixml -Path '_Packages.xml' -Force \n</code></pre> <p>If you open the XML, the contents should be similar to this</p> <p></p> <p>Copy this XML to your Scripts folder.  Along with the XML, another piece to the puzzle is needed to be able to grab the correct HSA Package during the Task Sequence.  The below PowerShell script (Get-DynamicHsaPackages.ps1) will look at the Packages.xml, match the Name/MTM to it's corresponding HSA Package, and leverage the OSDDownloadDownloadPackages override variable in the Download Package Content step.  This script needs to be saved in your Scripts folder as well.</p> <pre><code>[CmdletBinding()]\nparam (\n    [Parameter(ValueFromPipelineByPropertyName, Position = 0)]\n    [string] $MatchProperty = 'Description',\n\n    [Parameter(ValueFromPipelineByPropertyName, Position = 1)]\n    [string] $MachineType = (Get-CimInstance -Namespace root/CIMV2 -ClassName Win32_ComputerSystemProduct).Name.Substring(0, 4).Trim(),\n\n    [Parameter(ValueFromPipelineByPropertyName, Position = 2)]\n    [string] $PackageXMLLibrary = \".\\_Packages.xml\",\n\n    [Parameter(ValueFromPipelineByPropertyName, Position = 3)]\n    [ValidateSet(\"win10\", \"win11\")]\n    [string] $WindowsVersion = \"\",\n\n    [Parameter(ValueFromPipelineByPropertyName, Position = 4)]\n    [ValidateSet(\"1709\", \"1803\", \"1809\", \"1903\", \"1909\", \"2004\", \"20H2\", \"21H1\", \"21H2\", \"22H2\", \"23H2\", \"24H2\")]\n    [string] $WindowsBuild = \"\"\n)\n\n# Initialize task sequence environment if available\n$tsenvInitialized = $false\ntry\n{\n    $tsenv = New-Object -ComObject Microsoft.SMS.TSEnvironment\n    $tsenvInitialized = $true\n}\ncatch\n{\n    Write-Host 'Not executing in a task sequence'\n}\n\n# Find the PackageID based on the criteria\ntry\n{\n    $PackageID = (Import-Clixml -Path $PackageXMLLibrary | Where-Object { \n            $_.$MatchProperty.Split(',').Contains($MachineType) -and\n            $_.MifFileName -eq \"HSA\" -and\n            $_.MifName -eq $WindowsVersion -and\n            $_.MifVersion -match $WindowsBuild }).PackageID\n}\ncatch\n{\n    Write-Error \"Failed to find the PackageID. Error: $_\"\n    exit 1\n}\n\n# Output the PackageID\nWrite-Output(\"$PackageID for $MachineType will be downloaded\")\n\n# Set the task sequence variable if initialized\nif ($tsenvInitialized)\n{\n    try\n    {\n        $tsenv.Value('OSDDownloadDownloadPackages') = $PackageID\n    }\n    catch\n    {\n        Write-Error \"Failed to set task sequence variable. Error: $_\"\n    }\n}\n</code></pre>"},{"location":"dynamically-install-hardware-support-apps-with-configmgr/#putting-it-all-together","title":"Putting It All Together","text":"<p>Confirm the Windows Powershell (WinPE-PowerShell) optional component is added to your boot image</p> <p>In my testing, I created a Child Task Sequence containing everything above and have added to my main Task Sequence. Here's what it would look like</p> <p>Run PowerShell Script: Select the Scripts Package containing:</p> <ul> <li>_.Packages XML</li> <li>Get-DynamicHsaPackages.ps1</li> </ul> <p>Script Name: Get-DynamicHsaPackages.ps1</p> <p>Parameters: -WindowsVersion 'win11' -WindowsBuild '23H2'</p> <ul> <li>If you're deploying Windows 11 23H2, these are the parameters you'll set.</li> </ul> <p>PowerShell execution policy: Set to Bypass</p> <p></p> <p>Download Package Content: This step will eventually get overridden due to the OSDDownloadDownloadPackages variable being set in the Get-DynamicHsaPackages script. So create an empty Package and add it here.</p> <p>Custom path: This is where the HSA Package will be downloaded to on the client. Here, I'm using the %_SMSTSMDataPath% (I have my drivers set to download here as well). On the client, this will resolve to C:_SMSTaskSequence\\HSAs\\HSA_PackageID</p> <p></p> <p>Run Command Line: This step calls PowerShell to execute the Install-HSA.ps1 with parameters to install all HSAs offline (WinPE).</p> <pre><code>powershell.exe -ExecutionPolicy Bypass -Command (%_SMSTSMDataPath%\\HSAs\\*\\Install-HSAs.ps1 -Offline -All -DebugInformation)\n</code></pre> <p></p> <p>This being a Child Task Sequence, I've added it to my main Task Sequence right after my Install Drivers step and before the Setup Windows and ConfigMgr Client step</p> <p></p>"},{"location":"remediate-fibocom-fwswitchservice-on-devices-without-wwan-card/","title":"Remediate Fibocom FwSwitchService on Devices Without WWAN Card","text":"<p>After a successful Operating System Deployment (OSD), customers have noted the Fibocom FWSwitchService running on devices without a Fibocom WWAN Card.  In this blog post, we provide the cause and remediation for this issue.</p>"},{"location":"remediate-fibocom-fwswitchservice-on-devices-without-wwan-card/#cause","title":"Cause","text":"<p>The FwUpdateDriver.inf in the SCCM Driver Pack is listed as boot critical, forcing it to be added to the driver store and installed to the operating system during OSD.</p>"},{"location":"remediate-fibocom-fwswitchservice-on-devices-without-wwan-card/#impacted-models","title":"Impacted Models","text":"<pre><code>ThinkPad T14s Gen 4\nThinkPad T16 Gen 2\nThinkPad X1 Carbon Gen 11\n(In the future, this list may expand as other models are identified.)\n</code></pre>"},{"location":"remediate-fibocom-fwswitchservice-on-devices-without-wwan-card/#remediation","title":"Remediation","text":"<p>Apply a Configuration Manager Configuration Baseline with a Configuration Item to identify and resolve impacted devices.  We have exported the Configuration Baseline, which contains the Configuration Item, from an environment as CB \u2013 Fibocom FwSwitchService Fix.cab and are providing it in a ZIP file.  First, extract the .ZIP file and and then import the CB \u2013 Fibocom FwSwitchService Fix.cab into Configuration Manager.  Below is an explanation of the Configuration Baseline and Configuration Item.</p> <p>Download the Configuration Baseline here</p> <p>The Configuration Item contains one script setting type consisting of detection/remediation scripts.  These scripts will detect if the device has Fibocom hardware, if the FwSwitchService is running, and will remediate if the hardware is not found and the service is running.</p>"},{"location":"remediate-fibocom-fwswitchservice-on-devices-without-wwan-card/#settings-type-script","title":"Settings - Type Script","text":"<pre><code>Name - Detect Fibocom FWSwitchService\nSetting type - Script\nData type - Boolean\n</code></pre>"},{"location":"remediate-fibocom-fwswitchservice-on-devices-without-wwan-card/#supported-platforms","title":"Supported Platforms","text":"<pre><code>All Windows 10 (ARM64)\nAll Windows 10 (64-Bit)\nAll Windows 11 (ARM64)\nAll Windows 11 (64-bit)\n</code></pre>"},{"location":"remediate-fibocom-fwswitchservice-on-devices-without-wwan-card/#discovery-script","title":"Discovery Script","text":"<p>Detect listed Fibocom devices.  If any of the listed Fibocom devices are found, return false to keep the FWSwitchService enabled on the device.  If none of the listed Fibocom devices are found and the FWSwitchService service is enabled, return true to be remediated.  If no listed Fibocom devices are found and the FWSwitchService service is disabled, return false as the service is not running.</p> <pre><code>$FiboFWDev = Get-PnpDevice | Where-Object {$_.HardwareID -contains \"MBFW\\{ba3ec007-246e-4a4c-ad06-ee9342198298}\" -or $_.HardwareID -contains \"MBFW\\{66e99d5f-c11d-4438-811f-6d816b7391bb}\" -or $_.HardwareID -contains \"MBFW\\{65119331-831e-45f1-b036-fb8ac7c445dd}\" -or $_.HardwareID -contains \"MBFW\\{7ff0c42a-1a08-493f-bb35-9a8c86dbb588}\" -or $_.HardwareID -contains \"MBFW\\{536bfd93-86ab-4a6c-9ab0-0afc7ee4c11e}\" -or $_.HardwareID -contains \"MBFW\\{81648c03-219b-434d-867d-7c262fea3f97}\"}\nIf($Null -eq $FiboFWDev){\n    $FiboFWServ = Get-Service -Name FirmwareSwitchService -ErrorAction SilentlyContinue\n    If($FiboFWServ){\n        If($FiboFWServ.StartType -eq 'Disabled'){\n            Return $False\n        }\n        Else{\n            Return $True\n        }\n    }\n    Else{\n        Return $False\n    }\n}\nElse{\n    Return $False\n}\n</code></pre>"},{"location":"remediate-fibocom-fwswitchservice-on-devices-without-wwan-card/#remediation-script","title":"Remediation Script","text":"<p>When a remediation request is attempted, the device should search through all the installed drivers and uninstall the Fibocom driver with the FWSwitchService.exe.  Upon uninstall, the service, if running, will stop and be set to disabled.  On the next reboot, the FWSwitchService service will be removed from the services snapin.</p> <pre><code>$GCI = Get-ChildItem -Path \"C:\\Windows\\Inf\" -Name -Include *.inf\nForEach ($File in $GCI){$Content = Get-Content -Path \"C:\\Windows\\Inf\\$file\"\n    If($Content -match \"FWSwitchService.exe\"){\n        Start-Process -FilePath \"C:\\windows\\system32\\pnputil.exe\" -ArgumentList \"/delete-driver $file /uninstall /force\" -WindowStyle Hidden\n    }\n}\n</code></pre>"},{"location":"remediate-fibocom-fwswitchservice-on-devices-without-wwan-card/#deploying-the-baseline","title":"Deploying the Baseline","text":"<p>When ready to deploy the baseline, be sure to check the box to remediate noncompliant rules when supported.  It is suggested to test this on a small collection of T14s Gen 4, X1 Carbon Gen 11, and T16 Gen 2 devices where the collection contains a mixture of devices both with and without the Fibocom WWAN card and review the impact.</p> <p></p>"},{"location":"remediate-fibocom-fwswitchservice-on-devices-without-wwan-card/#monitoring","title":"Monitoring","text":"<p>In the console, navigate to the Monitoring workspace and select the Deployments node.  Here you can review the status of the baseline.</p>"},{"location":"hardware-support-apps-without-microsoft-store/","title":"Hardware Support Apps without Microsoft Store","text":"<p>With versions of Windows 10 since 1809, Microsoft has introduced the concept of Modern Drivers.  These new drivers have a few requirements:</p> <ul> <li>Declarative:  The driver must be INF installable with no co-installers</li> <li>Componentized:  The driver must support the architecture of having a base driver with optional extension drivers for customizations above the base functionality</li> <li>Hardware Support Apps:  Any software required for working with the device must be in the form of a UWP app available from the Microsoft Store and will be associated to this driver in the INF.</li> </ul> <p>One intent of these items is to simplify in-place upgrades.  With this approach, if a Windows 10 device is upgraded to a new build by Windows Update and any new drivers are required, Windows Update can install the driver and it can trigger the software to be installed automatically from the Microsoft Store.</p> <p>But what happens if you have blocked access to the Microsoft Store?  You will end up with a driver installed for a component without the software to control the device.  Keep in mind that not all device drivers will require a software component.  However, for those that do you may need them to get the full user experience from your device.</p> <p>So how do you deploy these Hardware Support Apps (HSAs) without using the Microsoft Store?  This is where Lenovo's Hardware Support App Packs come in.</p> <p>Starting in late June of 2020 you will begin to see these show up on the Lenovo Support site on the Drivers &amp; Software page for the specific model, under the Enterprise Management component.  These will be available for the new products just launched and going forward.  The HSA Packs are similar to our SCCM Driver Packs.  They contain just the source files to install the apps for specific models.  One difference between the two is that the HSA Packs will typically need to be updated much less frequently.  With this architecture, the driver may change several times and continue to use the same HSA.</p> <p>The HSA Pack will be a self-extracting executable file like our SCCM Driver Packs.  When you extract one you will get a folder structure with each app's source files contained in their own folder.  By default a folder with a random name will be used to prevent any kind of symlink vulnerability.</p> <p></p>"},{"location":"hardware-support-apps-without-microsoft-store/#scripted-install-of-hardware-support-apps-during-a-task-sequence","title":"Scripted Install of Hardware Support Apps during a Task Sequence","text":"<p>We have created a script to read JSON manifest files provided in the HSA packs.  The script can be leveraged in MEM/SCCM or MDT.  Below is the PowerShell script you can use for installation.</p> Install-HSA.ps1<pre><code>################################################################################\n##                                                                            ##\n##      Title: Install-HSA.ps1                                                ##\n##  Publisher: Lenovo                                                         ##\n##    Version: 1.03                                                           ##\n##       Date: 2024-04-10                                                     ##\n##                                                                            ##\n##                              Legal Disclaimer                              ##\n##                                                                            ##\n##  The sample scripts are not supported under any Lenovo standard support    ##\n##  program or service. The sample scripts are provided AS IS without         ##\n##  warranty of any kind. Lenovo further disclaims all implied warranties     ##\n##  including, without limitation, any implied warranties of                  ##\n##  merchantability or of fitness for a particular purpose. The entire risk   ##\n##  arising out of the use or performance of the sample scripts and           ##\n##  documentation remains with you. In no event shall Lenovo, its authors,    ##\n##  or anyone else involved in the creation, production, or delivery of the   ##\n##  scripts be liable for any damages whatsoever (including, without          ##\n##  limitation, damages for loss of business profits, business                ##\n##  interruption, loss of business information, or other pecuniary loss)      ##\n##  arising out of the use of or inability to use the sample scripts or       ##\n##  documentation, even if Lenovo has been advised of the possibility of      ##\n##  such damages.                                                             ##\n##                                                                            ##\n################################################################################\n\n\n&lt;#\n.SYNOPSIS\n\n    List the names of or install Hardware Support Applications (HSA) by \n    reading manifest files located in the subdirectories.\n\n.DESCRIPTION\n\n    By reading manifest files found in the subdirectories of a Hardware Support \n    Applications Pack, this script allows for the deployment of one, many, or \n    all Hardware Support Applications for a given model.  All installations are \n    against an offline installation of Windows 10.\n\n.PARAMETER LIST\n\n    Used to list the names of all Hardware Support Applications in the \n    subdirectories.  Returns the list of the Hardware Support \n Applications names to the screen.\n\n    -LIST\n\n.PARAMETER EXPORT\n\n    Used to list the names of all Hardware Support Applications in the \n    subdirectories.  Returns the list of names to the Export_{Date}{Time}.txt \n    file in the directory from which the script was executed.\n\n    -LIST -EXPORT\n\n.PARAMETER OFFLINE\n\n    Used to install the Hardware Support Applications.\n\n    -OFFLINE {-ALL, FILE '{FileName}.txt', or -NAME '{HSA Name}'}\n\n.PARAMETER ALL\n\n    Used to install all Hardware Support Applications in the subdirectories \n    below the script.\n\n    -OFFLINE -ALL\n\n.PARAMETER FILE\n\n    Used to install a list of Hardware Support Applications.  The text file \n    should be formatted with one Hardware Support Application name per line.  \n    The file should reside in the same folder as the Install-HSA.ps1 script.  \n    The names can be found using the -LIST parameter.  \n\n    -OFFLINE -FILE '{FileName}.txt'\n\n.PARAMETER NAME\n\n    Used to install one Hardware Support Application.  The name can be found \n    using the -LIST parameter.\n\n    -OFFLINE -NAME '{HSA Name}'\n\n.PARAMETER NOSMSTS\n\n    Used when running in WinPE, but not in a Microsoft.SMS.TSEnvironment, \n    provided by Microsoft Endpoint Manager (MEM), System Center \n    Configuration Manager (SCCM), or Microsoft Deployment Toolkit (MDT).\n\n    Call this parameter with the drive letter where the Windows partition has \n    the Windows folder already installed.\n\n    -NOSMSTS '{Drive Letter}:'\n\n.PARAMETER DEBUGINFORMATION\n\n    Use to turn on Transcript logging and full logging of DISM Commands.  The \n    transcript file can be found at C:\\Windows\\Logs.  There will be a separate  \n    log file from each DISM command generated at C:\\Windows\\Logs\\DISM.\n\n    -DEBUGINFORMATION\n\n.EXAMPLE\n\n    .\\Install-HSA.ps1 -LIST\n\n.EXAMPLE\n\n    .\\Install-HSA.ps1 -LIST -EXPORT\n\n.EXAMPLE\n\n    .\\Install-HSA.ps1 -OFFLINE -NAME 'Lenovo Pen Settings'\n\n.EXAMPLE\n\n    .\\Install-HSA.ps1 -OFFLINE -FILE 'List.txt'\n\n.EXAMPLE\n\n    .\\Install-HSA.ps1 -OFFLINE -NOSMSTS 'D:' -ALL\n\n.EXAMPLE\n\n    .\\Install-HSA.ps1 -OFFLINE -NOSMSTS 'D:' -ALL -DEBUGINFORMATION\n\n.NOTES\n\n    Return Code 1 : Both the -LIST and -OFFLINE commands were used.  Only one \n                    of these two parameters can be used at a time.\n    Return Code 2 : More than one -ALL, -FILE, or -NAME were used.  Only one \n                    of these three parameters can be used at a time.\n    Return Code 3 : No *_HSA_Manifest.json files were found in the \n                    subdirectories.\n    Return Code 4 : When using the -FILE parameter, the file name was not \n                    found in the directory where the script resides.\n\n#&gt;\n\n&lt;#\nVersion history\n\n- 1.03: Remove incompatible characters from the log file name.\n\n- 1.02: Initial Release\n\n#&gt;\n\n#######################\n#  SCRIPT PARAMETERS  #\n#######################\n[CmdletBinding(DefaultParameterSetName = 'GetList')]\nParam(\n    [Parameter(ParameterSetName = 'GetList')]\n    [switch]$List,\n    [Parameter(ParameterSetName = 'GetList')]\n    [switch]$Export,\n    [Parameter(ParameterSetName = 'InstallOffline')]\n    [switch]$Offline,\n    [Parameter(ParameterSetName = 'InstallOffline')]\n    [ValidateNotNullOrEmpty()]\n    [string]$Name,\n    [Parameter(ParameterSetName = 'InstallOffline')]\n    [ValidateNotNullOrEmpty()]\n    [string]$File,\n    [Parameter(ParameterSetName = 'InstallOffline')]\n    [switch]$All,\n    [Parameter(ParameterSetName = 'InstallOffline')]\n    [ValidateNotNullOrEmpty()]\n    [string]$NoSMSTS,\n    [Parameter(ParameterSetName = 'GetList')]\n    [Parameter(ParameterSetName = 'InstallOffline')]\n    [switch]$DebugInformation\n)\n###############\n#  FUNCTIONS  #\n###############\n#Install-HSA\nFunction Install-HSA\n{\n    [CmdletBinding()]\n    param (\n        [PSCustomObject]$HSAPackage,\n        [String]$HSAName\n    )\n    $OutDep = $Null\n    If((($HSAName -contains $HSAPackage.hsa) -and ($Null -ne $HSAName))-or $All)\n    {\n        ForEach($Dep in $HSAPackage.Dependencies)\n        {\n            $OutDep += \" /DependencyPackagePath:`\"$($HSAPackage.JSONPath)\\$($Dep)`\"\"\n        }\n        $DISMLog = \"\"\n        If($DebugInformation)\n        {\n            If(!(Test-Path -Path \"$($LogPath)\\DISM\"))\n            {\n                New-Item -Path \"$($LogPath)\\DISM\" -ItemType Directory\n            }\n            $HsaLogName = $($HSAPackage.hsa) -replace '\\&lt;|\\&gt;|:|\"|/|\\\\|\\||\\?|\\*', '_'\n            $DISMLog = \" /LogLevel:4 /LogPath:`\"$LogPath\\DISM\\$HsaLogName.log`\"\"\n        }\n        $DISMArgs = \"/Add-ProvisionedAppxPackage /PackagePath:`\"$($HSAPackage.JSONPath)\\$($HSAPackage.appx)`\" /LicensePath:`\"$($HSAPackage.JSONPath)\\$($HSAPackage.license)`\"$($OutDep) /Region:`\"All`\"$DISMLog\"\n        Write-Host \"Offline DISM - $($HSAPackage.hsa)\"\n        If($NoSMSTSPresent)\n        {\n            Write-Host \"Using string data from NoSMSTS parameter to define the root drive letter for the DISM /Image parameter.\"\n        }\n        $DISMArgs = \"/Image:$($Drive)\\ $($DISMArgs)\"\n        Write-Host \"$env:windir\\system32\\Dism.exe $DISMArgs\"\n        Start-Process -FilePath \"$env:windir\\system32\\Dism.exe\" -ArgumentList $DISMArgs -Wait -WindowStyle Hidden\n    }\n}\n##################\n#  SCRIPT SETUP  #\n##################\n$FilePresent = $false\n$NamePresent = $false\n$NoSMSTSPresent = $false\nIf(($PSBoundParameters.ContainsKey('List') -and $PSBoundParameters.ContainsKey('Offline')))\n{\n    Write-Host \"Use just one from the following list of parameters: -List or -Offline.  Review the script usage information for using these parameters.\"\n    Return 1\n}\nIf($Offline)\n{\n    If(($PSBoundParameters.ContainsKey('All') -and $PSBoundParameters.ContainsKey('File') -and $PSBoundParameters.ContainsKey('Name')) -or ($PSBoundParameters.ContainsKey('All') -and $PSBoundParameters.ContainsKey('File')) -or ($PSBoundParameters.ContainsKey('All') -and $PSBoundParameters.ContainsKey('Name')) -or ($PSBoundParameters.ContainsKey('File') -and $PSBoundParameters.ContainsKey('Name')) -or ((!($PSBoundParameters.ContainsKey('All')) -and (!($PSBoundParameters.ContainsKey('File'))) -and (!($PSBoundParameters.ContainsKey('Name'))))))\n    {\n        Write-Host \"Use just one from the following list of parameters: -All, -Name, or -File.  Review the script usage information for using these parameters.\"\n        Return 2\n    }\n    ElseIf($PSBoundParameters.ContainsKey('File'))\n    {\n        $FilePresent = $true\n    }\n    ElseIf($PSBoundParameters.ContainsKey('Name'))\n    {\n        $NamePresent = $true\n    }\n}\nIf($PSBoundParameters.ContainsKey('NoSMSTS'))\n{\n    $NoSMSTSPresent = $true\n}\n#Setup Vars\n$ScriptDir = Split-Path $Script:MyInvocation.MyCommand.Path\nIf(($Offline) -and (!($NoSMSTSPresent)))\n{\n    $TSenv = New-Object -COMObject Microsoft.SMS.TSEnvironment\n    If($TSEnv.value(\"OSDTargetSystemDrive\") -ne \"\")\n    {\n        $Drive = \"$($TSEnv.value(\"OSDTargetSystemDrive\"))\"\n    }\n    Else\n    {\n        $Drive = \"$($TSEnv.value(\"OSDisk\"))\"\n    }\n}\nElseIf(($Offline) -and ($NoSMSTSPresent))\n{\n    $Drive = $NoSMSTS\n}\nElseIf($List)\n{\n    $Drive = $env:SystemDrive\n}\n$LogDate = Get-Date -Format yyyyMMddHHmmss\nIf($DebugInformation)\n{\n    $LogPath = \"$($Drive)\\Windows\\Logs\"\n    $LogFile = \"$LogPath\\$($myInvocation.MyCommand)_$($LogDate).log\"\n\n######################\n#  START TRANSCRIPT  #\n######################\n    Start-Transcript $LogFile -Append -NoClobber\n    Write-Host \"Debug enabled\"\n}\n##########\n#  MAIN  #\n##########\n$MFJs = Get-ChildItem -path $ScriptDir -Recurse -File -Include \"*_manifest.json\"\nIf($Null -eq $MFJs)\n{\n    Write-Host \"No HSA_Manifest.JSON files found in the subfolder structure.\"\n    Return 3\n}\nElse\n{\n    $HSAPackages = @()\n    ForEach($MFJ in $MFJs)\n    {\n        $MFJData = Get-Content -Path \"$($MFJ.FullName)\" | ConvertFrom-Json\n        $HSAPackages += New-Object PSObject -Property @{'JSONPath' = $MFJ.DirectoryName; 'HSA' = $MFJData.HSA; 'Appx' = $MFJData.Appx; 'License' = $MFJData.License; 'Dependencies' = $MFJData.Dependencies}\n    }\n}\nIf($List -or $PSBoundParameters.Count -eq 0 -or ($DebugInformation -and $PSBoundParameters.Count -eq 1))\n{\n    If($PSBoundParameters.ContainsKey('Export'))\n    {\n        ForEach($Package in $HSAPackages)\n        {\n            $Package.hsa | Out-File \"$ScriptDir\\Export_$LogDate.txt\" -Append -Noclobber\n        }\n    }\n    Else\n    {\n        ForEach($Package in $HSAPackages)\n        {\n            Write-Host $Package.hsa\n        }\n    }\n}\nIf($Offline)\n{\n    If($All)\n    {\n        Write-Host \"Installing all HSAs found in the folder structure.\"\n    }\n    ElseIf($NamePresent)\n    {\n        Write-Host \"Installing the $Name HSA.\"\n    }\n    ElseIf($FilePresent)\n    {\n        Write-Host \"Reading the list of HSAs from $File.\"\n        If(!(Test-Path -Path \"$ScriptDir\\$File\"))\n        {\n            Write-Host \"File: $File not found in $ScriptDir\"\n            Return 4\n        }\n    }\n    ForEach($Package in $HSAPackages)\n    {\n        If($All)\n        {\n            Install-HSA -HSAPackage $Package\n        }\n        ElseIf($FilePresent -or $NamePresent)\n        { \n            If($FilePresent)\n            {\n                $InstallFileArray = @()\n                $InstallFileArray = Get-Content -Path \"$ScriptDir\\$File\"\n                ForEach($InstallFile in $InstallFileArray)\n                {\n                    Install-HSA -HSAPackage $Package -HSAName $InstallFile\n                }\n            }\n            If($NamePresent)\n            {\n                Install-HSA -HSAPackage $Package -HSAName $Name\n            }\n        }\n        $InstallFileArray = $Null\n    }\n}\nIf($DebugInformation)\n{\n    #####################\n    #  STOP TRANSCRIPT  #\n    #####################\n    Stop-Transcript\n}\n</code></pre> <ul> <li> <p>List Functionality \u2013 Used to list the names of all Hardware Support Applications in the subdirectories.  Returns the list of all Hardware Support Applications names to the screen.</p> </li> <li> <p>Export \u2013 Used to list the names of all Hardware Support Applications in the subdirectories.  Returns the list of all Hardware Support Applications names to the Export_{Date}{Time}.log file in the same directory from which the script was executed.</p> </li> <li> <p>Offline Install Functionality \u2013 Used to install the Hardware Support Applications.</p> </li> <li>All \u2013 Used to install all Hardware Support Applications in the subdirectories below the script.</li> <li>File \u2013 Used to install a list of Hardware Support Applications.  The text file should be formatted with one Hardware Support Application name per line.  The file should reside in the same folder as the Install-HSA.ps1 script.  The names can be found using the -LIST parameter</li> <li> <p>Name \u2013 Used to install one Hardware Support Application.  The name can be found using the -LIST</p> </li> <li> <p>NoSMSTS \u2013 used when running in winPE, but not in a Microsoft.SMS.TSEnvironment, provided by Microsoft Endpoint Manager (MEM) / System Center Configuration Manager (SCCM) or Microsoft Deployment Toolkit (MDT).</p> </li> <li> <p>Call this parameter with the drive letter and colon (:) where the Windows partition has the Windows folder already installed.</p> </li> <li> <p>DebugInformation \u2013 Used to turn on transcript logging and full logging of DISM commands.  The transcript file can be found at C:\\Windows\\Logs.  There will be a separate log file from each DISM command generated at C:\\Windows\\Logs\\DISM.</p> </li> </ul> <p>For MEM/SCCM and MDT implementations, we are providing the following guidance for the items needed to successfully deploying Lenovo devices. Each implementation has guidance on WinPE Optional Components Requirements, the package to convey the content to the device, and the Task Sequence task information to perform the install.</p>"},{"location":"hardware-support-apps-without-microsoft-store/#memsccm-implementation","title":"MEM/SCCM Implementation","text":""},{"location":"hardware-support-apps-without-microsoft-store/#windows-pe-optional-components-requirements","title":"Windows PE Optional Components Requirements","text":"<ul> <li>Microsoft .NET (WinPE-NetFx)</li> <li>Windows PowerShell (WinPE-PowerShell)</li> <li>Windows PowerShell (WinPE-DismCmdlets)</li> </ul>"},{"location":"hardware-support-apps-without-microsoft-store/#packaging","title":"Packaging","text":"<ol> <li>Download and extract the required HSA package from Lenovo's website.</li> <li>Copy the Install-HSA.ps1 script to the directory where the HSA package was extracted.</li> <li>Create a legacy package with the source files pointed to the directory where the HSA pack is extracted.  There is no need to create a program associated with this legacy package.</li> <li>Distribute to your environment.</li> </ol> <p>Note</p> <p>If you are going to install more than one HSA, but not all, and are going to use the -FILE parameter, be sure to include the text file with the list of HSA Names in the same directory as the script file.</p>"},{"location":"hardware-support-apps-without-microsoft-store/#task-sequence","title":"Task Sequence","text":"<ol> <li>After the Apply Operating System task, but before the Setup Windows and Configuration Manager task, add a Run PowerShell Script task.</li> <li>On the Properties tab, choose the Select a package with a PowerShell script option.  Click the Browse button to locate and select the package created above.</li> <li>In the Script name textbox, enter Install-HSA.ps1.</li> <li>In the Parameters textbox, enter the parameters required.  Ex. -Offline -All -DebugInformation.</li> <li>On the Options tab, if needed, add the conditional statement and any WMI queries to target by model.</li> </ol>"},{"location":"hardware-support-apps-without-microsoft-store/#mdt-implementation","title":"MDT Implementation","text":""},{"location":"hardware-support-apps-without-microsoft-store/#winpe-features-requirements","title":"WinPE Features Requirements","text":"<ul> <li>.NET Framework</li> <li>Windows PowerShell</li> <li>DISM Cmdlets</li> </ul>"},{"location":"hardware-support-apps-without-microsoft-store/#application","title":"Application","text":"<ol> <li>Download and extract the required HSA package from Lenovo's website.</li> <li>Copy the Install-HSA.ps1 script to the directory where the HSA package was extracted.</li> <li>Create an application in MDT.  We will use this to neatly store the files in MDT.  When the wizard asks for executable, you can put anything, as we will not be using the application functionality to install the HSA.</li> </ol> <p>Note</p> <p>If you are going to install more than one HSA, but not all, and are going to use the -FILE parameter, be sure to include the text file with the list of HSA Names in the same directory as the script file.</p>"},{"location":"hardware-support-apps-without-microsoft-store/#mdt-task-sequence","title":"MDT Task Sequence","text":"<ol> <li>In the Task Sequence, after the Apply Operating System task in the Install phase, but before the Restart Computer task in the PostInstall phase, add a Run Command Line task and give it a name.</li> <li>In the command line, enter the following command: <pre><code>powershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass -Command \"Copy-Item '%DeployRoot%\\Applications\\{ApplicationFolderNameHere}' -Destination %OSDisk%\\OSDTemp\\ -Recurse; %OSDisk%\\OSDTemp\\Install-HSA.ps1 -OFFLINE -ALL -DEBUGINFORMATION; Remove-Item %OSDisk%\\OSDTemp -Recurse -Force\"\n</code></pre> The command above will copy all files and folders from the Application folder defined, execute the Install-HSA.ps1 script, and remove the content from the %OSDisk% drive.</li> <li>Be sure to change {ApplicationFolderNameHere} to the actual folder name of the Application.</li> <li>On the Options tab, if needed, add the conditional statement and any WMI queries to target by model.</li> </ol>"},{"location":"hardware-support-apps-without-microsoft-store/#noteworthy","title":"Noteworthy","text":"<ul> <li>Not Applicable HSAs - Even though an HSA is in a Lenovo supplied HSA pack, that does not necessarily mean it will apply to every build of a model.  For example:</li> <li>On the ThinkPad T15 Gen 1, not all builds of this model will have an Nvidia Graphics Card, so the Nvidia Graphics HSA may or may not be needed.</li> <li>Many models have an option to utilize Intel Optane Storage.  The HSA is only needed if the device contains the Optane disk drive.</li> <li>HSAs not installing as SYSTEM account - In an MEM/SCCM Task Sequence, after the Setup Windows and Configuration Manager task, the task sequence runs as the SYSTEM account.  Many HSAs will not install under the SYSTEM account, so we recommend installing in WinPE.</li> </ul>"},{"location":"deploying-the-intel-processor-power-management-package/","title":"Deploying the Intel Processor Power Management Package","text":"<p>The Intel Processor Power Management (PPM) package is now available on the Lenovo support site. This will install a provisioning package on a supported system to tune power mode settings across AC/DC (Best Power Efficiency, Balanced, Best Performance). These power settings can help avoid running the system at higher temperatures which could throttle the CPU.</p> <p>This article covers how to deploy the package using Microsoft Intune.</p> <p>Note</p> <p>This package is not available in the System Update/Commercial Vantage catalog.</p>"},{"location":"deploying-the-intel-processor-power-management-package/#creating-the-win32-app","title":"Creating the Win32 App","text":"<p>Download the already-made .intunewin file and detection script from my GitHub</p> <p>https://github.com/philjorgensen/Intune/tree/main/Win32%20Apps/Intel_PPM</p> <p>Login to the Intune admin center to create a new Win32 app.</p> <p>Select the Invoke-IntelPPMPackage.intunewin app package file to upload. Fill out the required fields and any other data on the App information page.</p> <p>On the Program page, we'll need to enter the install/uninstall commands.</p> <p>Install Command</p> <pre><code>powershell.exe -ExecutionPolicy Bypass -File .\\Invoke-IntelPPMPackage.ps1\n</code></pre> <p>Uninstall Command <pre><code>powershell.exe -ExecutionPolicy Bypass -Command \"Uninstall-ProvisioningPackage -AllInstalledPackages | Where-Object { $_.PackagePath.IndexOf('PPM') -ne -1 }\"\n</code></pre></p> <p>Set the device restart behavior to Determine behavior based on return codes.</p> <p>Change the 0 return code from Success to Soft Reboot and add 2 additional return codes:</p> <ul> <li>1 = Failed</li> <li>2 = Success</li> </ul> <p></p> <p>Select 64-bit for the operating system architecture and Windows 11 22H2 as the minimum operating system on the Requirements page.</p> <p>Choose Use a custom detection script as the rule and specify the Detect-IntelPPMPackage.ps1.</p> <p>There's no dependencies or supersedence that we need to configure so continue on to create the app. It</p>"},{"location":"deploying-the-intel-processor-power-management-package/#assigning-the-app","title":"Assigning the App","text":"<p>While the logic in the install script determines if the system is applicable for one of these packages, you should at least assign the app to a device group containing Lenovo systems.</p>"},{"location":"deploying-the-intel-processor-power-management-package/#experience","title":"Experience","text":"<p>Since we configured additional return codes, the system should receive a toast notification informing of a restart to complete the installation.</p> <p></p> <p>You can run the following PowerShell command to check the installed PPM provisioning package</p> <pre><code>Get-ProvisioningPackage -AllInstalledPackages | Where-Object {$_.PackagePath.IndexOf(\"PPM\")}\n</code></pre>"},{"location":"introducing-lenovo-client-scripting-module-200/","title":"Introducing: Lenovo Client Scripting Module 2.0.0","text":"<p>Update June 12, 2025: Version 2.3.0 is now available in the PowerShell Gallery!</p> <p>Back in January of 2024 we introduced the Lenovo Device Management Module. Today we are replacing it with the new Lenovo.Client.Scripting Module which is a PowerShell module that provides several useful cmdlets for making it easier to manage Lenovo commercial PCs. The module supports Lenovo's commercial portfolio of ThinkPad, ThinkCentre and ThinkStation products.</p>"},{"location":"introducing-lenovo-client-scripting-module-200/#why-the-name-change","title":"Why the name change?","text":"<p>Some of you may be aware of another Lenovo product called Lenovo Device Manager.  This is a cloud-based management solution that we are continually enhancing to provide unique management capabilities for our commercial PCs as well as other devices like tablets and phones. This product is often referred to as LDM which started to be confused with LDMM, which is completely unrelated.</p> <p>We also have plans to update some of our other PowerShell-based tools to fit under the same \"Lenovo.Client\" naming convention. More to come on that in the near future.</p> <p>You can learn all about PowerShell modules here: About Modules</p> <p>You can also find a complete reference for each of the available cmdlets in the module here:  Lenovo.Client.Scripting Module</p>"},{"location":"introducing-lenovo-client-scripting-module-200/#installing-lenovoclientscripting-module","title":"Installing Lenovo.Client.Scripting Module","text":"<p>The module itself is currently available for download here: Lenovo.Client.Scripting.zip</p> <p>The module is also published in the PowerShell Gallery so it can easily be installed with the Install-Module command. To install from the PowerShell Gallery, simply run</p> <pre><code>Install-Module -Name Lenovo.Client.Scripting -Force\n</code></pre> <p>The zip file contains the module folder, Lenovo.Client.Scripting, which contains the Lenovo.Client.Scripting.psm1 and Lenovo.Client.Scripting.psd1 files plus the Public and Private sub-folders containing individual PowerShell scripts for the various functions. To manually install the module, there are two locations that the module folder can be copied to:</p> <ol> <li>Per User: %UserProfile%\\Documents\\WindowsPowerShell\\Modules</li> <li>All Users: %ProgramFiles%\\WindowsPowerShell\\Modules</li> </ol> <p>If you have the LnvDeviceManagement module installed already, we recommend you remove that module first.  The Lenovo.Client.Scripting module uses the same GUID with a higher version so it should supersede the earlier LDMM; however, it would be cleaner to remove LDMM first.</p> <pre><code>PS C:\\&gt; Remove-Module LnvDeviceManagement\n</code></pre> <p>To install the Lenovo.Client.Scripting module so that it is loaded into your PowerShell session, you need to call Import-Module first:</p> <pre><code>PS C:\\&gt; Import-Module Lenovo.Client.Scripting -Force\n</code></pre> <p>Then you can verify it is installed using the Get-Module command:</p> <pre><code>PS C:\\&gt; Get-Module Lenovo.Client.Scripting\n\nModuleType Version    Name                                ExportedCommands\n---------- -------    ----                                ----------------\nScript     2.0.0      Lenovo.Client.Scripting             {Add-LnvSUCommandLine, Add-LnvSULogging, Export-LnvUpdateR...\n</code></pre>"},{"location":"introducing-lenovo-client-scripting-module-200/#using-the-lenovoclientscripting-module","title":"Using the Lenovo.Client.Scripting Module","text":"<p>All of the cmdlets from the Lenovo Device Management module are still present. A couple of new cmdlets have been added for which you can find details at Lenovo.Client.Scripting Reference Guide. Let's see what a few of the cmdlets can do for us.</p> <p>Many of the cmdlets require Internet access to provide data. Some may require running as Administrator.</p>"},{"location":"introducing-lenovo-client-scripting-module-200/#get-lnvcve","title":"Get-LnvCVE","text":"<p>This cmdlet returns a list of the CVE identifiers that are listed as addressed vulnerabilities in the current BIOS update for the specified system. Only BIOS updates are covered by this cmdlet. A machine type can be passed as a parameter.  If no parameter is specified, the machine type of the running system will be used. CVE Data may not be available for all machine types.</p> <pre><code>PS C:\\&gt; Get-LnvCVE -MachineType 21DD\nCVE-2023-31100\nCVE-2022-4304\nCVE-2022-40982\nCVE-2023-28005\nCVE-2022-36763\nCVE-2022-36764\nCVE-2022-36765\nCVE-2022-27635\nCVE-2022-40964\nCVE-2022-36351\nCVE-2022-38076\nCVE-2021-42299\nCVE-2021-38578\nCVE-2022-48189\nCVE-2022-34301\nCVE-2022-34302\nCVE-2022-34303\nPS C:\\&gt;\n</code></pre>"},{"location":"introducing-lenovo-client-scripting-module-200/#find-lnvmachinetype","title":"Find-LnvMachineType","text":"<p>But what if you don't know the machine type of a particular model? You can use this cmdlet to the possible machine types based on the friendly model name. Specify less detail in the model name if you are not finding the results you are looking for. This will increase the chance of a string match and will return more results. In some cases you may see multiple machine types for the same model. Some of these may be Intel vs. AMD models. If you are creating a script to run on a device and just need the machine type of that device, you can use the Get-LnvMachineType  (see below).</p> <pre><code>PS C:\\&gt; Find-LnvMachineType -ModelName 'ThinkPad L15 Gen 4'\nThinkPad L15 Gen 4 Type 21H3 21H4 = 21H3\nThinkPad L15 Gen 4 Type 21H3 21H4 = 21H4\nThinkPad L15 Gen 4 Type 21H7 21H8 = 21H7\nThinkPad L15 Gen 4 Type 21H7 21H8 = 21H8\nPS C:\\&gt;\n</code></pre>"},{"location":"introducing-lenovo-client-scripting-module-200/#get-lnvavailablebiosversion","title":"Get-LnvAvailableBiosVersion","text":"<p>If you specify a machine type, the cmdlet will return the version of the  currently available BIOS update. If no machine type is specified, the cmdlet will use the running system's machine type and will compare the version of the currently available update to the version of the system and return an alert if the update is newer. The <code>-Download</code> switch can be used to trigger the download of the current update in either case and it will be stored in the current working directory.</p> <pre><code>PS C:\\&gt; Get-LnvAvailableBiosVersion -MachineType 21EY\nCurrent available version: 1.08\nPS C:\\&gt; Get-LnvAvailableBiosVersion -MachineType 21EY -Download                                                                               Current available version: 1.08                                                                                                               PS C:\\&gt; ls\n\n\n    Directory: C:\\\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\nd-----         11/2/2023   3:11 PM                0.0.5\nd-----         9/30/2023  11:53 AM                EFI\nd-----          5/7/2022   1:13 AM                PerfLogs\nd-r---        10/24/2023   1:31 AM                Program Files\nd-r---          5/7/2022   1:19 AM                Program Files (x86)\nd-----          5/7/2022   1:17 AM                sources\nd-r---        10/24/2023   1:30 AM                Users\nd-----         11/2/2023   3:14 PM                Windows\n-a----         11/2/2023   4:24 PM       17188096 n3ouj04w.exe\n-a----         11/2/2023   4:13 PM          38031 taxonomy.txt\n\n\nPS C:\\&gt;\n</code></pre>"},{"location":"introducing-lenovo-client-scripting-module-200/#get-lnvdriverpack","title":"Get-LnvDriverPack","text":"<p>This cmdlet will download the SCCM Driver Pack based on the specified machine type, OS and OS build version. Tab completion can be used to select the OS build version in the correct format. The cmdlet will leverage the default browser for downloading the pack so the user can select the location to save the file to.</p> <pre><code>PS C:\\&gt; Get-LnvDriverPack -MachineType 21EY -WindowsVersion 11 -OSBuildVersion 22H2\n</code></pre>"},{"location":"introducing-lenovo-client-scripting-module-200/#lenovo-device-data","title":"Lenovo Device Data","text":"<p>Sometimes you may be writing a script that needs to make use of a certain data element and you cannot easily remember the WMI query needed to get the value you are looking for.  There are several cmdlets that makes this task much easier.</p> <pre><code>PS C:\\&gt; Get-LnvMachineType\n21DD\n\nPS C:\\&gt; Get-LnvModelName\nThinkPad P1 Gen 5\n\nPS C:\\&gt; Get-LnvProductNumber\n21DDZA2EUS\n\nPS C:\\&gt; Get-LnvSerial\n8675309\nPS C:\\&gt;\n</code></pre>"},{"location":"introducing-lenovo-client-scripting-module-200/#get-lnvupdatesrepo","title":"Get-LnvUpdatesRepo","text":"<p>For instances where Update Retriever cannot be used to create the local repository or where full automation of the repository creation is desired, this cmdlet can be used instead. It can be customized and executed on a regular basis to get the latest update packages. This cmdlet is based on the PowerShell script that was documented in this blog article: Create Local Repository Using PowerShell</p> <p>One of the parameters of this cmdlet, -RT5toRT3, will generate a repository where the Reboot Type 5 updates are changed to Reboot Type 3 which modifies the XML Package Descriptor. A repository created this way with modified XML package descriptors will require you to use Thin Installer to process the updates in the repository. Commercial Vantage and Lenovo System Update will not recognize the modified updates.</p> <pre><code>PS C:\\&gt; Get-LnvUpdatesRepo -MachineTypes 21EY -WindowsVersion 11 -PackageTypes 3 -RebootTypes 5 -RepositoryPath c:\\21EY\n\nPS C:\\&gt;\n</code></pre>"},{"location":"introducing-lenovo-client-scripting-module-200/#see-them-all","title":"See Them All","text":"<p>There are currently 27 cmdlets included in the module and more will be added over time. To see the complete list and all the details for running each one of them, visit the reference guide here.</p>"},{"location":"introducing-lenovo-device-management-module/","title":"Introducing: Lenovo Device Management Module","text":"<p>Superseded</p> <p>This module has been superseded by the Lenovo Client Scripting Module. See this article.</p>"},{"location":"introducing-su-helper-utility/","title":"Introducing: SU Helper Utility","text":"<p>The SU Helper Utility provides a command-line interface for triggering the System Update process of Commercial Vantage. This seperate utility is not included with Commercial Vantage and must also be deployed to clients where it is needed. Let's see some of the things we can do with this utility.</p> <p>You can view the reference for the tool here: SU Helper Reference</p>"},{"location":"introducing-su-helper-utility/#installing-su-helper","title":"Installing SU Helper","text":""},{"location":"introducing-su-helper-utility/#use-cases-for-su-helper","title":"Use Cases for SU Helper","text":"<p>Note</p> <p>When using SU Helper, you must always specify the \"-autoupdate\" parameter first. The only exception to this is when using \"-help\" to get a reference to the possible parameters at the command line.</p>"},{"location":"introducing-su-helper-utility/#trigger-an-autoupdate-session","title":"Trigger an Autoupdate Session","text":"<p>The simplest function of SU Helper would be to just trigger an Autoupdate session to run on demand. Since Commercial Vantage is architected as a UWP application instead of a standard Win32 applciation, this as previously been difficult to do. Now with SU Helper you can simply run:</p> <p><code>suhelper.exe -autoupdate</code></p>"},{"location":"introducing-su-helper-utility/#filtering-updates","title":"Filtering Updates","text":"<p>Let's consider a case where you may want to trigger an Autoupdate session to only update the BIOS if needed. With SU Helper you can simply run:</p> <p><code>suhelper.exe -autoupdate -packagetype 3</code></p> <p>Package type numbers must be from the following list:</p> <pre><code>{0} : Others\n{1} : Application\n{2} : Driver\n{3} : Bios\n{4} : Firmware\n</code></pre>"},{"location":"introducing-su-helper-utility/#install-a-specific-update","title":"Install a Specific Update","text":"<p>There may be a case where a particular update needs to be installed immediately, outside of the normal schedule for updates. With SU Helper you can specify the Package ID for one or more updates that are required to be installed and only these updates will be applied during the Autoupdate session initiated.</p> <p><code>suhelper.exe -autoupdate -include n47uj02w</code></p> <p>When the Autoupdate session is triggered, the catalog of available updates is searched for the specified Package ID. If that package is not in the catalog, or if the package has already been installed, the Autoupdate session will simply end. Only if the update is applicable and listed in the catalog will it be installed.</p> <p>You can easily find the package IDs for updates by either using Update Retriever or the Driver &amp; Software Matrix for IT Admins. The latter has been updated to provide checkboxes in the list of search results so that one or more updates can be selected, then clicking the Copy Package ID(s) button will copy a string to the clipboard consisting of the selected Package IDs separated by a comma. This string can be used after the -include parameter in the command line.</p>"},{"location":"introducing-su-helper-utility/#exclude-a-specific-update-from-being-installed","title":"Exclude a Specific Update From Being Installed","text":"<p>In some cases, you may encounter an update that is not compatible with something else in your environment and you may want your devices running Commercial Vantage to ignore this particular update. This can be accomplished by running:</p> <p><code>suhelper.exe -autoupdate -exclude n47uj02w</code></p> <p>This will add the specified Package ID to a list of excluded packages on the device. When any subsequent Autoupdate sessions or even manual Check for Updates sessions are run, the updates listed in the exclude list will be ignored. If the update becomes required again, it can be removed from the excluded list and installed by using the \"-include\" parameter with the Package ID.</p>"},{"location":"introducing-su-helper-utility/#closing","title":"Closing","text":"<p>To get the full details of all the parameters and their usage, please be sure to check out the SU Helper Reference guide.</p>"},{"location":"setting-an-asset-tag-on-thinkpads-using-intune-proactive-remediations/","title":"Setting an Asset Tag on ThinkPads using Intune Proactive Remediations","text":"<p>For the unaware, Lenovo provides a Windows Utility to Read and Write Asset ID Information, specifically for ThinkPad. With this utility, you are able to set asset ID data such as an Owner Name, Owner Location, Asset Number and several other pieces of information.</p> <p>Refer to the ReadMe for all available group names and their associated fields, as well as supported models.</p> <p>The USERASSETDATA.ASSET_NUMBER is available through WMI by querying the SMBIOSAssetTag field of the Win32_SystemEnclosure class.</p> <p>This solution will focus on setting:</p> <ul> <li>Asset Tag</li> <li>Owner Name</li> <li>Department</li> <li>Location</li> </ul>"},{"location":"setting-an-asset-tag-on-thinkpads-using-intune-proactive-remediations/#intune-requirements","title":"Intune Requirements","text":"<p>Device must be enrolled into Endpoint Analytics</p> <p>Valid licenses for enrolled devices to use Microsoft Endpoint Manager.</p> <ul> <li>Intune Licensing</li> <li>ConfigMgr Licensing</li> </ul>"},{"location":"setting-an-asset-tag-on-thinkpads-using-intune-proactive-remediations/#proactive-remediations","title":"Proactive Remediations","text":"<p>Detection/Remediation scripts can be downloaded on my GitHub</p> <p>Sign-in to the Microsoft Endpoint Manager admin center and navigate to Reports &gt; Endpoint Analytics &gt; Proactive Remediations</p> <p>Click Create new script package. Provide a Name and description (if necessary)</p> <p></p> <p>On the Settings section, upload both the Detection script file and the Remediation script file by browsing to the location where the .ps1 files were saved.</p> <p>Configure the option to Run script in 64-bit PowerShell to Yes</p> <p></p> <p>Assign any scope tags and a group to deploy the script package to. For testing purposes, I set the schedule to run every hour.</p> <p>A reboot is required before the tag is populated in WMI.</p>"},{"location":"setting-an-asset-tag-on-thinkpads-using-intune-proactive-remediations/#monitor-script-package","title":"Monitor script package","text":"<p>Check the overview of your detection and remediation status under Reporting &gt; Endpoint Analytics - Proactive remediations. Review the Device status to get details for each device.</p> <p></p> <p>Warning</p> <p>Remember to change the Owner Data variables in the remediation script. The USERASSETDATA.ASSET_NUMBER is based off the UniqueID of the device and is what I decided to use for this scenario.</p>"},{"location":"deploying-thinkpad-bios-updates-with-intune/","title":"Deploying ThinkPad BIOS Updates With Intune","text":"<p>This walk-through will cover deploying ThinkPad BIOS updates with Intune. These are provided as standalone executables so adding them as a Win32 app will involve converting them to the .intunewin format using the Win32 Content Prep Tool.</p>"},{"location":"deploying-thinkpad-bios-updates-with-intune/#app-conversion","title":"App Conversion","text":"<p>Create a working folder where the Win32 App Packaging Tool and BIOS packages will reside. Download the latest BIOS for your model system and save it to a working folder. In a PowerShell or Command Prompt, execute IntuneWinAppUtil.exe and follow the prompts to:</p> <ul> <li>Specify the source folder - This is the location where the BIOS package downloaded from the web is saved.</li> <li>Setup File - The BIOS package file name, i.e. n3juj15w.exe</li> <li>Output folder - Location where the converted app will drop.</li> </ul> <p>Once this information is entered, you will see the tool validate the package parameters, encrypt the content, and generate the detection XML file. You'll now have a new file in the .intunewin format, which will need to be uploaded to Intune.</p>"},{"location":"deploying-thinkpad-bios-updates-with-intune/#add-the-win32-app","title":"Add the Win32 App","text":"<p>Login to the Microsoft Intune admin center to add a new Windows app. Choose Windows app (Win32) as the app type.</p> <p></p> <p>Select the newly created .intunewin file to upload</p>"},{"location":"deploying-thinkpad-bios-updates-with-intune/#app-information","title":"App Information","text":"<p>Fill out the required app information and any optional fields.</p> <p></p>"},{"location":"deploying-thinkpad-bios-updates-with-intune/#program-information","title":"Program Information","text":"<p>On the Program page, this is where you'll specify the install/uninstall commands. ThinkPad BIOS updates are wrapped as Inno Setup packages that accept the /PARAM parameter and passes it to what is executed normally (Winuptp.exe -s). The uninstall command is required but in this case, not necessary since you can't uninstall a BIOS update.</p> <p>Install command</p> <pre><code>n3juj15w.exe /VERYSILENT /PARAM=\"-s\"\n</code></pre> <p>Change the device restart behavior to Intune will force a mandatory restart. This will unlock additional options when you assign the app.</p> <p>Leave the default return codes as-is. We'll need to add an additional code to verify a successful installation. Click +Add, set the value to 1 and select Soft Reboot for the code type.  For ThinkPad BIOS, a return code 1 indicates a successful BIOS update and no reboot (a silent install).  You can find a list of Winuptp return codes here.</p> <p></p>"},{"location":"deploying-thinkpad-bios-updates-with-intune/#requirements","title":"Requirements","text":"<p>For Requirements:</p> <ul> <li>Operating system architecture - 64-bit</li> <li>Minimum operating system - Windows 10 1607</li> </ul> <p>Take it a bit further and configure an additional requirement rule to serve as a model check.</p> <p>Requirement Type: Registry</p> <p>Key path:</p> <pre><code>HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS\n</code></pre> <p>Value name:</p> <pre><code>SystemFamily\n</code></pre> <p>Value:</p> <pre><code>ThinkPad P1 Gen 5\n</code></pre> <p></p>"},{"location":"deploying-thinkpad-bios-updates-with-intune/#detection-rules","title":"Detection rules","text":"<p>Detection Rules can be handled several different ways. In this example, I'm choosing to look at the BIOSVersion value in the registry. The value in the screenshot below is after installing the latest BIOS update for my test system. This is what will be evaluated at the time of install, so if the client has an older BIOS installed, it should evaluate as False and proceed with the install.</p> <p></p> <p>This detection method assumes a newer BIOS version is being deployed to a system on an older version. If you're attempting to deploy an older BIOS version, the rule will still evaluate as false and attempt to install the older version. If for some reason you're deploying an older BIOS version, make sure the Secure Rollback Prevention BIOS setting is disabled.</p> <p>Key path</p> <pre><code>HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS\n</code></pre> <p>Value name</p> <pre><code>BIOSVersion\n</code></pre> <p>Value: Note the extra space between the 3 and ).</p> <pre><code>N3JET37W (1.21 )\n</code></pre> <p>You can find the BIOS ID in the version release matrix on the support site.</p> <p></p> <p>Values will vary across models so you'll need to confirm this data in the registry.</p>"},{"location":"deploying-thinkpad-bios-updates-with-intune/#assign-the-app","title":"Assign the App","text":"<p>Target a group for app assignment. If you're going to deploy multiple BIOS updates to different models, it may be a good idea to create a dynamic device group or device filter for each model and deploy its own BIOS to that group. An example query would be:</p> <pre><code>(device.deviceModel -startsWith \"20DC\") -or (device.deviceModel -startsWith \"20DD\")\n</code></pre> <p>Since we configured Intune to force a mandatory restart, we can configure restart grace period options, such as notifying the user when the device will be restarted and a countdown timer leading up to the event.</p> <p></p>"},{"location":"deploying-thinkpad-bios-updates-with-intune/#client-side-experience","title":"Client Side Experience","text":"<p>Once the app has been assigned, open the Company Portal on the client (if deployed as available) and choose to install the newly delivered app. If the app is required, the user should be presented with Windows toast notifications stating the update has been installed and requires a restart to complete installation.</p> <p></p> <p>A restart countdown prompt will then be displayed before the machine is forced to restart.</p> <p></p>"},{"location":"deploying-thinkpad-bios-updates-with-intune/#monitor","title":"Monitor","text":"<p>You can trace the workflow in the IntuneManagementExtension.log located under C:\\ProgramData\\Microsoft\\IntuneManagementExtension\\Logs. Highlighted below is during the app detection step and installation using the install commands specified.</p> <p></p> <p></p> <p>The device installation status in Intune may show failed (app not detected after install) due to the fact that the system has not restarted. This will return as \"Installed\" once the device has restarted and checks back into the Intune service.</p> <p>Note</p> <p>If your laptops are encrypted with BitLocker, this needs to be taken into consideration. It's a best practice to suspend BitLocker prior to flashing the BIOS. ThinkPad BIOS has this check built into Winuptp so if the system is encrypted, Winuptp will suspend encryption behind the scenes before a reboot is triggered.</p>"},{"location":"changing-the-bios-supervisor-password-with-intune-and-the-think-bios-config-tool/","title":"Changing the BIOS Supervisor Password with Intune and the Think BIOS Config Tool","text":"<p>For security purposes, there may be a requirement to change the supervisor password for BIOS access. There are a few ways to accomplish this, either programmatically using a couple lines of code or with the Think BIOS Config Tool. The former would be easiest but does pose quite the risk by exposing your supervisor password in plain text, which is a big no-no. So instead, we're going to use the Think BIOS Config Tool and an encrypted password file to tackle this scenario, which has become quite common these days it seems.</p>"},{"location":"changing-the-bios-supervisor-password-with-intune-and-the-think-bios-config-tool/#solution-overview","title":"Solution Overview","text":"<p>This solution uses a PowerShell script to change the BIOS supervisor password by invoking the Think BIOS Config Tool, which passes a password file containing the encrypted supervisor password for authentication and password update.</p>"},{"location":"changing-the-bios-supervisor-password-with-intune-and-the-think-bios-config-tool/#preparing-the-password-file","title":"Preparing the Password File","text":"<p>First, download and extract the Think BIOS Config Tool, which can be found here.</p> <p>Note</p> <p>Ensure version 1.41 or higher of the tool is used</p> <p>Launch the tool as Admin and tick the box beside Supervisor password set on the target machine. This will unlock additional options.</p> <p></p> <p>Enter your current supervisor password in the Enter password field. In the Enter encrypting key field, either specify your own key (it can be anything you want) or click the Generate a key button to generate a random string. </p> <p></p> <p>Next, tick the box beside Change Supervisor password. This will unlock 2 extra fields where you specify the new supervisor password.</p> <p></p> <p>Finally, click the Create password change file button. This will generate an .ini file in the directory where the tool was invoked.</p> <p>Note</p> <p>Whenever you generate a password file, the name of the .ini will be the model of the machine it was generated from. You can rename it if you'd like.</p> <p></p> <p>If you open the .ini file, you'll see a long string on a single line. This is the encrypted password that will be used for BIOS authentication so you're not passing the \"real\" one in plain text.</p>"},{"location":"changing-the-bios-supervisor-password-with-intune-and-the-think-bios-config-tool/#preparing-the-win32-app","title":"Preparing the Win32 App","text":"<p>Copy the password file (.ini) and the Think BIOS Config Tool (.hta) to a new directory.</p> <p>Download the Update-SVP.ps1 file from my GitHub and save it to the directory containing the .hta and .ini.</p> <p>Warning</p> <p>Before proceeding, you'll need to populate the $secretKey variable with the encrypting key you used to generate the password file</p> <p>Using the Win32 Content Prep Tool, we're going to wrap these 3 items up and convert to an .intunewin file.</p> <p></p> <p>An example command to create the .intunewin file</p> <pre><code>IntuneWinAppUtil.exe -c \"C:\\IntuneWin32\\Source\\tbct\" -s Update-SVP.ps1 -o \"C:\\IntuneWin32\\\" -q\n</code></pre>"},{"location":"changing-the-bios-supervisor-password-with-intune-and-the-think-bios-config-tool/#creating-the-win32-app","title":"Creating the Win32 App","text":""},{"location":"changing-the-bios-supervisor-password-with-intune-and-the-think-bios-config-tool/#app-information","title":"App Information","text":"<p>Add a new Windows app (Win32) in the Intune admin center and choose the .intunewin app package file you just created to upload. Fill out the required fields and click next.</p> <p></p>"},{"location":"changing-the-bios-supervisor-password-with-intune-and-the-think-bios-config-tool/#program","title":"Program","text":"<p>Install command</p> <pre><code>powershell.exe -NoProfile -ExecutionPolicy Bypass -File .\\Update-SVP.ps1\n</code></pre> <p>Uninstall command</p> <pre><code>cmd.exe /c del %ProgramData%\\Lenovo\\ThinkBiosConfig\\svp.status /s /q\n</code></pre> <p>Change Device restart behavior to Determine behavior based on return codes.</p> <p></p>"},{"location":"changing-the-bios-supervisor-password-with-intune-and-the-think-bios-config-tool/#requirements","title":"Requirements","text":"<p>Operating system architecture: 64-bit</p> <p>Minimum operating system: 1607</p> <p>Add a new Registry requirement rule</p> <p>Key path: HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS</p> <p>Value name: SystemManufacturer</p> <p>Registry key requirement: String comparison</p> <p>Operator: Equals</p> <p>Value: LENOVO</p> <p></p>"},{"location":"changing-the-bios-supervisor-password-with-intune-and-the-think-bios-config-tool/#detection-rules","title":"Detection rules","text":"<p>Add a File rule type to check for a .status file</p> <p>Path: %ProgramData%\\Lenovo\\ThinkBiosConfig</p> <p>File or folder: .svp.status</p> <p>Detection method: File or folder exists</p> <p></p> <p>No dependencies or supersedence is required so click through and assign the app to a group of devices.</p>"},{"location":"changing-the-bios-supervisor-password-with-intune-and-the-think-bios-config-tool/#experience","title":"Experience","text":"<p>On a machine that's received the app assignment, a toast notification should be presented to complete a restart to finish the installation. This assumes a successful password change.</p> <p></p> <p>To verify this, look under C:\\ProgramData\\Lenovo\\ThinkBIOSConfig for a svp.status file. If you open the log file, you will see the tool found the password .ini file and successfully changed the password.</p> <p>Note</p> <p>The log file name will change by machine. It's prefixed with the Machine Type Model followed by Serial.</p> <p></p> <p>If the app installation failed, there can be a few scenarios that would cause this.</p> <ul> <li>No supervisor password is set on the target machine</li> <li>The encrypting key is incorrect</li> </ul> <p>On a failed machine, the log will show Access Denied for password change if either of the above scenarios are true.</p> <p>Warning</p> <p>If a device has failed consecutive installs with an incorrect encrypting key, a prompt stating \"Security password retry count exceeded\" will be presented on the next reboot.</p>"},{"location":"configure-bios-settings-through-intune-using-the-think-bios-config-tool/","title":"Configure BIOS Settings Through Intune using the Think BIOS Config Tool","text":"<p>There are numerous articles out in the community that walk through how to configure BIOS settings through Intune.  The majority of them being PowerShell solutions.  </p> <p>This post will provide an alternate method for configuring BIOS settings using our official Think BIOS Config HTA that was introduced back in 2016.  This solution can also be leveraged as part of an Autopilot deployment.</p> <p>Before proceeding, make sure you have an exported .ini file that contains the desired BIOS settings you want applied to your target systems.   Refer to the documentation provided in the TBCT zip on how to obtain this file.  For this demonstration, I've exported the following .ini from a T14s (Intel)</p> <p></p> <p>Since my target systems have a Supervisor password already set, the first line is the encrypted Supervisor password which was created using the specified secret key as part of the tool's capture process.  Note, there's no way to set an initial Supervisor password with this tool.</p>"},{"location":"configure-bios-settings-through-intune-using-the-think-bios-config-tool/#preparing-the-win32-app-source-files","title":"Preparing the Win32 App source files","text":"<p>Create a temporary directory and place the HTA, .ini file, and the following sample PowerShell script (save as a .ps1), which will be used to call the tool and apply the .ini.</p> <p>Note</p> <p>The $arg variable is critical as this holds the file and password switches.  You'll need to replace ThinkPadBiosConfig.ini to whatever you named your .ini file.  Replace secretkey to the encrypting key you specified during the capture process.</p> <pre><code>$tag = \"$($env:ProgramData)\\Lenovo\\ThinkBiosConfig\\ThinkBiosConfig.tag\"\n$arg = '\"file=ThinkPadBiosConfig.ini\" \"key=secretkey\"'\n$log = '\"log=%ProgramData%\\Lenovo\\ThinkBiosConfig\\\"\"'\n\ntry {\n    if (!(Test-Path -Path $tag -PathType Leaf)) {\n        Write-Host \"Creating TBCT directory...\"\n        New-Item -ItemType File -Path $tag -Force -ErrorAction Stop\n        Set-Content -Path $tag -Value \"Bios Settings Configured\"\n        Write-Host \"Tag file created...\"\n\n        Start-Process cmd.exe -ArgumentList \"/C ThinkBiosConfig.hta $arg $log\" -NoNewWindow -Wait\n        Write-Host \"Bios Settings Configured\"\n        Exit 3010\n    }\n    else {\n        Write-Host \"Bios Settings already configured...\"\n        Exit 0\n    }\n}\ncatch [System.IO.IOException] {\n    Write-Host \"$($_.Exception.Message)\"\n}\ncatch {\n    Write-Host \"$($_.Exception.Message)\"\n}\n</code></pre> <p>Your directory should have 3 items</p> <p></p>"},{"location":"configure-bios-settings-through-intune-using-the-think-bios-config-tool/#create-and-upload-the-win32-app","title":"Create and Upload the Win32 App","text":"<p>We're going to use the Win32 Content Prep tool to create an .intunewin file that will be uploaded to Intune.</p> <p></p> <p>Once the .intunewin file has been created, sign into the MEM admin center and create a new Windows client app.  Choose Windows app (Win32) for the app type and select the .intunewin package file to upload.</p> <p>Specify the App Information</p> <p></p> <p>Enter the Install command</p> <pre><code>powershell.exe -NoProfile -ExecutionPolicy Bypass -File .\\Set-BiosSettings.ps1\n</code></pre> <p>and Uninstall command</p> <pre><code>cmd.exe /c del %ProgramData%\\Lenovo\\ThinkBiosConfig\\ThinkBiosConfig.tag\n</code></pre> <p></p> <p>Set Operating system architecture to 64-bit and Minimum operating system to Windows 10 1607</p> <p>Add a Registry requirement type rule to check the target system is Lenovo (Optional)</p> <p>Key path: HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS</p> <p>Value name: SystemManufacturer</p> <p>Registry key requirement: String comparison</p> <p>Operator: Equals</p> <p>Value: LENOVO</p> <p></p> <p>Add a File type rule to check for the presence of the tag that gets created by the PowerShell script.  We'll use this for the detection method.</p> <p>Path: %ProgramData%\\Lenovo\\ThinkBiosConfig</p> <p>File or folder: ThinkBiosConfig</p> <p>Detection method: File or folder exists</p> <p></p> <p>Finally, Review + Save to create the new app and deploy to a Device Group.  </p> <p>On my test machine, I see toast notifications that show the BIOS has been configured and to reboot.</p> <p></p> <p>The tool generates a log file so here you can see my Supervisor password has been validated with the encrypting key and the settings have been applied successfully.</p> <p></p>"},{"location":"configure-bios-settings-through-intune-using-the-think-bios-config-tool/#additional-notes","title":"Additional Notes","text":"<ul> <li>You can combine settings across different products into a single .ini and apply them to all of your devices which use the same BIOS password (only one password can be specified per .ini file).  There may be a BIOS setting from one device with a value of Enabled whereas another device's value is Enable.  For example: LockBIOSSetting,Enable vs. LockBIOSSetting,Enabled If one doesn't apply to a device, it will simply skip it.</li> <li>If you choose to deploy this as a Required app for Autopilot devices, the dreaded reboot during ESP will occur, resulting in the extra user login.</li> </ul>"},{"location":"adding-model-friendly-name-to-intune-device-notes/","title":"Adding Model Friendly Name to Intune Device Notes","text":"<p>As of today, there's still a limitation within the Intune portal to easily find the friendly name of a Lenovo system, i.e. ThinkPad T14 Gen 3. Instead, you're left with the Machine Type Model (21AH).</p> <p>I'm sure there's a small group of people, if any, that have memorized what every MTM translates to for its respective friendly name.</p> <p>To make this a bit easier, and with the help of Damien Van Robaeys' blog post, we can use the Graph API to populate the device notes property of an Intune device by matching the Model (aka MTM) to its friendly name.</p> <p>The below code can be used to accomplish this. If there's currently a note set for a device, the friendly name will be appended on the next line of the note. You can also download from my GitHub here.</p> <p>This was tested in a small tenant so results may vary as far as time to completion goes.</p> <p>Info</p> <p>PowerShell 7 is recommended</p>"},{"location":"adding-model-friendly-name-to-intune-device-notes/#graph-powershell-sdk-cmdlets","title":"Graph PowerShell SDK cmdlets","text":"<p>This option uses the cmdlets from the Graph PowerShell SDK.</p> <pre><code>#requires -Module Microsoft.Graph.Authentication\n#requires -Module Microsoft.Graph.DeviceManagement\n\nDisconnect-Graph -ErrorAction SilentlyContinue\nConnect-MgGraph -Scopes DeviceManagementManagedDevices.ReadWrite.All, Directory.Read.All\n\n# No longer needed in Graph SDK V2\n# Select-MgProfile -Name beta\n\n# Filter for Lenovo devices\n$managedDevices = Get-MgDeviceManagementManagedDevice -Filter \"Manufacturer eq 'LENOVO'\"\n\n&lt;#\n\nVariables for MTM to Friendly Name\nhttps://github.com/damienvanrobaeys/Lenovo_Models_Reference/blob/main/MTM_to_FriendlyName.ps1\n\n#&gt;\n\n$URL = \"https://download.lenovo.com/luc/bios.txt#\"\n$Get_Web_Content = (Invoke-WebRequest -Uri $URL).Content\n$Models = $Get_Web_Content -split \"`r`n\"\n\nforeach ($device in $managedDevices)\n{\n\n    $deviceNotes = (Get-MgDeviceManagementManagedDevice -ManagedDeviceId $device.Id -Property \"Notes\").Notes\n    $Mtm = $device.Model.Substring(0, 4).Trim()\n    [string]$FamilyName = $(foreach ($Model in $Models)\n        {\n            if ($Model.Contains($Mtm))\n            {\n                if ($Model.Contains(\"Type\"))\n                {\n                    Write-Host $Model.Split(\"Type\")[0]\n                }\n                else\n                {\n                    $Model.Split(\"=\")[0]\n                }\n            }\n        }) | Sort-Object -Unique\n\n    if ([string]::IsNullOrEmpty($deviceNotes))\n    {\n\n        # Update Device notes\n        Update-MgDeviceManagementManagedDevice -ManagedDeviceId $device.Id -Notes $FamilyName\n\n    }\n    elseif ($deviceNotes -notmatch $FamilyName)\n    {\n\n        $appendDeviceNote = $deviceNotes + \"`n$FamilyName\"\n        Update-MgDeviceManagementManagedDevice -ManagedDeviceId $device.Id -Notes $appendDeviceNote\n    }\n}\n\n&lt;#\n\n# Output the results\nforeach ($device in $managedDevices) {\n    $deviceNotes = (Get-MgDeviceManagementManagedDevice -ManagedDeviceId $device.Id -Property \"Notes\").Notes\n    Write-Output -InputObject \"$($device.DeviceName) is a $($deviceNotes)\"\n}\n\n#&gt;\n</code></pre>"},{"location":"adding-model-friendly-name-to-intune-device-notes/#invoke-mggraphrequest","title":"Invoke-MgGraphRequest","text":"<p>This other option makes direct calls to the Graph API using Invoke-MgGraphRequest.</p> <pre><code>#requires -Module Microsoft.Graph.Authentication\n\nConnect-MgGraph -Scopes DeviceManagementManagedDevices.ReadWrite.All, Directory.Read.All\n\n# Define constants\n$endpoint = \"https://graph.microsoft.com\"\n$version = \"beta\"\n$resource = \"deviceManagement/managedDevices\"\n$query = \"?`$filter=manufacturer eq 'LENOVO'\"\n$query2 = \"?`$select=notes\"\n\n# Query managed Lenovo devices via Microsoft Graph API\n$devicesRequest = @{\n    Uri    = \"$($endpoint)/$($version)/$($resource)$($query)\"\n    Method = \"GET\"\n}\n\ntry\n{\n    $managedDevices = (Invoke-MgGraphRequest @devicesRequest).value\n}\ncatch\n{\n    Write-Error \"Failed to retrieve managed devices: $_.Exception.Message\"\n    return\n}\n\n&lt;#\nVariables for MTM to Friendly Name\nhttps://github.com/damienvanrobaeys/Lenovo_Models_Reference/blob/main/MTM_to_FriendlyName.ps1\n#&gt;\n$URL = \"https://download.lenovo.com/luc/bios.txt#\"\n$Get_Web_Content = (Invoke-WebRequest -Uri $URL).Content\n$Models = $Get_Web_Content -split \"`r`n\"\n\nforeach ($device in $managedDevices)\n{\n    $deviceDetailsRequest = @{\n        Uri    = \"$($endpoint)/$($version)/$($resource)/$($device.id)$($query2)\"\n        Method = \"GET\"\n    }\n\n    try\n    {\n        $deviceDetails = Invoke-MgGraphRequest @deviceDetailsRequest\n    }\n    catch\n    {\n        Write-Error \"Failed to retrieve device details for device ID $($device.id): $_.Exception.Message\"\n        continue\n    }\n\n    $deviceNotes = $deviceDetails.notes\n    $Mtm = if ($device.model.Length -ge 4) { $device.model.Substring(0, 4).Trim() } else { $device.model.Trim() }\n    [string]$FamilyName = $(foreach ($Model in $Models)\n        {\n            if ($Model.Contains($Mtm))\n            {\n                if ($Model.Contains(\"Type\"))\n                {\n                    $Model.Split(\"Type\")[0]\n                }\n                else\n                {\n                    $Model.Split(\"=\")[0]\n                }\n            }\n        }) | Sort-Object -Unique\n\n    $notesRequest = @{\n        Uri    = \"$($endpoint)/$($version)/$($resource)/$($device.id)\"\n        Method = \"PATCH\"\n    }\n\n    if ([string]::IsNullOrEmpty($deviceNotes))\n    {\n        # Update Device notes\n        $notesRequest.Body = (@{ notes = $FamilyName } | ConvertTo-Json -Compress)\n        try\n        {\n            Invoke-MgGraphRequest @notesRequest\n            Write-Host \"Updated notes for device ID $($device.id) to $($FamilyName)\"\n        }\n        catch\n        {\n            Write-Error \"Failed to update notes for device ID $($device.id): $_.Exception.Message\"\n        }\n    }\n    elseif ($deviceNotes -notmatch $FamilyName)\n    {\n        $appendDeviceNote = $deviceNotes + \"`n$FamilyName\"\n        $notesRequest.Body = (@{ notes = $appendDeviceNote } | ConvertTo-Json -Compress)\n        try\n        {\n            Invoke-MgGraphRequest @notesRequest\n            Write-Host \"Appended notes for device ID $($device.id) with $($FamilyName)\"\n        }\n        catch\n        {\n            Write-Error \"Failed to append notes for device ID $($device.id): $_.Exception.Message\"\n        }\n    }\n    else\n    {\n        Write-Host \"No update needed for device ID $($device.id)\"\n    }\n}\n</code></pre>"},{"location":"adding-model-friendly-name-to-intune-device-notes/#results","title":"Results","text":"<p>Once finished, check a device's notes in the portal to find it's friendly name.</p> <p></p> <p>If you used the Set-DeviceNoteFriendlyName_GraphAPI.ps1 script, you can see which devices got updated.</p> <p></p>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/","title":"Reporting on Update Status, BIOS Level, CVEs, and More","text":"<p>This post will walk through deploying a Remediation script that will collect data from specific Lenovo WMI classes using the HTTP Data Collector API. As a result, the data will be sent to a Log Analytics Workspace in Azure Monitor.</p> <p>Warning</p> <p>The HTTP Data Collector API will be deprecated on 2026/09/14</p> <p>We can then create an Azure Monitor Workbook to report on the following data from your Lenovo devices.</p> <p>This solution is not supported on ThinkBook</p>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/#update-installation-status","title":"Update Installation Status","text":"<p>Lists all updates by package ID and title with their respective install statuses</p> <p></p> <p></p> <p></p>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/#bios-level-and-cves","title":"BIOS Level and CVEs","text":"<p>Displays BIOS level information for each model and if the model is affected by any CVEs.</p> <p></p> <p></p>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/#battery-health-status","title":"Battery Health Status","text":"<p>Lists all endpoints and health of their battery.</p> <p></p>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/#warranty-end-date","title":"Warranty End Date","text":"<p>Lists the warranty end dates of all endpoints</p> <p></p>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/#prerequisites","title":"Prerequisites","text":"<p>The data gathered relies on Lenovo Commercial Vantage being installed on your endpoints.</p> <p>For a step by step guide on how to deploy Commercial Vantage through Intune, refer to this blog article.</p> <p>The following policies need to be enabled in order to create the WMI namespaces that will be inventoried, along with their respective classes</p> <ul> <li>Configure System Update</li> <li>Write warranty information to WMI table</li> <li>Write battery information to WMI table</li> </ul> <p>If these polices aren't enabled, the status will return as \"Unavailable\" in the workbook.</p>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/#required-files","title":"Required Files","text":"<ul> <li> <p>Get-LenovoDeviceStatus.ps1</p> </li> <li> <p>LenovoDeviceHealth.json</p> </li> </ul> <p>Download both files from our GitHub here.</p>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/#log-analytics-workspace","title":"Log Analytics Workspace","text":"<p>Assuming a Log Analytics Workspace has been created, you'll need the Workspace ID and Primary Key. This can be found under Agents management of your workspace.</p> <p></p>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/#deploying-the-remediation","title":"Deploying the Remediation","text":"<p>Once you have Commercial Vantage installed and the necessary policies enabled on your endpoints, it's time to deploy the Remediation script to collect inventory. The script will install the Lenovo Device Management Module on the endpoint to help gather certain data, such as Available BIOS versions and CVEs.</p> <p>Replace the $customerID and $sharedKey variables in the Get-LenovoDeviceStatus.ps1 script</p> <ul> <li>Login to the Microsoft Endpoint Manager admin center</li> <li>Navigate to Devices &gt; Scripts and remediations</li> <li>Click Create</li> <li>Enter a name for the script and click Next</li> <li>Browse to Get-LenovoDeviceStatus.ps1 for the Detection script file</li> <li>Select Yes to Run script in 64-bit PowerShell and click Next</li> <li>Assign to a group and set the schedule for the script package to run.</li> <li>Create</li> </ul> <p>As devices receive the policy, review the Device status blade to verify if devices don't have Commercial Vantage installed or the necessary policies enabled. You can review this by adding the Pre-remediation detection output column.</p>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/#reporting","title":"Reporting","text":"<p>You can check what data is being collected by looking at the Custom fields tab in Custom logs in your Workspace</p> <p></p> <p>Everything being inventoried here can be found on the device in the root/Lenovo WMI namespace under one of the following classes</p> <ul> <li>Lenovo_Updates</li> <li>Lenovo_Battery</li> <li>Lenovo_Warranty</li> </ul>"},{"location":"reporting-on-update-status-bios-level-cves-and-more/#adding-the-workbook","title":"Adding the Workbook","text":"<p>Add the sample Workbook to your Log Analytics Workspace</p> <ul> <li>Login to the Azure Portal</li> <li>Go to Log Analytics Workspace &gt; Workbooks</li> <li>Click +New</li> <li>Click the Advanced Editor button</li> </ul> <p></p> <ul> <li>Clear the contents and copy/paste the contents from Lenovo-DeviceStatus.json here</li> <li>Click Apply</li> </ul> <p>Happy reporting!</p>"},{"location":"lenovo-updates-catalog-v3-for-sccm/","title":"Lenovo Updates Catalog v3 for SCCM","text":"<p>The Lenovo Updates Catalog has been upgraded to the V3 format.  The catalog is still hosted at the same URL:</p> <p>https://download.lenovo.com/luc/v2/LenovoUpdatesCatalog2v2.cab</p> <p>The URL and file name did not change so as to avoid all subscribers having to change their subscription settings.  The V3 format simply adds some additional files that allow the updates in the catalog to be categorized.</p> <p>Previously when subscribing to the V2 catalog, all the updates in the catalog would automatically be published with meta data only.  Now with the V3 catalog, you can specify one or more categories to automatically publish instead of publishing all updates.  The categories in the Lenovo Updates Catalog are broken down into Model and Update Type (BIOS, driver, application).</p> <p>The categories can be selected when initially syncing the catalog or right-clicking on the catalog and selecting properties.</p> <p></p> <p></p> <p>Once categories are selected, the content can be staged which means it will be automatically downloaded to the top-level Software Update Point. This will remove the need to download the content through the Configuration Manager console prior to deployment.</p> <p></p>"},{"location":"lenovo-updates-catalog-v3-for-sccm/#summary","title":"Summary","text":"<p>With the introduction of the V3 format, you now have more granular control over what content from the catalog is published into your environment. With thousands of updates in a third-party catalog, this can make a big difference in the amount of data managed in your environment as well as the amount of processing your clients perform during their scan cycles.</p>"},{"location":"lenovo-updates-catalog-v3-for-sccm/#more-information","title":"More Information","text":"<p>https://docs.microsoft.com/en-us/mem/configmgr/sum/deploy-use/third-party-software-updates</p>"},{"location":"managing-system-update-with-intune/","title":"Managing System Update with Intune","text":"<p>This post will describe how you can manage Lenovo System Update on Windows 10/11 devices with Intune.</p> <p>Before you begin, you will need:</p> <ul> <li>System Update Administrator Tools - This contains the System Update ADMX/ADML files. By default, the contents are extracted to C:\\SWTOOLS\\TOOLS\\Admin</li> <li>A Windows 10 or 11 device connected to Azure Active Directory and managed by Intune</li> <li>System Update installed on the device</li> </ul>"},{"location":"managing-system-update-with-intune/#ingest-the-tvsu-admx-file","title":"Ingest the TVSU ADMX file","text":"<p>Sign in to the Microsoft Endpoint Manager admin center</p> <ul> <li>Navigate to Devices &gt; Windows &gt; Configuration Profiles &gt; Create Profile</li> <li>Select Windows 10 and later for Platform</li> <li>Select Templates for Profile type and choose the Custom template. Click Create</li> <li>Enter a name for the profile, for example, Lenovo System Update configuration</li> <li>Enter a description (Optional)</li> </ul> <p>In the Custom OMA-URI Settings menu, click Add and enter the following</p> <ul> <li>Name: TVSU ADMX Ingest</li> <li>Description: (Optional)</li> <li>OMA-URI:</li> </ul> <pre><code>./Device/Vendor/MSFT/Policy/ConfigOperations/ADMXInstall/Lenovo/Policy/TVSU\n</code></pre> <ul> <li>Data Type: String</li> <li>Value: Copy the contents of the tvsu.admx into this field</li> </ul> <p>Click save to complete adding the new OMA-URI row.</p> <p>Assign the profile to a group. This group should only include devices that have System Update installed.</p> <p>Verify the settings have pushed to a device by launching Regedit and navigating to HKLM\\SOFTWARE\\Microsoft\\PolicyManager\\AdmxDefault</p> <p></p>"},{"location":"managing-system-update-with-intune/#creating-a-tvsu-policy","title":"Creating a TVSU Policy","text":""},{"location":"managing-system-update-with-intune/#example-1","title":"Example 1","text":"<p>Repeat the steps above by adding an additional configuration setting. This example will be for setting the AdminCommandLine</p> <ul> <li>Name: Admin Command Line</li> <li>Description: Installs Critical and Recommended packages with a reboot type 3 (requires reboot)</li> <li>OMA-URI:</li> </ul> <pre><code>./Device/Vendor/MSFT/Policy/Config/Lenovo~Policy~Cat_ThinkVantage_61~Cat_System_Update_63~Cat_UserSettings_74~Cat_General_78/Policy_Admin_CommandLine_154\n</code></pre> <ul> <li>Data Type: String</li> <li>Value</li> </ul> <pre><code>&lt;enabled/&gt;\n&lt;data id=\"Policy_TextBox_Element_Admin_CommandLine_155\" value=\"/CM -search R -action INSTALL -includerebootpackages 3 -noicon -noreboot -nolicense\"/&gt;\n</code></pre> <p></p>"},{"location":"managing-system-update-with-intune/#example-2","title":"Example 2","text":"<p>This example will set custom repository paths</p> <ul> <li>Name: Repository Path</li> <li>Description: Optional</li> <li>OMA-URI:</li> </ul> <pre><code>./Device/Vendor/MSFT/Policy/Config/Lenovo~Policy~Cat_ThinkVantage_61~Cat_System_Update_63~Cat_UserSettings_74~Cat_General_78/Policy_Repository_Location_116\n</code></pre> <ul> <li> <p>Data Type: String</p> </li> <li> <p>Value</p> </li> </ul> <pre><code>&lt;enabled/&gt;\n&lt;data id=\"Policy_TextBox_Element_Repository_Location_119\" value=\"\\\\CustomRepoPath\"/&gt;\n&lt;data id=\"Policy_TextBox_Element_Repository_Location_120\" value=\"\\\\CustomRepoPath2\"/&gt;\n&lt;data id=\"Policy_TextBox_Element_Repository_Location_121\" value=\"\\\\CustomRepoPath3\"/&gt;\n</code></pre> <p></p> <p>Verify the policies have pushed down to the device by launching Regedit and navigating to HKLM\\SOFTWARE\\Policies\\Lenovo\\System Update\\UserSettings\\General</p> <p></p>"},{"location":"managing-system-update-with-intune/#further-reading","title":"Further Reading","text":"<p>Enable ADMX-backed policies in MDM</p> <p>Win32 and Desktop Bridge app policy</p>"},{"location":"mdt-no-longer-detects-enclosure-correctly/","title":"MDT No Longer Detects Enclosure Correctly","text":"<p>The SMBIOS Specification was updated again this year to add new enclosure type values that affect the IsDesktop, IsLaptop, and IsServer variables in MDT.  These variables are populated by ZTIGather.wsf.  To ensure your IsDesktop, IsLaptop, IsServer variables are accurate you should upgrade your MDT environment to version 8456.  If, for some reason, you cannot or should not update your MDT version, you can also easily update the ZTIGather.wsf script.</p> <p>Backup Script</p> <p>Please make a backup copy of ZTIGather.wsf prior to editing.</p> <p>Find the following lines of code:</p> <pre><code>    Select Case objInstance.ChassisTypes(0)\n        Case \"8\", \"9\", \"10\", \"11\", \"12\", \"14\", \"18\", \"21\"\n                bIsLaptop = true\n        Case \"3\", \"4\", \"5\", \"6\", \"7\", \"15\", \"16\"\n                bIsDesktop = true\n        Case \"23\"\n                bIsServer = true\n        Case Else\n                ' Do nothing\n    End Select\n</code></pre> <p>Replace the lines with:</p> <pre><code>    Select Case objInstance.ChassisTypes(0)\n        Case \"8\", \"9\", \"10\", \"11\", \"12\", \"14\", \"18\", \"21\", \"30\", \"31\", \"32\"\n                bIsLaptop = true\n        Case \"3\", \"4\", \"5\", \"6\", \"7\", \"13\", \"15\", \"16\", \"35\", \"36\"\n                bIsDesktop = true\n        Case \"23\", \"28\"\n                bIsServer = true\n        Case Else\n                ' Do nothing\n    End Select\n</code></pre> <p>The table from the current (as of the date of this writing) SMBIOS specification for your reference:</p> <p></p>"},{"location":"lenovo-model-information-in-mdt/","title":"Lenovo Model Information in MDT","text":"<p>When using Microsoft Deployment Toolkit (MDT), the ZTIGather.wsf script will pull important information MDT needs and place it into variables for usage during a task sequence.   The %Model% variable is a key piece of information during task sequences especially for targeting software and drivers.A popular example of the %Model% variable usage is the Total Control method of driver organization and injection by Johan Arwidmark.</p>"},{"location":"lenovo-model-information-in-mdt/#problem","title":"Problem","text":"<p>Currently, when the model information is pulled from a Lenovo system, it will display the Lenovo Machine Type Model (MTM) in the Model variable as 20MD001YUS or 20MD003YUS, for example.  When using the MTM, the Out-of-Box Drivers library of model folders in MDT can quickly grow and become nearly repetitive.  The growth can become a management burden when attempting to maintain drivers, as each folder beginning with 20MD, for example, would have the same set of drivers in it.</p>"},{"location":"lenovo-model-information-in-mdt/#resolution","title":"Resolution","text":"<p>To enable better management, we can edit the ZTIGather.wsf script to change where it pulls the model information on Lenovo computers.  The script change will set the %Model% variable to the friendly name from WMI, such as ThinkPad P1.</p> <p>Backup Script</p> <p>Please make a backup copy of ZTIGather.wsf prior to editing.</p> <p>In the ZTIGather.wsf, we are going to add a bit of logic to detect if the Make is Lenovo and act accordingly to set the model information.</p> <p>ZTIGather.wsf</p> <pre><code>' Get the make, model, and memory from the Win32_ComputerSystem class\n\nSet objResults = objWMI.InstancesOf(\"Win32_ComputerSystem\")\nFor each objInstance in objResults\n    If not IsNull(objInstance.Manufacturer) then\n        sMake = Trim(objInstance.Manufacturer)\n    End if\n    If sMake &lt;&gt; \"LENOVO\" Then\n        If not IsNull(objInstance.Model) then\n            sModel = Trim(objInstance.Model)\n        End if\n    End if\n    If not IsNull(objInstance.TotalPhysicalMemory) then\n        sMemory = Trim(Int(objInstance.TotalPhysicalMemory / 1024 / 1024))\n    End if\nNext\nIf sMake = \"\" then\n    oLogging.CreateEntry \"Unable to determine make via WMI.\", LogTypeInfo\nEnd if\nIf sMake &lt;&gt; \"LENOVO\" Then\n    If sModel = \"\" then\n        oLogging.CreateEntry \"Unable to determine model via WMI.\", LogTypeInfo\n    End if\nEnd If\n\n' Get the UUID from the Win32_ComputerSystemProduct class\nSet objResults = objWMI.InstancesOf(\"Win32_ComputerSystemProduct\")\nFor each objInstance in objResults\n    If not IsNull(objInstance.UUID) then\n        sUUID = Trim(objInstance.UUID)\n    End if\n    If sMake = \"LENOVO\" Then\n        If not IsNull(objInstance.Version) then\n            sModel = Trim(objInstance.Version)\n        End if\n    End if\nNext\nIf sUUID = \"\" then\n    oLogging.CreateEntry \"Unable to determine UUID via WMI.\", LogTypeInfo\nEnd if\n\nIf sMake = \"LENOVO\" Then\n    If sModel = \"\" then\n        oLogging.CreateEntry \"Unable to determine model via WMI.\", LogTypeInfo\n    End if\nEnd if\n</code></pre> <p>While on the topic of model information and injecting drivers, there is an additional change to ensure that only the drivers for the model being deployed are applied.  While testing driver packs, we have found an instance where the incorrect driver folder may be used.  This is caused by one model name being an exact substring of a second model.  An example would be ThinkPad P1 and ThinkPad P1 Gen 2.  They both contain ThinkPad P1.</p> <p>For this to be an issue, Out-of-Box Drivers repository would need to be alphabetized, ThinkPad P1 would need to be above ThinkPad P1 Gen 2 in the list of folders. When the DriverGroup001 variable is set to %Make%\\%Model%, the ZTIConfigFile.vbs searches for the matching Out-of-Box Drivers folder structure to apply to the variable.  By default, the script applies the last found instance.  This means, in the above example, when deploying a Lenovo ThinkPad P1, the script will find Lenovo\\ThinkPad P1 Gen 2 and assign it to the DriverGroup001 variable.  What needs to happen is for there to be an exact match.</p> <p>In the ZTIConfigFile.vbs, there is one line of code to edit.  Editing this line of code will allow the script to precisely define the Out-Of-Box Drivers subfolder(s) when reading the DriverGroup001 variable.</p> <p>Backup Script</p> <p>Please make a backup copy of ZTIConfigFile.vbs prior to editing.</p> <p>ZTIConfigFile.vbs</p> <p>Change the following line of vbscript code from <pre><code>If InStr(1,sName &amp; \"\\\", oGroupItem, vbTextCompare ) &lt;&gt; 0 then\n</code></pre> to <pre><code>If InStr(1,sName &amp; \"\\\", oGroupItem, vbTextCompare ) &lt;&gt; 0 AND (LEN(sName) = LEN(oGroupItem)) then\n</code></pre></p> <p>The original line of code performs a compare to find if the DriverGroup001 variable matches any subfolders.  The issue in this line of code is that if the deployed model is a ThinkPad P1, but we have subfolders for the ThinkPad P1 and ThinkPad P1 Gen 2, the search will find both but use the last match.  If the DriverGroups.xml is organized alphabetically, then the last subfolder found in this example is the ThinkPad P1 Gen 2.  Since the example deployment was for a ThinkPad P1, this will result in the incorrect set of drivers being applied to the device.</p> <p>The edited line of code retains the original search for the text from DriverGroup001, but now checks that the length of the DriverGroup001 variable is the same as the Out-Of-Box Drivers subgroup name being queried.  The result of the new line of code is that only the group being searched for will be used.</p>"},{"location":"introducing-lenovo-odometer/","title":"Introducing Lenovo Odometer","text":"<p>In some previous articles we have highlighted how you can collect Lenovo Updates History from a new WMI class in the root\\Lenovo namespace. See https://thinkdeploy.blogspot.com/2018/10/tracking-thininstaller-update-history.html</p> <p>We are now adding a new class under this namespace for the new \"Odometer\" feature found in the latest ThinkPads that were recently launched.  This feature keeps track of several metrics that can provide an indication of how a system has been used.  The metrics collected are:</p> <ul> <li>CPU Uptime - amount of time CPU has been active (in S0 state), counted in hours</li> <li>Shock events - based on detections from accelerometer where a delta reading of 1.75G(1.75m/s<sup>2</sup>) is detected</li> <li>Thermal events - registered high-temp conditions where CPU was throttled</li> <li>Battery cycles - number of charge cycles performed on battery</li> <li>SSD Read/Writes - number of block reads and writes on one or more internal SSDs</li> </ul> <p>These counters are maintained by the Embedded Controller and the current values are exposed each time the system boots using SMBIOS Table data. In order to have this data stored in a meaningful way so it can be inventoried and collected by MEM Configuration Manager, we have created a PowerShell script (odometer.ps1, available from download link below) that can be implemented as either a scheduled task or used on demand to populate the Lenovo_Odometer class in WMI. </p> <p>Once you have run the PowerShell script on a system that supports Odometer you will be able to find the data in WMI as shown below:</p> <p></p> <p>As previously mentioned, you could also run the \"odometer.ps1\" using the very useful Run Scripts feature in the Config Manager console.  With that you will be able to get direct feedback from the device in the console as shown below:</p> <p></p> <p>The Config Manager hardware inventory can be extended to include the Lenovo_Odometer custom class using the \"odometer.mof\" file provide in the zip file linked below. In Config Manager you can import the file as a new Hardware Inventory Class in your Client Settings. For more information on extending hardware inventory, refer to the docs here: https://docs.microsoft.com/en-us/sccm/core/clients/manage/inventory/extend-hardware-inventory</p> <p>Once clients have reported inventory, you can create an SSRS report on the data that would like like the following:</p> <p></p>"},{"location":"introducing-lenovo-odometer/#supported-systems","title":"Supported Systems","text":"<ul> <li>ThinkPad P1 (Gen 3) / ThinkPad X1 Extreme (Gen 3)</li> <li>ThinkPad T14 (Intel/AMD)/ ThinkPad T14 Healthcare Edition / ThinkPad P14s</li> <li>ThinkPad T15 / ThinkPad P15s</li> <li>ThinkPad T14s (Intel/AMD)</li> <li>ThinkPad X13 (Intel/AMD)</li> <li>ThinkPad X13 Yoga</li> <li>ThinkPad X1 Carbon (8th gen)</li> <li>ThinkPad X1 Yoga (5th gen)</li> <li>ThinkPad P15v / ThinkPad T15p</li> <li>ThinkPad L14 (Intel)</li> <li>ThinkPad L15 (Intel)</li> <li>ThinkPad P15 / ThinkPad P15G</li> <li>ThinkPad P17</li> </ul> <p>Download .PS1 and .MOF files for this solution.</p>"},{"location":"correcting-the-qualcomm-x55-wwan-excessive-logging-issue/","title":"Correcting the Qualcomm X55 WWAN Excessive Logging Issue","text":""},{"location":"correcting-the-qualcomm-x55-wwan-excessive-logging-issue/#symptoms","title":"Symptoms","text":"<p>Continuously growing log files generated by the Qualcomm X55 WWAN service. These logs are located under %ProgramData%\\Qualcomm\u00ae Snapdragon\u2122 X55 5G Modem\\SVClog</p>"},{"location":"correcting-the-qualcomm-x55-wwan-excessive-logging-issue/#scenario","title":"Scenario","text":"<p>Installing the SCCM driver pack with ConfigMgr or MDT on systems that did not have the card installed would result in excessive logging issues.</p> <p>If the driver were to be upgraded by either System Update/Thin Installer/Commercial Vantage/Lenovo Patch, it would no longer be an issue. Systems that were upgraded were where the WWAN card was detected as installed. In this case, later versions of the driver would fix those systems.</p> <p>On systems that do NOT have the card installed, the above mentioned tools would never see the device and never update the driver.</p>"},{"location":"correcting-the-qualcomm-x55-wwan-excessive-logging-issue/#known-affected-models","title":"Known Affected Models","text":"<ul> <li>ThinkPad X1 Carbon Gen 9/10</li> <li>ThinkPad X1 Yoga Gen 6/7</li> <li>ThinkPad T14 Gen 2</li> <li>ThinkPad X13 Gen 2</li> <li>ThinkPad X1 Nano Gen 1</li> </ul>"},{"location":"correcting-the-qualcomm-x55-wwan-excessive-logging-issue/#solution","title":"Solution","text":"<p>One possible solution is to leverage a ConfigMgr Configuration Item/Baseline. The CI will include two script setting types consisting of detection/remediation scripts. These scripts will:</p> <ul> <li>Check if the logs are present and delete them if the WWAN card is not installed (detected by PnpId)</li> <li>Check if the Qualcomm Sim Service is running and to stop/disable the service</li> </ul> <p>Download the Configuration Baseline here</p>"},{"location":"correcting-the-qualcomm-x55-wwan-excessive-logging-issue/#script-type-settings","title":"Script Type Settings","text":"<p>Name - Detect Qualcomm WWAN Log</p> <p>Discovery Script</p> <pre><code>$QCD = Get-PnpDevice -InstanceID \"USB\\VID_0489&amp;PID_E0B1&amp;MI_02*\"\n\nIf ($Null -eq $QCD){ \n    $Path = Join-Path -Path ($env:ProgramData) -ChildPath \"Qualcomm\u00ae Snapdragon\u2122 X55 5G Modem\"\n    if (Test-Path -Path $Path) {\n        if (Get-ChildItem -Path $Path -Filter \"log*.txt\" -Recurse) {\n            return $true\n        }\n    }\n    else {\n        return $false\n    }\n}\nelse{\n    return $false\n}\n</code></pre> <p>Remediation Script</p> <pre><code>$Path = Join-Path -Path ($env:ProgramData) -ChildPath \"Qualcomm\u00ae Snapdragon\u2122 X55 5G Modem\"\nGet-ChildItem -Path $Path -Filter \"log*.txt\" -Recurse | Remove-Item -Force\n</code></pre> <p>Name - Detect SimService Status</p> <p>Discovery Script</p> <pre><code>If ((Get-Service -Name SimService).Status -eq \"Running\") { \n    return $true \n}\nElse { \n    return $false \n}\n</code></pre> <p>Remediation Script</p> <pre><code>$Service = Get-Service -Name SimService\nStop-Service -Name $Service.Name\nSet-Service -Name $Service.Name -StartupType Disabled\n</code></pre>"},{"location":"correcting-the-qualcomm-x55-wwan-excessive-logging-issue/#deploying-the-baseline","title":"Deploying the Baseline","text":"<p>When you're ready to deploy the baseline, be sure to tick the box to remediate noncompliant rules when supported.</p> <p></p>"},{"location":"correcting-the-qualcomm-x55-wwan-excessive-logging-issue/#monitoring","title":"Monitoring","text":"<p>In the console, navigate to the Monitoring workspace and select the Deployments node. Here, you can review the deployment status of the baseline.</p>"},{"location":"creating-local-repository-using-powershell/","title":"Creating Local Repository Using PowerShell","text":"<p>There are various scenarios where one might want to quickly generate a local repository of Lenovo updates that can be consumed by Thin Installer or System Update in a scripted manner. This article will describe a PowerShell script that can be leveraged to create a repository for a specified machine type and OS. A scenario where this script might be used will also be described.</p> <p>The script, Get-LnvUpdatesRepo.ps1, can be found in the CDRT Library repository on GitHub here. The parameters and switches used by the script are documented at the beginning of the script.</p> <p>The child task sequence described in the first scenario can be downloaded here.</p>"},{"location":"creating-local-repository-using-powershell/#scenario-1","title":"Scenario 1","text":"<p>In the first scenario, Thin Installer will be leveraged in a Microsoft Configuration Manager Operating System Deployment task sequence to apply any applicable updates available for the machine type of the targeted system. For this approach, a PowerShell script will be executed in a child task sequence to orchestrate the creation of the repository with the desired updates which can be customized based on Package Types and Reboot Types.</p>"},{"location":"creating-local-repository-using-powershell/#child-task-sequence-workflow","title":"Child Task Sequence Workflow","text":"<p>The child task sequence will be added after the Setup Windows and Configuration Manager step in your parent Operating System Deployment task sequence</p>"},{"location":"creating-local-repository-using-powershell/#preparing-thin-installer","title":"Preparing Thin Installer","text":"<p>The top level group Prepare Thin Installer queries the device to determine if it is a ThinkPad, ThinkCentre or ThinkStation commercial PC product. </p> <p>A WQL query is used to check if the Operating System build is 22H1 or earlier. If it is, then Thin Installer is installed as an Application in the 'Application' group:  </p> <p>Another WQL query is used to check if the Operating System build is 22H2 or later in the 'Winget' group. This group contains a step to install Thin Installer from the Winget repository. Windows 11 22H2 contains Winget automatically while earlier versions of Windows must install Winget from the Microsoft.DesktopAppInstaller package. If Winget is available in your environment on earlier OS builds, you can change the conditions on these groups and leverage the Winget install task instead. </p> <p>PowerShell script to install Thin Installer using Winget:</p> <pre><code># Function to install Thin Installer\nfunction Install-ThinInstaller\n{\n    $ErrorActionPreference = 'SilentlyContinue'\n\n    # Create folder for logging\n    $WinGet = \"$($env:ProgramData)\\WinGet\"\n    if (-not (Test-Path -Path $WinGet))\n    {\n        New-Item -ItemType Directory -Path $WinGet\n    }\n\n    # Select newest winget.exe file based on folder order and set it as winget variable\n    $wingetExe = Get-ChildItem -Path \"$($env:ProgramFiles)\\WindowsApps\" -Filter winget.exe -Recurse | Sort-Object -Property 'FullName' -Descending | Select-Object -First 1 -ExpandProperty FullName | Tee-Object -FilePath \"$WinGet\\Winget-file-found-from.log\"\n\n    Write-Output \"Thin Installer not present. Installing the latest version from the Winget repository.\"\n    Start-Process -FilePath $wingetExe -NoNewWindow -Wait -ArgumentList 'install Lenovo.ThinInstaller --silent --accept-package-agreements --accept-source-agreements'\n    Start-Sleep -Seconds 15\n}\n\n# Function to check and update Thin Installer\nfunction Update-ThinInstaller\n{\n    $ThinInstallerPath = Join-Path -Path (Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath Lenovo) -ChildPath \"ThinInstaller\"\n\n    if (-not (Test-Path -Path $ThinInstallerPath))\n    {\n        Install-ThinInstaller\n    }\n    else\n    {\n        Write-Output \"Checking the Winget repository for an updated version...\"\n\n        # Get the local version of Thin Installer\n        [version]$LocalVersion = $(try { ((Get-ChildItem -Path $ThinInstallerPath -Filter \"thininstaller.exe\" -Recurse).VersionInfo.FileVersion) } catch { $null })\n\n        # Prepare for capturing the versions output\n        $versionsOutputFile = \"$($env:TEMP)\\winget_versions_output.txt\"\n\n        # Select newest winget.exe file based on folder order and set it as winget variable\n        $wingetExe = Get-ChildItem -Path \"$($env:ProgramFiles)\\WindowsApps\" -Filter winget.exe -Recurse | Sort-Object -Property 'FullName' -Descending | Select-Object -First 1 -ExpandProperty FullName | Tee-Object -FilePath \"$WinGet\\Winget-file-found-from.log\"\n\n        # Start the process to get versions and redirect output to a file\n        Start-Process -FilePath $wingetExe -ArgumentList 'show lenovo.thininstaller --versions' -NoNewWindow -Wait -RedirectStandardOutput $versionsOutputFile\n\n        # Read the output from the file\n        $versionsOutput = Get-Content -Path $versionsOutputFile\n\n        # Extract versions from the output and find the latest version\n        $versions = $versionsOutput | Select-String -Pattern '^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$'\n        $latestVersion = [version]($versions -replace 'Version', '' -replace '-', '' | ForEach-Object { $_.Trim() } | Sort-Object -Descending | Select-Object -First 1)\n\n        Write-Output \"Local version: $LocalVersion\"\n        Write-Output \"Latest version: $latestVersion\"\n\n        # Compare the local version with the latest version\n        if ($LocalVersion -lt $latestVersion)\n        {\n            Write-Output \"An update is available.\"\n            Install-ThinInstaller\n        }\n        else\n        {\n            Write-Output \"The installed version is up-to-date.\"\n        }\n    }\n}\n\n# Call the function to check and update Thin Installer\nUpdate-ThinInstaller\n</code></pre>"},{"location":"creating-local-repository-using-powershell/#building-the-repository","title":"Building the Repository","text":"<p>The PowerShell script Get-LnvUpdatesRepo.ps1 will download current updates from Lenovo's servers and store on the device. Parameters are accepted to specify the repository path and to filter updates by package type and reboot type. The SCCM Task Sequence module has also been integrated to provide more details as updates are downloaded and installed during each pass of Thin Installer.</p> <pre><code>-RepositoryPath 'C:\\ProgramData\\Lenovo\\ThinInstaller\\Repository' -PackageTypes '1,2,3,4' -RebootTypes '0,3,5' -RT5toRT3\n</code></pre> <p>Based on the above, this filters update package types to include:</p> <ul> <li>1 - Applications</li> <li>2 - Drivers</li> <li>3 - BIOS</li> <li>4 - Firmware</li> </ul> <p>and reboot packages that are:</p> <ul> <li>0 (No reboot required)</li> <li>3 (Reboot required but not forced)</li> <li>5 (Delayed forced reboot).</li> </ul> <p>The -RT5toRT3 parameter is a special case to be used in task sequences which will control the rebooting of the system after Thin Installer runs. It will change Reboot Type 5 updates to Reboot Type 3, which instructs Thin Installer to not perform the reboot.</p> <p>Note</p> <p>After these types of updates are applied, the system needs to be rebooted immediately to avoid possible damage to the system. This is taken care of by the task sequence.</p> <p>Info</p> <p>The All Updates group contains the necessary parameters and Thin Installer command lines to include Reboot Type 5 packages (BIOS/Firmware). The Drivers group will only download Reboot Type 0 and 3 packages (Drivers), and is disabled by default.</p> <p>Once all content is downloaded to the device, 3 passes of Thin Installer (with a reboot in between) installs all updates to ensure the device is current.</p>"},{"location":"creating-local-repository-using-powershell/#install-passes","title":"Install Passes","text":"<p>A PowerShell script invoking Thin Installer with the necessary parameters is executed in each pass.</p> <p>1st Pass</p> <p>If a BIOS update is applicable, this package gets installed first</p> <p>2nd Pass</p> <p>Only drivers and apps are filtered for installation. Depending on the model, a second step of this pass will pick up any dependent drivers that weren't visible until its parent driver was installed during the 1st pass.</p> <p>Note</p> <p>In some cases, typically with Thunderbolt, there may be a requirement that the latest driver needs to be installed before the firmware can be updated. This pass will ensure those drivers are installed before the firmware is installed in the next pass.</p> <p>A preview of what the task sequence looks like during these passes</p> <p></p> <p></p> <p>3rd Pass</p> <p>The final pass installs firmware packages, such as Intel ME Firmware.</p> <p>Note</p> <p>In some cases there are drivers that do not become applicable until another driver has been installed. This final pass includes drivers to ensure those are covered for a complete installation.</p>"},{"location":"creating-local-repository-using-powershell/#summary","title":"Summary","text":"<p>With this scenario, there is very little effort needed to manage multiple models. This approach does download the updates on each device being deployed which may be a redundant use of network bandwidth to the Internet. However, this approach works very well in a scenario where the device is being reimaged off-site.</p> <p>This approach could be modified easily to incorporate a centralized network storage for the repository so that multiple devices could share the same content. The Get-LnvUpdatesRepo.ps1 script could be called from an admin's machine to create repository folders for each machine type. The script in the task sequence could then be modified to call Thin Installer with a -repository parameter pointing to the correct machine type folder.</p> <p>Normally, if BIOS and firmware updates are included which will force a reboot (reboot type 1) or force a delayed reboot (reboot type 5) then the task sequence will be interrupted. Most current Lenovo ThinkPad, ThinkCentre and ThinkStation products have switched to using Reboot Type 5 for BIOS updates. Therefore, the Get-LnvUpdatesRepo.ps1 script has an option, -RT5toRT3, which changes the Reboot Type to 3 instead of 5. This, in combination with the -noreboot parameter of Thin Installer, allows the updates to be applied with Configuration Manager controlling the restart.</p> <p>In a future article we will look at other scenarios that are made possible with the Get-LnvUpdatesRepo.ps1 script and may even provide additional features and enhancements to the script.</p>"},{"location":"su-helper-use-cases-in-a-modern-world/","title":"SU Helper Use Cases in a Modern World","text":"<p>The SU Helper utility was introduced to programmatically trigger the System Update AddIn of Commercial Vantage. Let's see how we can leverage SU Helper in different scenarios across Microsoft's Endpoint Management solutions.</p>"},{"location":"su-helper-use-cases-in-a-modern-world/#overview","title":"Overview","text":"<p>This will be an ongoing article as new examples will continue to be introduced.</p>"},{"location":"su-helper-use-cases-in-a-modern-world/#configuration-manager","title":"Configuration Manager","text":""},{"location":"su-helper-use-cases-in-a-modern-world/#run-scripts-functionality","title":"Run Scripts functionality","text":"<p>This example will demonstrate how to utilize Configuration Manager's ability to run PowerShell scripts.</p> <p>Note</p> <p>Reference the MS docs here</p>"},{"location":"su-helper-use-cases-in-a-modern-world/#scenario-on-demand-bios-update","title":"Scenario: On-Demand BIOS Update","text":"<p>In this scenario, we're going to demonstrate how to deploy a PowerShell script to a co-managed Windows endpoint that will trigger the System Update AddIn of Commercial Vantage to filter and install only applicable BIOS updates, followed by presenting a toast notification to the end user prompting to install and reboot. Keep in mind, this example is more or less a \"quick and dirty\" solution but is intended to show expected behavior, where to trace the System Update log for installation status, and querying the Lenovo_Updates WMI class.</p> <p>Follow the steps to create a script and insert the below sample PowerShell code. Once created, approve it.</p> <pre><code># Define SU Helper variables\n$basePath = \"$env:ProgramFiles\\Lenovo\\SUHelper\"\n$suHelperPath = Join-Path -Path $basePath -ChildPath \"SUHelper.exe\"\n$suParams = @('-autoupdate', '-packagetype', '3') # Specifying Package Type 3 to filter only BIOS updates (https://docs.lenovocdrt.com/guides/cv/suhelper/#-packagetype-string)\n\n# Check if SUHelper.exe exists\nif (-Not (Test-Path $suHelperPath))\n{\n    Write-Error \"SUHelper.exe not found at $suHelperPath.\"\n    exit 1\n}\n\ntry\n{\n    # Fetch applicable updates\n    $applicableUpdates = Get-CimInstance -Namespace root/Lenovo -ClassName Lenovo_Updates | Where-Object { $_.Status -eq \"Applicable\" }\n\n    # Check for BIOS update\n    $biosUpdateAvailable = $applicableUpdates | Where-Object { $_.Title -match \"BIOS\" }\n\n    if (-Not $biosUpdateAvailable)\n    {\n        Write-Output \"No BIOS update available.\"\n        exit 0\n    }\n    else\n    {\n        Write-Output \"BIOS update available to install. Triggering SU Helper.\"\n    }\n\n    # Start the SU Helper process\n    $process = Start-Process -FilePath $suHelperPath -ArgumentList $suParams -NoNewWindow -PassThru\n    $process.WaitForExit()\n\n    if ($process.ExitCode -ne 0)\n    {\n        Write-Error \"SUHelper.exe exited with code $($process.ExitCode).\"\n        exit 1\n    }\n}\ncatch\n{\n    Write-Error \"Error occurred: $_\"\n    exit 1\n}\n</code></pre> <p></p> <p>On a test device, assume Commercial Vantage and SU Helper is installed. For this demo, I'm going to manually launch Commercial Vantage and run a check for updates. Here you can see one recommended update, which is BIOS.</p> <p></p> <p>I can also retrieve this by querying the Lenovo_Updates WMI class.</p> <p></p> <p>If you have enabled logging, you can review the update candidate list in the System Update AddIn log which will also show you the package's reboot type. BIOS packages will be a type 5.</p> <p></p> <p>Back in the ConfigMgr console, I'm going to select my test device and Run Script from the ribbon bar, choosing the Trigger SU Helper script approved earlier. Shortly after, I see the script has successfully run and that a BIOS update is available to install.</p> <p></p> <p>Now for the user experience. BIOS updates are designed to present a prompt to the end user informing that this update will require a reboot. This is what the toast notification will look like, which can be customized with your company's branding as of version 10.2501.15.0.</p> <p></p> <p>I'm going to click OK to proceed with the update. In the background, the BIOS update will be installed and staged for flashing upon the next reboot. Assuming all is well, I can open the latest System Update AddIn log and filter for success and see the BIOS package was installed successfully.</p> <p></p> <p>Once the process completes, a second toast notification will be presented to the user informing that the system will reboot in 5 minutes.</p> <p></p> <p>After the reboot completes, I can launch Commercial Vantage and see the update history now shows the BIOS update was installed successfully with a timestamp.</p> <p></p> <p>If I query WMI, I can see the the property values have been updated as well</p> <p></p>"},{"location":"su-helper-use-cases-in-a-modern-world/#intune","title":"Intune","text":""},{"location":"su-helper-use-cases-in-a-modern-world/#remediations","title":"Remediations","text":"<p>This scenario describes using Intune Remediations to trigger SU Helper.</p>"},{"location":"su-helper-use-cases-in-a-modern-world/#scenario-silently-updating-drivers","title":"Scenario: Silently Updating Drivers","text":"<p>In this scenario, we're going to deploy a PowerShell remediation script package to filter for drivers and install only reboot type 0 and 3 updates. These updates will install silently (requiring a reboot) and won't present any prompts to the user.</p> <p>Info</p> <p>SU Helper documentation for details regarding -packagetype and -reboottype parameters</p> <p>The detection will check a few items, such as SU Helper presence and the last time the updates_history.txt file was last modified. This file gets updated every time Commercial Vantage scans for updates and can be found at this location:</p> <pre><code>C:\\ProgramData\\Lenovo\\Vantage\\AddinData\\LenovoSystemUpdateAddin\\session\n</code></pre> <ol> <li> <p>In the Intune admin center, go to Devices &gt; Manage devices &gt; Scripts and remediations.</p> </li> <li> <p>Click Create and enter a name and optionally a description.</p> </li> <li> <p>Save and upload the Detection and Remediation script files from my GitHub and assign to a group, preferably one containing Lenovo devices.</p> </li> </ol> <p>At the time of this writing (June 11), I grabbed a system that hasn't been powered on in over 3 months so the threshold variable set in the detection script (30 days) should certainly trigger SU Helper.</p> <p></p> <p>After triggering the remediation to run on the device and waiting several minutes, I see the timestamp for the updates_history text file has been modified and the SU Helper log output returned a 0 - Success return code. When I launched Commercial Vantage and checked the updates history, I see a handful of drivers that updated successfully.</p> <p></p> <p>Back in the Intune admin center, adding the Pre/Post-remediation detection output columns, remediation did its job and the device is now up-to-date.</p> <p></p>"},{"location":"what-is-the-system-firmware-update-utility/","title":"What Is The System Firmware Update Utility?","text":"<p>You may start seeing a new update offered titled System Firmware Update Utility. What exactly is this and what does it fix?</p> <p>Starting with the X1 Carbon Gen 13, and eventually common for all ThinkPad 2025 products, this System Firmware Update Utility now bundles:</p> <ul> <li>System Firmware</li> <li>UEFI BIOS</li> <li>Embedded Controller Firmware (ECP)</li> <li>Intel Management Engine Firmware</li> <li>Power Delivery Firmware</li> </ul> <p>This can be found in the ReadMe</p> <p></p> <p>Here is what is presented in Commercial Vantage.</p> <p></p> <p>Inspecting the package XML descriptor, we can see these updates are a RebootType 5 (reboot delayed) and PackageType 4 (Firmware).</p> <p></p> <p>The BIOS update utility has been revamped to now show a comparison between the currently installed firmware versions and the newer versions.</p> <p></p> <p>The end-user experience shows a counter and which firmware is being updated now, which is helpful.</p> <p></p> <p>The System Firmware Version can be found in the BIOS Setup Main page. It is a version number representing the collection of UEFI + EC + ME + PD firmware.</p> <p></p> <p>While this is a great improvement in update delivery and reduces the amount of separate updates for a given device, with it comes implications. There will be the challenge of having multiple versions of different updates within the package that also has its own version number. If a future update is released that keeps the same version of BIOS but includes a newer version of the Intel MEFW, what would this look like if you're using the Get-LnvAvailableBiosVersion cmdlet from our Lenovo Client Scripting module?</p> <p>On the bright side, this should make patching a bit less painful.</p>"},{"location":"how-to-use-thinkcentres-tpm-firmware--switch-tool-with-configmgr/","title":"How to Use ThinkCentre's TPM Firmware <br> Switch Tool with ConfigMgr","text":"<p>This article will cover the TPM Firmware Switch Tool that was released to remedy affected ThinkCentres described in the LEN-15552 Security Advisory.</p> M71x-Series M91x-Series M710t M910t M710s M910s M710q M910q M715s M910x M715t <p>If a system is configured for TPM 2.0, the BIOS level must be at a specific level before the firmware update can be applied. Links to the BIOS versions can be found in the matrix.</p> <p>To summarize, the tool will update the TPM firmware to the latest version, whether it be TPM Spec 1.2 or 2.0. It will also allow you to switch the TPM Spec version from 1.2 to 2.0 or vice versa if desired, while also applying the latest TPM firmware in the process.</p> <p>BitLocker (or an alternative) will need to be suspended prior to performing the update otherwise you will be prompted for the Recovery Key after the flash completes and the system reboots. Most importantly, a Supervisor Password is required before attempting to update or switch the TPM firmware.</p> <p>After you've downloaded and extracted the contents of the tool to a source location, you'll want to edit the flash.cmd by removing the shutdown switch that forces the system to reboot. That way, you can call the shutdown at the end of the task sequence with the SMSTSPostAction variable.</p> <p>Look for the following line in the flash.cmd and remove /shutdown and save the file.</p> <pre><code>%Flashtool% /CAPFILE:%FWFILE% /pw:%BIOSPWD% /shutdown\n</code></pre> <p>Create a Package in your ConfigMgr console, no program, pointing to the source location of where you extracted the contents of the zip.</p> <p>Below is a sample Task Sequence that shows the workflow of how this tool can be used to switch TPM Spec versions while applying the latest firmware:</p> <p></p>"},{"location":"how-to-use-thinkcentres-tpm-firmware--switch-tool-with-configmgr/#group-1-set-ts-variables","title":"Group 1-Set TS Variables","text":"<ul> <li>Check SecurityChipStatus - Task Sequence Variable</li> </ul> <p>WMI Query to check if the Security Chip is Spec 1.2</p> <pre><code>SELECT * From Lenovo_BiosSetting WHERE CurrentSetting LIKE 'Security Chip 1.2,Active'\n</code></pre> <p>The value here may differ across models, i.e. SecurityChip, Active or Security Chip,Enable. Be sure to double check this before adding your query.</p> <ul> <li>Set OSDBitLockerStatus task sequence variable (credit to Mike Terrill).</li> </ul> <p></p> <p></p> <p>WMI Query to check if the system drive is encrypted and protection is on.</p> <pre><code>SELECT * From Win32_EncryptableVolume WHERE DriveLetter = 'C:' and ProtectionsStatus = '1'\n</code></pre> <ul> <li>ThinkCentre SMSTSPostAction - Task Sequence Variable</li> </ul> <p>This will invoke the flash due to the required shutdown. Remember this was removed from flash.cmd earlier, otherwise the task sequence would break.</p> <p></p> <p></p> <p>WMI Query to check if the system is a ThinkCentre</p> <pre><code>SELECT * FROM Win32_ComputerSystemProduct WHERE Version LIKE 'ThinkCentre%'\n</code></pre>"},{"location":"how-to-use-thinkcentres-tpm-firmware--switch-tool-with-configmgr/#group-2-disable-bitlocker","title":"Group 2-Disable BitLocker","text":"<ul> <li>Native Disable BitLocker step</li> </ul> <p>Add a condition to check if Task Sequence Variable OSDBitLockerStatus status equals Protected.</p>"},{"location":"how-to-use-thinkcentres-tpm-firmware--switch-tool-with-configmgr/#group-3-configure-tpm","title":"Group 3-Configure TPM","text":"<p>Add a condition to check if Task Sequence Variable SecurityChipStatus does not equal Ready.</p> <ul> <li>Download Think BIOS Config Tool - Download Package Content Step<ul> <li>I'm using the Think BIOS Config Tool to enable the security chip.</li> </ul> </li> </ul> <p></p> <ul> <li>Run Command Line - Enable TPM</li> </ul> <p></p> <pre><code>cmd.exe /c %BIOSConfig01%\\ThinkBiosConfig.hta \"file=BIOSConfig.ini\" \"pass=1234567\"\n</code></pre> <p>By using the BIOS Config Tool, I'm calling the configuration file .ini that holds the value to enable the security chip while passing the Supervisor Password. Alternatively, this can be achieved using Run Command Line steps calling PowerShell and setting/saving the BIOS settings stored in the Lenovo_BiosSetting namespace.</p> <ul> <li>Restart Computer Step - Back to Operating System</li> </ul> <p></p>"},{"location":"how-to-use-thinkcentres-tpm-firmware--switch-tool-with-configmgr/#group4-thinkcentre","title":"Group4-ThinkCentre","text":"<p>These WMI queries will check the first 4 characters of the BIOS version, which matches to each of the affected ThinkCentres as noted in the security bulletin matrix. Refer to the Deployment Recipe Card for these queries.</p>"},{"location":"how-to-use-thinkcentres-tpm-firmware--switch-tool-with-configmgr/#group5-tpm-spec-12-to-20","title":"Group5-TPM Spec 1.2 to 2.0","text":"<p>WMI Query to check the TPM Spec is 1.2 before continuing to switch to 2.0.</p> <p>Namespace: root\\cimv2\\Security\\MicrosoftTpm</p> <pre><code>SELECT * From Win32_Tpm WHERE SpecVersion LIKE '1.2%'\n</code></pre> <ul> <li>Run Command Line-Update TPM Firmware</li> </ul> <p></p> <pre><code>flash.cmd /2 1234567 /s\n</code></pre>"},{"location":"how-to-use-thinkcentres-tpm-firmware--switch-tool-with-configmgr/#further-research-notes-and-caveats","title":"Further research, notes and caveats","text":"<ul> <li>If the Security Chip is Inactive, the TPM will not have an owner. Once the Configure TPM group is executed and Security Chip becomes Active, Windows 10 will take ownership of the TPM automatically.  Clearing the TPM will not be necessary after this.</li> <li>If down-leveling from TPM 2.0 to 1.2 using the /1 switch, adjust the SpecVersion query to:</li> </ul> <pre><code>SELECT * FROM Win32_TPM WHERE SpecVersion LIKE '2.0%'\n</code></pre> <ul> <li>As a result of down-leveling, the TPM will become disabled, inactive, and unowned. This can be fixed using the SetPhysicalPresenceRequest method.  (10-Enable, activate, and allow the installation of a TPM owner.)</li> <li>Windows 10 will automatically re-enable BitLocker after the reboot.</li> </ul>"},{"location":"windows-365-and-thinkphone/","title":"Windows 365 and ThinkPhone","text":"<p>This article will serve as a basic walkthrough for bringing the full Windows 365 experience to your Lenovo ThinkPhone.</p> <p>\"... The power and security of the Microsoft cloud with the versatility and simplicity of the PC\" is now in your pocket!</p>"},{"location":"windows-365-and-thinkphone/#prerequisites","title":"Prerequisites","text":"<p>To avoid redundancy or confusion, most of the steps laid out in this guide will link to Microsoft's documentation. It's assumed the reader has an active Azure subscription and working tenant with the necessary licenses (Intune user and Windows 365) assigned.</p> <p>ThinkPhone can connect to either Windows 365 Enterprise or Business cloud PCs. Refer to the edition comparisons here.</p> <p>Ensure your tenant is configured for user and device enrollment and verify the cloud PC has been provisioned successfully (if deploying an Enterprise SKU).</p>"},{"location":"windows-365-and-thinkphone/#enrolling-thinkphone-in-intune","title":"Enrolling ThinkPhone in Intune","text":"<p>There are several options when enrolling Android devices. For this guide, I'm going to enroll my ThinkPhone as an Android Enterprise fully managed device (COBO).</p> <p>Be sure to complete the task list. Once your enrollment profile has been created, you're ready to power on your ThinkPhone and bring it under management.</p> <p>I'm going to enroll using a QR code. Once the QR reader is open, scan the enrollment profile QR code</p> <p>For demo purposes, this is what the QR/token looks like and will be revoked after this blog is published</p> <p></p> <p>Next, connect to a Wi-Fi network and follow the many on-screen prompts.</p> <p>There's at least a dozen different screens to transition through during enrollment so I'm only adding a handful of the important ones</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"windows-365-and-thinkphone/#connecting-to-windows-365","title":"Connecting to Windows 365","text":"<p>Upon successful enrollment, pair your ThinkPhone to your Bluetooth keyboard/mouse and connect to a monitor via USB-C cable. Moto Connect will extend to your monitor and what's first in the list of apps to choose? Windows 365?!</p> <p></p> <p>Click on Windows 365. Notice the screen change to the Windows 365 wallpaper and on your phone, choose which cloud PC to connect to</p> <p> </p> <p>Enter your credentials and you'll be taken to your Windows 365 cloud PC.</p> <p> </p>"},{"location":"windows-365-and-thinkphone/#deploying-the-motorola-ready-for-assistant","title":"Deploying the Motorola Ready For Assistant","text":"<p>To take advantage of the enhanced ThinkPhone experience when combined with a Lenovo Windows PC, you can deploy the Ready For Assistant store app to your users' devices.</p> <p>Login to the Intune admin center</p> <p>Go to the Apps blade. Click +Add to create a new app.</p> <p>Select Microsoft Store app (new) for App type and click Select </p> <p>Click Search the Microsoft Store app (new). If you search the store for Ready For Assistant, you won't get any results. However, you can search using the app ID XP8JRF5SXV03ZM to add it</p> <p></p> <p>Click on the app and then click Select. Once the app is added, find it in the list and open its Properties.</p> <p></p> <p>Scroll to the bottom and click Edit next to Assignments</p> <p></p> <p>Configure the assignments as desired and then click Review + save</p> <p></p> <p>Devices will then get the app based on the configuration of the Assignment. It may require the devices to get to their scheduled sync before the offer is made.</p> <p>You can force a sync by going to the device in the Devices view and clicking the  button.</p>"},{"location":"thinkshield-secure-wipe/","title":"ThinkShield Secure Wipe","text":""},{"location":"thinkshield-secure-wipe/#overview","title":"Overview","text":"<p>ThinkShield secure wipe is the successor to the ThinkPad Drive Erase Utility and is designed to provide the wipe out function of the SSD.</p> <p>Note</p> <p>For more detailed information about ThinkShield Secure Wipe, please see the ThinkShield Secure Wipe Technical Whitepaper</p> <p>Although the Drive Erase Utility is still supported and provided as an external tool, ThinkShield secure wipe is fully integrated in the BIOS image and does not require any external tools.</p> <p>Secure wipe can be executed locally by BIOS from the application menu of the Startup Boot Menu invoked by F12 or remotely from OS through the WMI interface, which is what this post will be covering.</p>"},{"location":"thinkshield-secure-wipe/#supported-systems","title":"Supported Systems","text":""},{"location":"thinkshield-secure-wipe/#all-2020-and-later-thinkpadthinkcentre","title":"All 2020 and later ThinkPad/ThinkCentre","text":""},{"location":"thinkshield-secure-wipe/#thinkstation","title":"ThinkStation","text":"P Series P360 Tiny/Tower P360 Ultra P350 Tiny/Tower/Small Form Factor P358 P340 Tiny <p>Warning</p> <p>These examples are intended to demonstrate a few different methods available to deploy the solution and not necessarily a \"Best Practice\". Adjust accordingly to fit your environment's needs. There is also no auditing/reporting provided by these methods.</p>"},{"location":"thinkshield-secure-wipe/#requirements","title":"Requirements","text":"<p>The WMI service for ThinkShield secure wipe is available only when one of the following is set</p> <ul> <li>Supervisor Password (SVP)</li> <li>System Management Password (SMP)</li> <li>Hard Disk Password (HDP)</li> </ul> <p>Sample PowerShell script that executes secure wipe on target system.</p> <p>https://github.com/CDRT/Library/tree/master/secure-wipe</p> <p>Save as Invoke-ThinkShieldSecureWipe.ps1</p>"},{"location":"thinkshield-secure-wipe/#scenarios","title":"Scenarios","text":"<p>The following examples will demonstrate how to invoke the ThinkShield secure wipe function with Microsoft Configuration Manager and Intune service</p>"},{"location":"thinkshield-secure-wipe/#configuration-manager","title":"Configuration Manager","text":""},{"location":"thinkshield-secure-wipe/#scenario-1a-deploying-using-run-scripts","title":"SCENARIO 1a - Deploying using Run Scripts","text":"<p>Navigate to Software Library &gt; Scripts &gt; Create Script and either import Invoke-ThinkShieldSecureWipe.ps1 or copy the contents into the script editor field</p> <p></p> <p>Specify the EraseMethod, PasswordType, and Password parameters. Details for each parameter is explained in the script header.</p> <p></p> <p>Complete the Create Script wizard and Approve it</p> <p></p> <p>Deploy to a single system or collection of systems. If successful, you should see a message stating the secure wipe succeeded and that the system needs to reboot to finish.</p> <p></p>"},{"location":"thinkshield-secure-wipe/#scenario-1b-deploying-as-a-task-sequence","title":"SCENARIO 1b - Deploying as a Task Sequence","text":"<p>Create a new Custom Task Sequence. Edit the Task Sequence and add a Run PowerShell Script step. Tick the radio button Enter a PowerShell script and click Edit Script...</p> <p>Browse to Invoke-ThinkShieldSecureWipe.ps1 or copy the contents into the script editor.</p> <p>In the Parameters field, enter the required parameters.</p> <p></p> <p>Add a Restart Computer step to transition the system to secure wipe. In my lab, I deployed as an available Task Sequence and customized the notification texts.</p> <p></p>"},{"location":"thinkshield-secure-wipe/#intune","title":"Intune","text":"<p>Package the Invoke-ThinkShieldSecureWipe.ps1 as a Win32 app using the Microsoft Win32 Content Prep Tool.</p> <p></p> <p>Log into the Intune admin center and add a new Win32 app. Browse to the Invoke-ThinkShieldSecureWipe.intunewin file and add it for upload.</p> <p>Specify App Information such as a Name, Description, and Publisher</p> <p></p> <p>Specify Program details</p> <p></p> <ul> <li>Install Command</li> </ul> <pre><code>powershell.exe -ExecutionPolicy Bypass -File \".\\Trigger-ThinkShieldSecureWipe.ps1\" -EraseMethod ATAN -PasswordType SVP -Password secretsvp\n</code></pre> <ul> <li>Uninstall Command</li> </ul> <pre><code>cmd.exe /c\n</code></pre> <p>Device Restart Behavior: Determine based on return codes</p> <p>Set the OS architecture to 64-bit and Minimum OS to Windows 10 1607</p> <p>Add an additional requirement rule to check the system is Lenovo.</p> <p></p> <ul> <li>Registry Type</li> <li>Key Path: HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS</li> <li>Value Name: SystemManufacturer</li> <li>Key Requirement: String Comparison</li> <li>Operator: Equals</li> <li>Value: LENOVO</li> </ul> <p>Set the detection rule to check the presence of a File</p> <p></p> <p>This file will be created automatically when the script is run.</p> <ul> <li>Path: %ProgramData%\\Lenovo\\ThinkShield</li> <li>File or folder: SecureWipe.tag</li> <li>Detection method: File or folder exists</li> </ul> <p>Deploy the app to a group. In my testing, I deployed as available and installed through the Company Portal.  After a successful install, a toast notification is presented instructing for the reboot.</p> <p></p> <p>Once the system has restarted, secure wipe will trigger.</p> <p></p>"},{"location":"tracking-thin-installer-update-history-with-configmgr-current-branch/","title":"Tracking Thin Installer Update History With ConfigMgr Current Branch","text":"<p>Due to customer feedback, Lenovo is introducing a couple of new features focused on tracking updates.  Traditionally, updates installed on the client were logged in the Updates_log(timestamp).txt.</p> <p>Admittedly, parsing through the log to find out which updates were skipped, installed, or failed is not that easy. If you're deploying a task sequence to your Lenovo systems that runs Thin Installer, you can only see if Thin Installer runs or not. How do you tell which updates installed without logging into each system and checking the logs?</p> <p>A new switch can now be added to your Thin Installer command line that will do the following upon execution:</p> <ul> <li>Create a new Lenovo WMI namespace and Lenovo_Updates class</li> <li>Adds the following Properties to the Class</li> <li>PackageID - Listed as Update ID in Update Retriever</li> <li>Title - Friendly name of the update</li> <li>Status - Possible values can be:<ul> <li>NotApplicable</li> <li>AlreadyInstalled</li> <li>Applicable</li> <li>NotInstalled</li> <li>DownloadFailed</li> <li>InstallFailed</li> <li>InstallSuccess</li> </ul> </li> <li>AdditionalInfo - Provides more detail if the Status equaled Download Failed.  Possible values can be:<ul> <li>InstallerFileNotExist</li> <li>InstallerFileCrcNotMatch</li> <li>ExternalFileNotExist</li> <li>ExternalFileCrcNotMatch</li> </ul> </li> <li>Version - The version associated with the update installed</li> </ul> <p>A sample Thin Installer command line using the new -exporttowmi switch</p> <pre><code>ThinInstaller.exe /CM -search A -action INSTALL -repository \\\\URrepo\\LenovoUpdates -noicon -includerebootpackages 3 -noreboot -exporttowmi -log \"%SystemDrive%\\Program Files (x86)\\ThinInstaller\\Logs\"\n</code></pre>"},{"location":"tracking-thin-installer-update-history-with-configmgr-current-branch/#exploring-wmi","title":"Exploring WMI","text":"<p>Launching WMIExplorer on a target system and navigating to the newly created Namespace/Class, we can see the 5 properties have been created</p> <p></p> <p>On the Instances tab, you'll notice 17 entries. This means that 17 applicable updates to this system were found in my Update Retriever repository.</p> <p></p> <p>Each instance will display the PackageID of the update it found. If you click on an instance, you can see the result of the update that attempted to install on the system. In this case, the latest Chipset Software is already installed.</p> <p></p> <p>Reviewing another instance, a newer version of the Camera Driver was installed successfully</p> <p></p> <p>One more example, this Bluetooth Driver returned as Not Applicable because it only applies to Windows 10 1703. The system I ran Thin Installer on is Windows 10 1803.</p> <p></p>"},{"location":"tracking-thin-installer-update-history-with-configmgr-current-branch/#collecting-the-data-with-hardware-inventory","title":"Collecting the data with Hardware Inventory","text":"<p>Now that the data is in WMI, it can be collected. Copy the contents below into NotePad and save it as a .MOF file, which you will then import as a new Hardware Inventory Class in your Client Settings.  For more information on extending hardware inventory, refer to the MS docs here.</p> <pre><code>[SMS_Report, SMS_Group_Name(\"Lenovo_Updates\"), SMS_Class_Id(\"Lenovo_Updates\"),Namespace (\"root\\\\\\\\Lenovo\")]\nclass Lenovo_Updates: SMS_Class_Template\n{\n [key, SMS_Report] string PackageID;\n [SMS_Report] string Title;\n [SMS_Report] string Status;\n [SMS_Report] string AdditionalInfo;\n [SMS_Report] string Version;\n};\n</code></pre> <p></p> <p>Once the client has received the updated Client Settings and the Hardware Inventory cycle has processed, you can start up Resource Explorer and review the data.</p> <p></p>"},{"location":"tracking-thin-installer-update-history-with-configmgr-current-branch/#tracking-thin-installer-version-and-last-scan","title":"Tracking Thin Installer Version and Last Scan","text":"<p>We can take this a step further and track the version of Thin Installer on the system and when a scan was last performed to install updates. Thin Installer adds a few registry keys and stamps the Version and Last Scan Date every time it executes.</p> <p>Since these are registry keys that need to be collected, you'll need to append the configuration.mof specifying the data to be consumed as part of the Hardware Inventory cycle.</p> <p>CTGlobal and Enhansoft walk through how to do this using the RegKeytoMof tool.</p> <p>Here's the information to be copied into the configuration.mof</p> <pre><code>#pragma namespace (\"\\\\\\\\.\\\\root\\\\cimv2\")\n#pragma deleteclass(\"ThinInstaller\", NOFAIL)\n[DYNPROPS]\nClass ThinInstaller\n{\n[key] string KeyName;\nString Version;\nString LastScanDate;\n};\n\n[DYNPROPS]\nInstance of ThinInstaller\n{\nKeyName=\"ThinInstaller\";\n[PropertyContext(\"Local|HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\WOW6432Node\\\\Lenovo\\\\ThinInstaller|Version\"),Dynamic,Provider(\"RegPropProv\")] Version;\n[PropertyContext(\"Local|HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\WOW6432Node\\\\Lenovo\\\\ThinInstaller|LastScanDate\"),Dynamic,Provider(\"RegPropProv\")] LastScanDate;\n};\n</code></pre> <p>Upon the next Hardware Inventory cycle, these registry keys will be collected and can be reviewed in Resource Explorer</p> <p></p>"},{"location":"updating-lenovo-thin-installer-with-proactive-remediations/","title":"Updating Lenovo Thin Installer with Proactive Remediations","text":"<p>If your endpoints rely on Thin Installer to update drivers/BIOS/firmware, it should always be on the latest release. As part of the certificate verification process for installing updates with Thin Installer, older versions of Thin Installer cannot validate packages signed with newer certificates. The only solution is to upgrade Thin Installer, hence the reason for this article.</p> <p>Lenovo's enterprise tools are now available in the Windows Package Manager Community Repository and can be managed using the Winget tool.</p> <p>Since Thin Installer doesn't require installation, a Registry detection as to which version is \"installed\" on the endpoint isn't an option. What you're left with comes down to a file version check on the Thin Installer application itself.</p> <p>While it's available to install from the winget repository, the manifest does not include uninstall parameters. And as it's not actually \"installed\" on the endpoint, winget doesn't recognize it either.</p> <p>On my test machine, I installed an older version of Thin Installer via winget. Executing a simple get-childitem command verifies this, however, the list command of the winget tool says otherwise</p> <p></p> <p>What about the upgrade command of winget?</p> <p></p> <p>Nope. Can't upgrade if it's not there. So how can this tool be kept current without having to create a separate Win32 App?</p>"},{"location":"updating-lenovo-thin-installer-with-proactive-remediations/#solution","title":"Solution","text":"<p>We'll use a Proactive Remediation script package to compare the version of Thin Installer on the endpoint and what's available in the winget repository.</p> <p>While the winget tool will be used to perform the upgrade, I found the PSWinget Module handles the version comparisons much easier than manipulating the output from the winget tool itself. For my testing and expected end results, this is what I stuck with. The detection/remediation scripts can be found on my GitHub.</p> <p>This solution will install a PowerShell module on the endpoint</p> <p>Detection script</p> <pre><code># Enable Tls 1.2 support to download modules\n[Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls12\n\nif (-not(Get-InstalledModule -Name PSWinGet -ErrorAction SilentlyContinue)) {\n    Write-Output -InputObject \"`nPSWinGet module was not found. Installing ...\"\n    try {\n        # Install NuGet package provider\n        Install-PackageProvider -Name \"NuGet\" -MinimumVersion 2.8.5.201 -Force -ErrorAction Stop\n        # Install PSWinGet module for easier app version comparisons\n        Install-Module PSWinGet -Scope AllUsers -Force -Confirm:$false\n    }\n    catch {\n        Write-Error -Message $_.Exception.Message\n    }\n}\n\n$ThinInstallerPath = Join-Path -Path (Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath Lenovo) -ChildPath \"ThinInstaller\"\nif (-not(Test-Path -Path $ThinInstallerPath)) {\n    Write-Output -InputObject \"Thin Installer not present...\"; Exit 1\n} else {\n    Write-Output -InputObject \"Checking the Winget repository for an updated version...\"\n}\n\n[version]$LocalVersion = $(try { ((Get-ChildItem -Path $ThinInstallerPath -Filter \"thininstaller.exe\" -Recurse).VersionInfo.FileVersion) } catch { $null })\n[version]$WingetVersion = (Find-WinGetPackage -Id Lenovo.ThinInstaller).Version\nif ($LocalVersion -lt $WingetVersion) {\n    Write-Output -InputObject \"Thin Installer is not current...\"; Exit 1\n}\nelse {\n    Write-Output -InputObject \"Thin Installer is current...\"; Exit 0\n}\n</code></pre> <p>Simple Remediate script</p> <pre><code>try {\n    Install-WinGetPackage -Id Lenovo.ThinInstaller -Confirm:$false; Exit 0\n}\ncatch {\n    Write-Warning -Message $_.Exception.Message; Exit 1\n}\n</code></pre>"},{"location":"updating-lenovo-thin-installer-with-proactive-remediations/#monitoring","title":"Monitoring","text":"<p>Tracking the AgentExecutor.log on my test system with an older version of Thin Installer, I see the version is not current.</p> <p></p> <p>Remediation kicks in and downloads the current version.</p> <p></p> <p>Detection reevaluates and shows it's now current.</p> <p></p> <p>Checking back in the Intune console, I can see issues were fixed and all is well.</p> <p></p>"},{"location":"preparing-the-tpm-for-bitlocker-pre-provisioning-using-configmgr/","title":"Preparing the TPM for BitLocker Pre-provisioning using ConfigMgr","text":"<p>There are some definite advantages to pre-provisioning BitLocker. Pre-provisioning the disk will encrypt only used space, so when this step executes, the drive will be encrypted before the operating system has been laid down to the client, saving a ton of time.</p> <p>The catch here is that in order for pre-provisioning to work, a TPM has to be present on the system AND enabled, as stated in the Pre-provision BitLocker step.</p> <p></p> <p>All Lenovo ThinkPads with Discrete TPM 1.2 are shipped from the factory with the TPM enabled but NOT Active. Systems with TPM 2.0 only should already be Enabled. If the system runs through a deployment without activating the TPM in BIOS, pre-provisioning will not work. If you review the OSDOfflineBitlocker.exe section of the smsts.log, you'll see the failure</p> <p></p> <p>In a few simple steps, here's how to activate the TPM on newly shipped systems with Discrete TPM 1.2:</p> <ul> <li> <p>In your Task Sequence, add a new Group named Configure Security Chip after the disk partition step.</p> </li> <li> <p>Add a Run Command Line step with the following command line:</p> </li> </ul> <pre><code>powershell.exe -Executionpolicy Bypass -Command \"(Get-WmiObject -Namespace \"root\\CIMV2\\Security\\MicrosoftTpm\" -Class Win32_TPM).SetPhysicalPresenceRequest(10)\"\n</code></pre> <p>This will enable, activate, and allow the installation of a TPM owner.  (More information on the SetPhysicalPresenceRequest method can be found here.)</p> <ul> <li> <p>Add a Restart Computer step, booting to the boot image assigned to the Task Sequence.</p> </li> <li> <p>Confirm the Enable BitLocker step is near or at the end of the Task Sequence.</p> </li> </ul> <p>That's all! You will notice the computer restart twice for the settings to be applied. Once the deployment finishes, verify BitLocker is in fact on.</p> <p></p> <p>For more control over the Configure Security Chip group, you can add conditions that determines whether or not the group executes. For example, if the Security Chip is already Active and Enabled, it's not really necessary to go through these steps every time.</p>"},{"location":"preparing-the-tpm-for-bitlocker-pre-provisioning-using-configmgr/#recommended","title":"Recommended","text":"<p>In the Configure Security Chip group, add an If any condition with the following two conditions:</p> <ul> <li>WMI Namespace: root\\cimv2\\Security\\MicrosoftTpm</li> <li> <p>WQL Query: SELECT * FROM Win32_Tpm WHERE IsEnabled_InitialValue = False</p> </li> <li> <p>WMI Namespace: root\\cimv2\\Security\\MicrosoftTpm</p> </li> <li>WQL Query: SELECT * FROM Win32_Tpm WHERE IsActivated_InitialValue = False</li> </ul>"},{"location":"preparing-the-tpm-for-bitlocker-pre-provisioning-using-configmgr/#not-recommended-but-can-work","title":"Not recommended but can work","text":"<p>In the Configure Security Chip group, add an If none condition with the following condition:</p> <ul> <li>WMI Namespace: root\\wmi</li> <li>WQL Query: SELECT * FROM Lenovo_BiosSetting WHERE CurrentSetting = 'SecurityChip,Active'</li> </ul> <p>Now when you deploy systems that may already have the Security Chip activated, it will skip this group and continue on.</p>"},{"location":"preparing-the-tpm-for-bitlocker-pre-provisioning-using-configmgr/#notes","title":"Notes","text":"<p>One thing to be aware of is that the value set in WMI for the Security Chip may vary. You can confirm by running this command in PowerShell on your system:</p> <pre><code>(Get-WmiObject -Namespace \"root\\wmi\" -Class Lenovo_BiosSetting).CurrentSetting\n</code></pre> <p>Look for Security Chip and note the value, like below:</p> <p></p> <p>You may encounter on some systems the value is slightly different, i.e. Security Chip,Active or SecurityChip,Enable or Security Chip,Enabled</p> <p>If that's the case, just add another WMI Query to the Configure Security Chip group so it catches all values.</p> <p>Note</p> <p>Systems that have TPM 2.0 only equipped should be enabled by default from the factory. If it's disabled, the below commands can be used to enable it:</p> <pre><code>powershell.exe -Executionpolicy Bypass -Command \"(gwmi \u2013NameSpace root\\wmi \u2013Class Lenovo_SetBIOSSetting).SetBIOSSetting(\u201cSecurityChip,Enable\u201d)\"\n\npowershell.exe -Executionpolicy Bypass -Command \"(gwmi \u2013NameSpace root\\wmi \u2013Class Lenovo_SaveBIOSSettings).SaveBIOSSettings()\"\n</code></pre> <p>Reboot the system and the TPM should now be enabled.</p>"},{"location":"upgrading-tpm-spec-12-to-20-on-thinkpad-using-configmgr-current-branch/","title":"Upgrading TPM Spec 1.2 to 2.0 on ThinkPad using ConfigMgr Current Branch","text":"<p>Now that your Windows 7 to 10 migration is complete, you may want to upgrade the TPM Spec version from 1.2 to 2.0 to take full advantage of Windows 10's security features, like Device Guard and Credential Guard.</p> <p>This can be accomplished with the ThinkPad Setup Settings Capture/Playback Utility (SRSetupWin).  There's actually two separate utilities, with one supporting a broader range of models so take note of the supported systems sections.  Here's a link to both:</p> <p>https://pcsupport.lenovo.com/downloads/DS102568</p> <p>https://pcsupport.lenovo.com/downloads/DS032441</p> <p>There are caveats when using this tool.  A Supervisor Password must be present on the system and the TPM must be cleared prior to converting, which will require physical presence.  That means a tech will have to touch each box.  If you're ok with these requirements and wish to proceed, keep on reading.</p> <p>Tip</p> <p>Supervisor passwords cannot be set initially in an automated way, unless the system supports System Deployment Boot Mode.</p> <p>First, create a Package in your console after you've downloaded and extracted the appropriate utility and distribute the content to your Distribution Points.</p>"},{"location":"upgrading-tpm-spec-12-to-20-on-thinkpad-using-configmgr-current-branch/#task-sequence-overview","title":"Task Sequence Overview","text":"<p>Group 1. Disable BitLocker</p> <p>Assuming the systems have already been deployed and are in full OS, you'll need to suspend BitLocker before anything.  I referenced Mike Terrill's BitLocker template for this.</p> <p>Group 2. Download SRSetup</p> <p>Add a Download Package Content Step, specifying the Package created earlier containing SRSetup. I'm choosing to drop into the ccmcache directory and saving the path as a variable named Content.</p> <p></p> <p>Group 3. Upgrade TPM-ThinkPad</p> <p>I added the following 2 conditions on this group.</p> <p></p> <p></p> <p>Clear TPM</p> <p>Add a Run PowerShell Script step to clear the TPM</p> <pre><code>Get-CimInstance -Namespace root/cimv2/Security/MicrosoftTpm -ClassName Win32_TPM | Invoke-CimMethod -MethodName SetPhysicalPresenceRequest -Arguments @{Request='14'}\n</code></pre> <p>Restart Computer (WinPE)</p> <p>Add a Restart Computer step, selecting to boot to the Boot Image.  This prevents Windows from automatically taking ownership of the TPM, allowing you to perform the upgrade successfully.</p> <p>Upgrade from 1.2 to 2.0</p> <p>Add a Run Command Line step with the command being</p> <pre><code>srsetupwin64.exe /z /fTPM /q /APAP yourbiossupervisorpassword\n</code></pre> <p>or</p> <pre><code>srsetupewin64.exe /z /fTPM /q /APAP yourbiossupervisorpassword\n</code></pre> <p>The /Z switch is undocumented and must be done independently from other BIOS settings changes.  If you have a mix of systems that require you to use both utilities, define conditions on each step to determine which utility executes against the supported system.  WMI logic to query the Win32_ComputerSystemProduct namespace and Version property would suffice.</p> <p>In the Start in: field, enter %Content01%</p> <p></p> <p>Add a Restart Computer step (back into OS) followed by a group to Re-Enable BitLocker.  Once you're logged back in, you can confirm the TPM Spec Version in the TPM Management Console.</p> <p>A new task sequence variable OSDDoNotLogCommand was introduced in ConfigMgr version 1806. When set to True, sensitive data is prevented from being displayed or logged. This only applied to the Install Package step. In version 1902, this variable now applies to Run Command Line steps. If you prefer not having your Supervisor password in clear text, set this variable to True. Here's an example of what this will look like in your log once the srsetup utility is executed:</p> <p></p>"},{"location":"upgrading-tpm-spec-12-to-20-on-thinkpad-using-configmgr-current-branch/#further-reading","title":"Further Reading","text":"<p>SetPhysicalPresenceRequest method of the Win32_Tpm class: https://docs.microsoft.com/en-us/windows/desktop/SecProv/setphysicalpresencerequest-win32-tpm</p> <p>Download Package Content: https://docs.microsoft.com/en-us/sccm/osd/understand/task-sequence-steps#BKMK_DownloadPackageContent</p> <p>Task Sequence Variable Reference: https://docs.microsoft.com/en-us/sccm/osd/understand/task-sequence-variables</p>"},{"location":"deploying-intel-me-firmware--updates-with-intune/","title":"Deploying Intel ME Firmware <br> Updates with Intune","text":"<p>Intel ME firmware have always been a struggle to keep up-to-date. This guide will walk through deploying these updates as a Win32 app.</p>"},{"location":"deploying-intel-me-firmware--updates-with-intune/#preparing-the-win32-app","title":"Preparing the Win32 App","text":"<p>Download the Intel ME Firmware package for your model from the support site. Using the Win32 Content Prep Tool, we'll convert the package to an .intunewin file to upload to Intune.</p> <p>Example command:</p> <pre><code>IntuneWinAppUtil.exe -c \"C:\\IntuneWin32\\Source\\ME\\\" -s n3crg03w.exe -o C:\\IntuneWin32\\\n</code></pre>"},{"location":"deploying-intel-me-firmware--updates-with-intune/#adding-the-win32-app","title":"Adding the Win32 App","text":"<p>Once complete, login to the Intune admin center and add a new Win32 app.</p> <p>Fill out the app information:</p> <p></p> <p>Enter the install command line:</p> <pre><code>n3crg03w.exe /VERYSILENT /DIR=\"C:\\IntelMEFW\" /PARAM=\"/silent\"\n</code></pre> <p>uninstall command line:</p> <p>Required but since you can't uninstall this type of update, we'll simply delete the directory the contents are extracted to</p> <pre><code>cmd.exe /c rmdir C:\\IntelMEFW /s /q\n</code></pre> <p>Change the device restart behavior to Intune will force a mandatory restart. This will allow you to set restart grace periods and restart notifications when you assign it.</p> <p></p> <p>Set requirements. Refer to the package ReadMe for minimum supported operating systems.</p> <p></p> <p>For detection rules, choose to use a custom script for detection. Below is an example PowerShell script that can be used:</p> <pre><code>$DeployedFwVersion = \"16.1.25.1932\"\n$LocalFwVersion = (Get-CimInstance -Namespace root/Intel_ME -ClassName ME_System).FWVersion\n\nif([version]$LocalFwVersion -lt [version]$DeployedFwVersion) {\n    Write-Output -InputObject \"Firmware is outdated...\"; Exit 3010\n} else {\n    Write-Output -InputObject \"Firmware is up-to-date...\"; Exit 0\n}\n</code></pre> <p>Finish creating the Win32 app. Before assigning it, I'm going to create a Device Filter that only contains T14s Gen 3's so the app will only target these models.</p> <p>The syntax for the filter is:</p> <pre><code>(device.model -startsWith \"21BR\") or (device.model -startsWith \"21BS\")\n</code></pre>"},{"location":"deploying-intel-me-firmware--updates-with-intune/#deploymonitor","title":"Deploy/Monitor","text":"<p>For my testing, I assigned the app to All Devices and only including T14s Gen 3's using the device filter I just created.</p> <p></p> <p>As I mentioned earlier, you can configure restart grace periods, restart notifications, and/or allowing the user to snooze the restart notification.</p> <p></p> <p>Once the app finishes installing, a toast notification is presented prompting for a reboot.(This screenshot was taken from an L14)</p> <p></p>"},{"location":"hosting-a-repository-in-an-azure-blob/","title":"Hosting a repository in an Azure blob","text":"<p>System Update v5.07.0110 and later supports Blob storage access via HTTPS</p> <p>When it comes to managing a centralized Update Retriever repository, challenges arise with widely distributed environments.  This is where leveraging a cloud storage solution can bring value.</p> <p>This post may be helpful for anyone piloting a \"modern\" way of updating their Think products.  This walk-through assumes the following tools are in place:</p> <ul> <li>Update Retriever</li> <li>Thin Installer or System Update on the client</li> <li>Azure Blob Container (a free trial account with an included 5gb limit is what I used here)</li> </ul> <p>I won't cover creating the Storage account or Blob, just the process of uploading the Update Retriever content to the Blob container and how to configure the ThinInstaller Configuration XML on the client. Note though, the Container access level should be set to Blob (anonymous read access for blobs only).</p>"},{"location":"hosting-a-repository-in-an-azure-blob/#populating-the-update-retriever-repository","title":"Populating the Update Retriever repository","text":"<p>First, you'll need to download any new updates to your local machine or network share. Currently, you can only set a repository location to a local drive or UNC path.</p> <p></p> <p>You can take advantage of configuring your Update Retriever repository as a \"Lenovo cloud repository\" so that only the package XML's will be downloaded rather than the full updates.  This process is covered here. Once all updates are downloaded successfully, you'll need to upload them to the Blob.  There's a few different ways to accomplish this. </p> <ul> <li>Install Azure Storage Explorer and upload the folder containing the updates, database.xml, and database.xsd.</li> <li>Upload the content using AzCopy (latest version can be downloaded here)</li> <li>Upload the content using the Set-AzStorageBlobContent cmdlet.</li> </ul> <p>Method 1: Storage Explorer Authenticate to your Storage account, navigate to the folder containing your updates and choose to upload by folder.</p> <p></p> <p>Once complete, you should see all data uploaded in the Activities pane.</p> <p></p> <p>Method 2: AzCopy You'll need a few more pieces of information before uploading with AzCopy.</p> <ul> <li>Blob Container URL (Storage Account/Blobs/Blob Container/Properties)</li> </ul> <p></p> <ul> <li>Storage Account Access Keys (There will be 2 keys presented.  Either can be used) or a SAS token.  It's highly recommended to use a SAS token.</li> </ul> <p></p> <p>With this information, you should now be able to upload the content.  Starting in AzCopyv10, you can sync directories.  Here's a sample command to execute using AzCopy:</p> <pre><code>AzCopy.exe sync 'C:\\lenovoUpdates' 'https://your-blob.core.windows.net/updateretriever&lt;SASToken&gt;' --delete-destination true\n</code></pre> <p>The results will look something like this</p> <p></p> <p>Method 3: PowerShell Similar to AzCopy but instead using the Set-AzStorageBlobContent cmdlet.  You'll need the Azure PowerShell module installed first.  Below is a simple, sample script that was pieced together from the examples provided by the MS docs.</p> <pre><code>$srcPath = \"C:\\lenovoUpdates\"\n$token = \"your-sas-token\"\n$containerName = 'your-container-name'\n$storageContext = New-AzStorageContext -StorageAccountName 'your-storage-account' -SasToken $token\n\nls -File $srcPath -Recurse | Set-AzStorageBlobContent `\n  -Container $containerName `\n  -BlobType Block `\n  -Context $storageContext -Force\n</code></pre> <p>An example capture once the upload kicks off</p> <p></p>"},{"location":"hosting-a-repository-in-an-azure-blob/#client-side-configuration","title":"Client side configuration","text":""},{"location":"hosting-a-repository-in-an-azure-blob/#thin-installer","title":"Thin Installer","text":"<p>Now that the repository is ready, you'll need to make a quick change to the Thin Installer Configuration XML to direct the client to the Blob container.  Open the ThinInstaller.exe.configuration file and set the new repo path the Blob Container URL as noted earlier. </p> <p></p> <p>When Thin Installer is launched it will connect to the Update Retriever repository in Azure.</p> <p></p>"},{"location":"hosting-a-repository-in-an-azure-blob/#system-update","title":"System Update","text":"<p>Simply update the AdminCommandLine registry value to point to your Blob URL.  An example command line would be:</p> <pre><code>/CM -search A -action LIST -includerebootpackages 1,3,5 -packagetypes 1,2,3,4 -nolicense -repository https://yourblob.blob.core.windows.net/repository -exporttowmi \n</code></pre> <p>Refer to the System Update Suite Deployment Guide for available command line options.</p>"},{"location":"revisiting-update-retriever-and-azure-blob-storage/","title":"Revisiting Update Retriever and Azure Blob Storage","text":"<p>This is a follow up to a previous article that walked through hosting an on-prem Update Retriever repository in an Azure Blob Storage.</p> <p>If you've started leveraging cloud storage for your driver repository, this solution may be of interest to you if you're at a roadblock with how to deploy BIOS updates to your endpoints.</p> <p>The main focus of this article is a rather hot topic: Silently installing BIOS and firmware updates.</p> <p>Historically, BIOS packages prompted the user to proceed with the update followed by a forced reboot. In later models, BIOS and firmware packages present a 5 minute countdown timer before the system force reboots. In an enterprise, suppressing these prompts and preventing any forced reboots is extremely important.</p> <p>This solution assumes you have an on-prem Update Retriever repository and Azure Blob Storage already in place.</p>"},{"location":"revisiting-update-retriever-and-azure-blob-storage/#entra-app-registration","title":"Entra App Registration","text":"<p>For authentication, I'm using a Service Principal, which the example script uses.</p> <p>Generate a client secret and save its value. It will be used in the script, along with the application (client) ID.</p>"},{"location":"revisiting-update-retriever-and-azure-blob-storage/#service-principal-role-assignments","title":"Service Principal Role Assignments","text":"<p>After you've registered a new Entra app, you'll need to assign a few roles to the service principal to allow content to be transferred to the Blob container. In my tenant, I set the scope at the resource level.</p> <ol> <li> <p>Browse to your Storage Account where the Blob container resides and select Access control (IAM).</p> </li> <li> <p>Select Add, then select Add role assignment.</p> </li> <li> <p>In the Role tab, select Storage Account Contributor and Storage Blob Data Contributor.</p> </li> <li> <p>Select Next.</p> </li> <li> <p>On the Members tab, for Assign access to, select User, group, or service principal.</p> </li> <li> <p>Select Select members. Search for the Entra app you created earlier since Entra apps aren't displayed in the available options by default.</p> </li> <li> <p>Select the Select button, then select Review + assign.</p> </li> </ol>"},{"location":"revisiting-update-retriever-and-azure-blob-storage/#downloading-bios-and-firmware-updates","title":"Downloading BIOS and Firmware Updates","text":"<p>Since we have to modify the packages, make sure your Update Retriever repository is configured as a Local repository.</p> <p>Launch Update Retriever and select the models you want to get updates for.</p> <p>Select BIOS and Firmware packages to download (and/or drivers).</p> <p>Once the packages are downloaded, click Manage repository &gt; Update view, you'll see the Reboot type is Reboot Delayed.</p> <p></p>"},{"location":"revisiting-update-retriever-and-azure-blob-storage/#xml-change-and-repository-sync","title":"XML Change and Repository Sync","text":"<p>With some PowerShell, we can save time by automatically altering the package XML descriptors to support a completely silent installation of BIOS and firmware updates using Thin Installer. After running the code, the output will show which package XML's were modified or skipped, the AzCopy statistics, and the log file path for more details.</p> <p></p> <p>If you refresh the view in Update Retriever, you'll see the Reboot type is now Requires a reboot.</p> <p></p> <p>The script can be found on my GitHub:</p> <p>https://github.com/philjorgensen/Azure/blob/main/Blob/Sync-Repositories.ps1</p>"},{"location":"revisiting-update-retriever-and-azure-blob-storage/#scenario","title":"Scenario","text":"<p>The following Thin Installer command line will pull these packages down for a silent installation</p> <pre><code>.\\ThinInstaller.exe /CM -search A -action INSTALL -includerebootpackages 3 -packagetypes 3,4 -noicon -repository https://storageaccount.blob.core.windows.net/bios-repository -ignorexmlsignature -noreboot -exporttowmi\n</code></pre> <p>-includerebootpackages 3 filters for Reboot required packages</p> <p>-packagetypes 3,4 filters for only BIOS and Firmware packages</p>"},{"location":"revisiting-update-retriever-and-azure-blob-storage/#reference","title":"Reference","text":"<p>Refer to the System Update Deployment Guide for additional Thin Installer usage</p> <p>https://docs.lenovocdrt.com/guides/sus/su_dg/su_dg_ch5/#52-thin-installer</p>"},{"location":"hosting-a-repository-in-an-azure-file-share/","title":"Hosting a repository in an Azure file share","text":"<p>This option leverages the Lenovo cloud repository feature in Update Retriever.  By choosing this option, only the package XML's will be downloaded to the repository while the full content will be hosted by Lenovo.</p> <p></p> <p>If you're moving your on-prem repository to the cloud, this option will most definitely cut down storage costs as these XML's are only a couple of Kilobytes in size.</p> <p>A few things to note before exploring this route:</p> <ul> <li>System Update (version 5.07.0046 and later) is supported</li> <li>Commercial Vantage is supported</li> <li>Thin Installer is NOT supported</li> </ul>"},{"location":"hosting-a-repository-in-an-azure-file-share/#creating-the-storage-account","title":"Creating the Storage Account","text":"<p>You'll need to create a new storage account first.  During the creation, make sure you set the account kind to StorageV2 since we're going to be using this as an Azure file share.</p> <p>After creation, go to the new storage account and scroll down to the File service section and click File shares.  Click +File share, give it a name and click Create.</p> <p>The URL of the share can be found in Properties</p> <p></p> <p>You'll need to take note of one of the Access keys for the storage account, which will be used to later on.  These can be found under Settings + networking.</p> <p></p> <p>If you need to lock down access to specific vNets and/or IP ranges, you can configure this under Networking.</p>"},{"location":"hosting-a-repository-in-an-azure-file-share/#populating-the-update-retriever-repository","title":"Populating the Update Retriever repository","text":"<p>Install the latest version of Update Retriever on a technician system.  We're going to use cmdkey to store the Azure storage account credentials.  Launch PowerShell and enter the following command (replacing the storage account name and access key):</p> <pre><code>Invoke-Expression -Command \"cmdkey /add:&lt;storageaccountname&gt;.file.core.windows.net /user:Azure\\&lt;storageaccountname&gt; /pass:&lt;accesskey&gt;\"\n</code></pre> <p>You should see cmdkey return a Credential added successfully message.  You can verify by opening Credential Manager and looking under Windows Credentials.</p> <p>Now, launch Update Retriever and select Lenovo Cloud repository.  Instead of entering the URL of the file share, enter it as a UNC path:</p> <p></p> <p>Set any other options and click Continue.  You may see a spinning wheel for a bit but will eventually proceed to the Get new updates screen.  Here you can add your MTM's and check for updates.  You should see Update Retriever connect to your Azure file share and download content.</p> <p>If you look in Event Viewer under Applications and Services Logs &gt; Lenovo &gt; ThinkVantage &gt; UpdateRetriever and look through the This is the operational log of ThinkVantage UpdateRetriever log, you'll see Events like this:</p> <p></p> <p>Back in the Azure portal, navigate to your file share and you should now see all of the package ID directories with corresponding .xml's, as well as the database.xml.</p> <p> </p>"},{"location":"hosting-a-repository-in-an-azure-file-share/#client-side-configuration","title":"Client side configuration","text":"<p>We need to upload and deploy a PowerShell script to add the Azure storage account credentials on the client.  Unfortunately, SAS tokens aren't supported with SMB access so one option is to use a Storage Account Access Key.</p> <p>Copy the same command that was used earlier into a .ps1 file and add it to Device Scripts in the MEM admin center.</p> <p>Set the Script settings to:</p> <p>Run this script using the logged on credentials - Yes Run script in 64 bit PowerShell host - Yes</p> <p>Assign to a group.</p> <p>Verify the System Update scheduled task has been configured.  Refer to the System Update Deployment Guide.</p> <p>To confirm everything works, manually start the scheduled task and monitor the tvsu_timestamp.log which can be found under %ProgramData%\\Lenovo\\SystemUpdate\\logs</p> <p>I can see the client connects to the repository and finds the database.xml</p> <p></p> <p>And further down the log, once the client parses through the database.xml for applicable updates, the packages are downloaded from Lenovo</p> <p></p> <p>I've set my AdminCommandLine to list the updates so I can select which ones to install.</p> <pre><code>/CM -search A -action LIST -includerebootpackages 3,5 -noreboot -noicon -exporttowmi\n</code></pre> <p>And here's a screenshot of updates that are applicable to download and install</p> <p></p> <p>If you're using Commercial Vantage, ensure you've configured the Local Repository GPO to point to the UNC of your Azure file share.</p> <p>Further reading: https://docs.microsoft.com/en-us/azure/storage/files/storage-files-faq#security-authentication-and-access-control</p>"},{"location":"introducing-the-manage-driver-packs-feature/","title":"Introducing the Manage Driver Packs Feature","text":""},{"location":"introducing-the-manage-driver-packs-feature/#what-is-it","title":"What is it?","text":"<p>This feature allows an admin to create a collection of the hardware drivers for a specified model in a format that can be imported into Microsoft System Center Configuration Manager (SCCM) or Microsoft Deployment Toolkit (MDT) to support OS Deployment.</p>"},{"location":"introducing-the-manage-driver-packs-feature/#how-is-it-different","title":"How is it different?","text":"<p>This feature presents a list of only hardware drivers for a specified model based on what is currently available on the Lenovo Support web site instead of basing search results on content ready for use with System Update or Thin Installer. NOTE: Only Windows 10 and 11 is in scope for this feature.</p>"},{"location":"introducing-the-manage-driver-packs-feature/#who-would-use-this","title":"Who would use this?","text":"<p>IT administrators that are performing custom imaging using SCCM and MDT always need to start with a set of hardware drivers specific to a model in order to get the best results. Any IT admin that wants to reduce the amount of time this process takes AND wants to use only the very latest drivers released will gain an advantage using this feature.</p>"},{"location":"introducing-the-manage-driver-packs-feature/#walkthrough","title":"Walkthrough","text":"<ol> <li> <p>Launch Update Retriever </p> </li> <li> <p>Select download location and model </p> </li> <li> <p>Select specific drivers </p> </li> <li> <p>Update Retriever downloads an extracts selected drivers </p> </li> <li> <p>Now you have collection of source files for a driver package... </p> </li> </ol> <p>...and a CSV report file </p>"},{"location":"introducing-the-manage-driver-packs-feature/#q-a","title":"Q &amp; A","text":"<p>Why only Windows 10 and 11?</p> <p>Windows 7 driver content available from Lenovo Support web site does not always have the INF installable source files directly accessible. With Windows 10 and later, there is a requirement for all hardware drivers to be INF installable so we are able to achieve consistent results only with Windows 10 and later drivers.</p> <p>What Lenovo products are supported?</p> <p>This feature will be limited to ThinkPad, ThinkCentre and ThinkStation products launched in 2018 and going forward. Content for older products did not meet the packaging requirements necessary to ensure consistent results by this feature.</p> <p>Why is there a difference in the content normally offered by Update Retriever and the content available through this feature?</p> <p>The content that you would normally manage in an Update Retriever content is designed to be used by System Update, Thin Installer, etc. There is additional work that occurs to enable these tools to automate the installation of this content and therefore it takes longer for the updates to become available. This new feature simply relies on the packages available for download and manual installation which become available sooner.</p> <p>What is the difference between a driver pack created with this feature versus the \u201cSCCM Driver Packs\u201d available for download from Lenovo Support web site?</p> <p>There are a few differences:</p> <ol> <li> <p>The SCCM driver packs available for download are created and validated as a set. Due to the time required to produce and publish these there can sometimes be newer drivers on the Lenovo Support web site than what is in a pack. Using this feature in Update Retriever will provide the most current drivers available.</p> </li> <li> <p>The SCCM driver packs contain all of the hardware drivers that could be needed for a model. Depending on the particular model you have, there may be drivers that are not needed in the pack. Using this feature in Update Retriever you can control exactly which drivers you include.</p> </li> <li> <p>In order to leverage the most current drivers, the package that is published for manual download and install is being used by this feature. In order to support the manual installation there may be some files in the package that are not necessary for OS deployment using SCCM or MDT. These files are typically removed from SCCM driver packs. Note: if the source files are imported into SCCM or MDT, only the files referenced specifically by an INF will be imported so the effect is minimal.</p> </li> </ol> <p>Are BIOS and firmware updates covered?</p> <p>No, this new feature is intended to support the OS deployment process of new drivers which only works with INF installable hardware drivers. Application updates and firmware updates cannot be included.</p>"},{"location":"automate-partition-sizes-when-using-windows-11-iso/","title":"Automate Partition Sizes When Using Windows 11 ISO","text":"<p>As more corporate customers are moving to Intune and other cloud based tools for device management, there has been and probably will continue to be a decrease in the use of imaging technologies to deploy operating systems to devices.  Most of the time, customers are using the OEM provided preload on the device as the initial operating system installation.  Customers then leverage tools to continue with device configuration until the desired state is met.</p>"},{"location":"automate-partition-sizes-when-using-windows-11-iso/#automating-partition-sizes-when-installing-windows-from-an-iso","title":"Automating Partition Sizes When Installing Windows From An ISO","text":"<p>Using the OEM provided preload is an excellent choice for the initial operating system installation, but what happens when there is a need to reload Windows and there is no MDT or Configuration Manager to rely on?  The answer is to use the Windows ISO to load Windows on the device.  Customers have noted that when using the Windows 11 ISO to install Windows, they cannot update BIOS/UEFI and or Firmware on the device.  The following questions arise when we discuss utilizing the Windows 11 ISO to install Windows.</p> <ul> <li>How does an IT department standardize the drive configuration?</li> <li>What is the best method to guarantee enough space is allocated to the EFI System Partition (ESP) for booting the device and OEM tooling?</li> <li>Can we dynamically size the Operating System partition to maximize the drive space available to the end user?</li> <li>How do we guarantee the Recovery partition is the last partition on the drive?</li> <li>Can we prevent the Recovery partition from being grossly over provisioned?</li> </ul> <p>The solution to all of these questions is fairly simple and does not require specialized tools to implement with exception of the Windows ADK being installed to a system.</p>"},{"location":"automate-partition-sizes-when-using-windows-11-iso/#the-solution","title":"The Solution","text":"<p>To solve the above scenario, we can leverage the Windows 11 ISO and include an AutoUnattend.xml file, a start-configuration.bat file to call a diskpart script, and the configure-partitions.txt diskpart script file to configure drive.  The AutoUnattend.xml will define the disk and partition to install the operating sytem as well as directing setup to execute the batch file prior to running the Setup Wizard.  The executed batch file will first ask for a confirmation to erase the disk and, upon receiving the acknowledgement, will call the diskpart script to format and partition disk 0.  The diskpart script information will configure the disk as follows:</p> <ul> <li>Partition 1 set as an EFI System Partition (ESP) formatted as FAT32 with a size of 500 MB and has a label of System.</li> <li>Partition 2 set as a Microsoft System Reserved (MSR) Partition with a size of 16 MB</li> <li>Partition 3 set as a Primary Partition formatted as NTFS with a size set dynamically and has a label of Windows</li> <li>Partition 4 set as a Recovery Partition formatted as NTFS with a size of 990 MB and a label of Recovery</li> </ul> <p>The goal is to meet OEM space needs, meet Windows requirements by exceeding the Microsoft minimums, and by the end of the task, still provision enough space for end users to work effectively.</p>"},{"location":"automate-partition-sizes-when-using-windows-11-iso/#additional-partitioning-information","title":"Additional Partitioning Information","text":"<p>After researching, we have found the EFI System Partition size should be more than the 200 MB defined by the Microsoft default configuration information found in the technical documentation.  Beyond Microsoft using the EFI System Partition to boot the device, OEMs leverage this partition, hosting files used to update the BIOS/UEFI as well as system and component firmware.  Due to the size of BIOS/UEFI and Firmware updates, the default 100 MB EFI System Partition size can be quickly be exceeded, which is why we recommend the size increase.</p> <p>For the Windows Primary Partition, we essentially allow diskpart to partition the remaining free space on the drive.  Once the partition is created, we shrink that partition down by the amount of space we want to allocate to the Recovery Partition, which in this case configured to occupy the last 990 MB on the disk.</p>"},{"location":"automate-partition-sizes-when-using-windows-11-iso/#the-preparation","title":"The Preparation","text":"<ol> <li>Create the following folder structure.  The structure listed will correlate to the steps in the [[#Building the ISO]] section.<ul> <li>C:\\W11</li> <li>C:\\Mount</li> <li>C:\\ExtraFiles</li> </ul> </li> <li>Using the AutoUnattend.xml, Start-Configuration.bat, and Configure-Partitions.txt code at the end of this article, create each file in the C:\\ExtraFiles directory.</li> <li>Obtain the Windows 11 ISO file.</li> <li>Right click on the Windows 11 ISO file and choose the Mount option.</li> <li>Copy the entire folder structure and files from the mounted ISO to the C:\\W11 directory.</li> <li>Download and install the latest Windows ADK.  This installation is required for access to the OSCDIMG.exe to create the updated ISO file.</li> </ol>"},{"location":"automate-partition-sizes-when-using-windows-11-iso/#building-the-iso","title":"Building the ISO","text":"<ol> <li>Open Start &gt; Windows Kits &gt; Deployment and Imaging Tools Environment.  Be sure to run this using the Run As Administrator option.  To do this, right click on the Deployment and Imaging Tools Environement and choose \"More &gt;\" and then Run As Administrator.</li> <li>Mount boot.wim index:2     a. dism /Mount-Wim /WimFile:C:\\w11\\sources\\boot.wim /index:2 /MountDir:C:\\Mount</li> <li>Copy the start-configuration.bat and configure-partitions.txt files from C:\\ExtraFiles to C:\\Mount\\Windows\\System32</li> <li>Unmount boot.wim index:2     a. dism /unmount-wim /mountdir:C:\\Mount /commit</li> <li>Copy the autounattend.xml file from C:\\ExtraFiles to C:\\W11</li> <li>Create new ISO     a. oscdimg -lW11 -m -u2 -bC:\\W11\\efi\\microsoft\\boot\\efisys.bin C:\\W11\\ C:\\W11_Prompt.iso</li> </ol> <p>Tip</p> <p>To remove the \"Press any key to boot from CD/DVD...\" prompt, change the oscdimg commmand to the following: oscdimg -lW11 -m -u2 -bC:\\W11\\efi\\microsoft\\boot\\efisys_noprompt.bin C:\\W11\\ C:\\W11_NoPrompt.iso</p>"},{"location":"automate-partition-sizes-when-using-windows-11-iso/#using-the-iso","title":"Using the ISO","text":"<ol> <li>Using your favorite tool, apply the newly created ISO file to a USB drive.</li> <li>Plug the USB drive into the computer</li> <li>Power on the computer, enter the boot menu, and select the boot option for the USB drive.</li> <li>If needed, press any key to continue the boot process.</li> <li>At the command prompt, read the message and choose Y to erase the disk and use the partitions steps provided.  If you do not want to erase the disk, press N and the device will shutdown.</li> <li>After the formatting and partitioning of the disk has completed, navigate through the Setup Wizard, making appropriate choices.</li> <li>Once you finish the wizard, the device will begin to install Windows and will stop at OOBE.</li> </ol>"},{"location":"automate-partition-sizes-when-using-windows-11-iso/#scripts","title":"Scripts","text":""},{"location":"automate-partition-sizes-when-using-windows-11-iso/#autounattendxml","title":"AutoUnattend.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;unattend xmlns=\"urn:schemas-microsoft-com:unattend\"&gt;\n    &lt;settings pass=\"windowsPE\"&gt;\n        &lt;component name=\"Microsoft-Windows-Setup\" processorArchitecture=\"amd64\" publicKeyToken=\"31bf3856ad364e35\" language=\"neutral\" versionScope=\"nonSxS\" xmlns:wcm=\"http://schemas.microsoft.com/WMIConfig/2002/State\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;\n            &lt;DiskConfiguration&gt;\n                &lt;WillShowUI&gt;OnError&lt;/WillShowUI&gt;\n            &lt;/DiskConfiguration&gt;\n        &lt;RunSynchronous&gt;\n        &lt;RunSynchronousCommand wcm:action=\"add\"&gt;\n                    &lt;Path&gt;cmd.exe /c \"%systemroot%\\System32\\start-configuration.bat\"&lt;/Path&gt;\n                    &lt;Description&gt;Initiate Disk and Partition Configuration&lt;/Description&gt;\n                    &lt;Order&gt;1&lt;/Order&gt;\n        &lt;/RunSynchronousCommand&gt;\n        &lt;/RunSynchronous&gt;\n        &lt;ImageInstall&gt;\n                &lt;OSImage&gt;\n                    &lt;InstallTo&gt;\n                        &lt;DiskID&gt;0&lt;/DiskID&gt;\n                        &lt;PartitionID&gt;3&lt;/PartitionID&gt;\n                    &lt;/InstallTo&gt;\n                &lt;/OSImage&gt;\n            &lt;/ImageInstall&gt;\n        &lt;/component&gt;\n    &lt;/settings&gt;\n&lt;/unattend&gt;\n</code></pre>"},{"location":"automate-partition-sizes-when-using-windows-11-iso/#start-configurationbat","title":"Start-Configuration.bat","text":"<pre><code>@echo off\nsetlocal\n:PROMPT\nEcho This process is destructive and will wipe the disk. All data on the drive will be lost.\nEcho Press Y to wipe the drive and use the preconfigured settings.\nEcho Press N to discontinue the process and shutdown the computer.\n\nSET /P AREYOUSURE=Do you want to continue (Y/[N])?\nIF /I \"%AREYOUSURE%\" EQU \"Y\" GOTO CONFIGURE\nwpeutil shutdown\n\n:CONFIGURE\ndiskpart /s \"%systemroot%\\System32\\configure-partitions.txt\"\nendlocal\n</code></pre>"},{"location":"automate-partition-sizes-when-using-windows-11-iso/#configure-partitionstxt","title":"Configure-Partitions.txt","text":"<pre><code>rem === disk configuration ===\nselect disk 0\nclean\nconvert gpt\nrem === EFI Partition ===\ncreate partition efi size 500\nformat quick fs=fat32 label=\"System\"\nassign letter=S\nrem === MSR Partition ===\ncreate partition msr size=16\nrem === Windows Primary Partition ===\ncreate partition primary\nshrink minimum=990\nformat quick fs=ntfs label=\"Windows\"\nassign letter=W\nrem === Recovery Partition ===\ncreate partition primary size=990\nformat quick fs=ntfs label=\"Recovery\"\nset id=de94bba4-06d1-4d40-a16a-bfd50179d6ac\ngpt attributes=0x8000000000000001\nassign letter=R\n</code></pre>"},{"location":"archive/2025/","title":"2025","text":""},{"location":"archive/2024/","title":"2024","text":""},{"location":"archive/2023/","title":"2023","text":""},{"location":"archive/2022/","title":"2022","text":""},{"location":"archive/2021/","title":"2021","text":""},{"location":"archive/2020/","title":"2020","text":""},{"location":"archive/2019/","title":"2019","text":""},{"location":"archive/2018/","title":"2018","text":""},{"location":"archive/2017/","title":"2017","text":""},{"location":"page/2/","title":"Welcome to the ThinkDeploy Blog rss","text":""},{"location":"page/3/","title":"Welcome to the ThinkDeploy Blog rss","text":""},{"location":"page/4/","title":"Welcome to the ThinkDeploy Blog rss","text":""},{"location":"page/5/","title":"Welcome to the ThinkDeploy Blog rss","text":""},{"location":"page/6/","title":"Welcome to the ThinkDeploy Blog rss","text":""}]}